/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _three = __webpack_require__(2);

	var _three2 = _interopRequireDefault(_three);

	var _Viewer = __webpack_require__(3);

	var _Viewer2 = _interopRequireDefault(_Viewer);

	var _PLYLoader = __webpack_require__(16);

	var _PLYLoader2 = _interopRequireDefault(_PLYLoader);

	var _ExtrinsicsLoader = __webpack_require__(17);

	var _ExtrinsicsLoader2 = _interopRequireDefault(_ExtrinsicsLoader);

	var _getURLParams = __webpack_require__(18);

	var _getURLParams2 = _interopRequireDefault(_getURLParams);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var loader, model, light, axes, extrinsics;

	var submit = document.getElementById('submit');
	submit.onclick = function () {
	  console.log('HERRO!');
	};

	// Load URL parameters
	var params = (0, _getURLParams2.default)();
	var label = params.label === undefined ? 'glue' : params.label;
	var frame = params.frame === undefined ? 0 : params.frame;
	frame = 'frame-' + String('000000' + frame).slice(-6);

	var extrinsicsLoader = new _ExtrinsicsLoader2.default();

	extrinsicsLoader.load('./test/data/' + frame + '.pose.txt', function (matrix) {
	  // extrinsics = new THREE.Matrix4();
	  // extrinsics.getInverse(matrix);
	  extrinsics = matrix;
	  console.log(extrinsics);
	});

	var viewer = new _Viewer2.default(document.getElementById("container"), {
	  path: './data/resources/pointclouds/' + frame + '/cloud.js',
	  cameraPosition: null, // other options: cameraPosition: [10,10,10],
	  cameraTarget: null, // other options: cameraTarget: [0,0,0],
	  fov: 60, // field of view in degrees,
	  sizeType: "Adaptive", // other options: "Fixed", "Attenuated"
	  quality: null, // other options: "Circles", "Interpolation", "Splats"
	  material: "RGB", // other options: "Height", "Intensity", "Classification"
	  pointLimit: 1, // max number of points in millions
	  pointSize: 1, //
	  navigation: "Transform", // other options: "Orbit", "Flight"
	  useEDL: false
	}, {
	  "onPointCloudLoaded": function onPointCloudLoaded(event) {}
	});

	loader = new _PLYLoader2.default();

	loader.load('./test/data/glue.ply', function (geometry) {
	  // var position = new THREE.Vector3();
	  // var lookAt = new THREE.Vector3();
	  // var up = new THREE.Vector3();

	  // position.copy(viewer.camera.position);
	  // lookAt.copy(viewer.camera.getWorldDirection());
	  // up.copy(viewer.camera.up);

	  // var rotation = new THREE.Quaternion();
	  // var position = new THREE.Vector3();

	  // rotation.setFromRotationMatrix(extrinsics);
	  // position.setFromMatrixPosition(extrinsics);
	  // console.log(rotation, position);

	  // viewer.camera.matrixWorldInverse.getInverse(extrinsics);
	  // console.log(viewer.camera.matrixWorldInverse)
	  // viewer.camera.updateMatrix();
	  // viewer.camera.up.applyMatrix4(extrinsics);
	  // lookAt.applyMatrix4(extrinsics);
	  // viewer.camera.lookAt(lookAt);
	  // viewer.camera.up = new THREE.Vector3(0, 0, 1);
	  // viewer.camera.position.copy(new THREE.Vector3());
	  // viewer.camera.quaternion.copy(new THREE.Quaternion());
	  // viewer.camera.position.setFromMatrixPosition(extrinsics);
	  // viewer.camera.quaternion.setFromRotationMatrix(extrinsics);

	  // console.log(viewer.camera.position, viewer.camera.quaternion);

	  var material = new _three2.default.MeshPhongMaterial({ color: 0xffffff, shading: _three2.default.FlatShading });
	  model = new _three2.default.Mesh(geometry, material);
	  viewer.scene.add(model);

	  configControls(viewer);
	  viewer.controls.attach(model);

	  axes = new _three2.default.AxisHelper(5);
	  viewer.scene.add(axes);
	});

	light = new _three2.default.DirectionalLight(0xffffff);
	light.position.set(1, 1, 1);
	viewer.scene.add(light);

	light = new _three2.default.DirectionalLight(0x002288);
	light.position.set(-1, -1, -1);
	viewer.scene.add(light);

	light = new _three2.default.AmbientLight(0x222222);
	viewer.scene.add(light);

	function configControls(viewer) {
	  window.addEventListener('keydown', function (event) {
	    console.log(event.keyCode, 'pressed!');

	    switch (event.keyCode) {

	      case 81:
	        // Q
	        viewer.controls.setSpace(viewer.controls.space === "local" ? "world" : "local");
	        break;

	      case 17:
	        // Ctrl
	        viewer.controls.setTranslationSnap(100);
	        viewer.controls.setRotationSnap(_three2.default.Math.degToRad(15));
	        break;

	      case 87:
	        // W
	        viewer.controls.setMode("translate");
	        break;

	      case 69:
	        // E
	        viewer.controls.setMode("rotate");
	        break;

	      case 82:
	        // R
	        viewer.controls.setMode("scale");
	        break;
	      case 84:
	        // T
	        model.position.copy(viewer.controls.target);
	        break;

	      case 65:
	        //
	        viewer.controls.reset();
	        break;

	      case 187:
	      case 107:
	        // +, =, num+
	        viewer.controls.setSize(viewer.controls.size + 0.1);
	        break;

	      case 189:
	      case 109:
	        // -, _, num-
	        viewer.controls.setSize(Math.max(viewer.controls.size - 0.1, 0.1));
	        break;

	      case 90:
	        // Z
	        console.log(model);
	        console.log(viewer.controls);
	        break;
	    }
	  });

	  window.addEventListener('keyup', function (event) {

	    switch (event.keyCode) {

	      case 17:
	        // Ctrl
	        viewer.controls.setTranslationSnap(null);
	        viewer.controls.setRotationSnap(null);
	        break;
	    }
	  });
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var self = self || {};// File:src/Three.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var THREE = { REVISION: '71' };

	// browserify support

	if ( true ) {

		module.exports = THREE;

	}

	// polyfills

	if ( Math.sign === undefined ) {

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function ( x ) {

			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : +x;

		};

	}


	// set the default log handlers
	THREE.log = function() { console.log.apply( console, arguments ); }
	THREE.warn = function() { console.warn.apply( console, arguments ); }
	THREE.error = function() { console.error.apply( console, arguments ); }


	// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

	THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

	// GL STATE CONSTANTS

	THREE.CullFaceNone = 0;
	THREE.CullFaceBack = 1;
	THREE.CullFaceFront = 2;
	THREE.CullFaceFrontBack = 3;

	THREE.FrontFaceDirectionCW = 0;
	THREE.FrontFaceDirectionCCW = 1;

	// SHADOWING TYPES

	THREE.BasicShadowMap = 0;
	THREE.PCFShadowMap = 1;
	THREE.PCFSoftShadowMap = 2;

	// MATERIAL CONSTANTS

	// side

	THREE.FrontSide = 0;
	THREE.BackSide = 1;
	THREE.DoubleSide = 2;

	// shading

	THREE.NoShading = 0;
	THREE.FlatShading = 1;
	THREE.SmoothShading = 2;

	// colors

	THREE.NoColors = 0;
	THREE.FaceColors = 1;
	THREE.VertexColors = 2;

	// blending modes

	THREE.NoBlending = 0;
	THREE.NormalBlending = 1;
	THREE.AdditiveBlending = 2;
	THREE.SubtractiveBlending = 3;
	THREE.MultiplyBlending = 4;
	THREE.CustomBlending = 5;

	// custom blending equations
	// (numbers start from 100 not to clash with other
	//  mappings to OpenGL constants defined in Texture.js)

	THREE.AddEquation = 100;
	THREE.SubtractEquation = 101;
	THREE.ReverseSubtractEquation = 102;
	THREE.MinEquation = 103;
	THREE.MaxEquation = 104;

	// custom blending destination factors

	THREE.ZeroFactor = 200;
	THREE.OneFactor = 201;
	THREE.SrcColorFactor = 202;
	THREE.OneMinusSrcColorFactor = 203;
	THREE.SrcAlphaFactor = 204;
	THREE.OneMinusSrcAlphaFactor = 205;
	THREE.DstAlphaFactor = 206;
	THREE.OneMinusDstAlphaFactor = 207;

	// custom blending source factors

	//THREE.ZeroFactor = 200;
	//THREE.OneFactor = 201;
	//THREE.SrcAlphaFactor = 204;
	//THREE.OneMinusSrcAlphaFactor = 205;
	//THREE.DstAlphaFactor = 206;
	//THREE.OneMinusDstAlphaFactor = 207;
	THREE.DstColorFactor = 208;
	THREE.OneMinusDstColorFactor = 209;
	THREE.SrcAlphaSaturateFactor = 210;


	// TEXTURE CONSTANTS

	THREE.MultiplyOperation = 0;
	THREE.MixOperation = 1;
	THREE.AddOperation = 2;

	// Mapping modes

	THREE.UVMapping = 300;

	THREE.CubeReflectionMapping = 301;
	THREE.CubeRefractionMapping = 302;

	THREE.EquirectangularReflectionMapping = 303;
	THREE.EquirectangularRefractionMapping = 304;

	THREE.SphericalReflectionMapping = 305;

	// Wrapping modes

	THREE.RepeatWrapping = 1000;
	THREE.ClampToEdgeWrapping = 1001;
	THREE.MirroredRepeatWrapping = 1002;

	// Filters

	THREE.NearestFilter = 1003;
	THREE.NearestMipMapNearestFilter = 1004;
	THREE.NearestMipMapLinearFilter = 1005;
	THREE.LinearFilter = 1006;
	THREE.LinearMipMapNearestFilter = 1007;
	THREE.LinearMipMapLinearFilter = 1008;

	// Data types

	THREE.UnsignedByteType = 1009;
	THREE.ByteType = 1010;
	THREE.ShortType = 1011;
	THREE.UnsignedShortType = 1012;
	THREE.IntType = 1013;
	THREE.UnsignedIntType = 1014;
	THREE.FloatType = 1015;
	THREE.HalfFloatType = 1025;

	// Pixel types

	//THREE.UnsignedByteType = 1009;
	THREE.UnsignedShort4444Type = 1016;
	THREE.UnsignedShort5551Type = 1017;
	THREE.UnsignedShort565Type = 1018;

	// Pixel formats

	THREE.AlphaFormat = 1019;
	THREE.RGBFormat = 1020;
	THREE.RGBAFormat = 1021;
	THREE.LuminanceFormat = 1022;
	THREE.LuminanceAlphaFormat = 1023;
	// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
	THREE.RGBEFormat = THREE.RGBAFormat; //1024;

	// DDS / ST3C Compressed texture formats

	THREE.RGB_S3TC_DXT1_Format = 2001;
	THREE.RGBA_S3TC_DXT1_Format = 2002;
	THREE.RGBA_S3TC_DXT3_Format = 2003;
	THREE.RGBA_S3TC_DXT5_Format = 2004;


	// PVRTC compressed texture formats

	THREE.RGB_PVRTC_4BPPV1_Format = 2100;
	THREE.RGB_PVRTC_2BPPV1_Format = 2101;
	THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
	THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


	// DEPRECATED

	THREE.Projector = function () {

		THREE.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

		this.projectVector = function ( vector, camera ) {

			THREE.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );

		};

		this.unprojectVector = function ( vector, camera ) {

			THREE.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );

		};

		this.pickingRay = function ( vector, camera ) {

			THREE.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

		};

	};

	THREE.CanvasRenderer = function () {

		THREE.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

		this.domElement = document.createElement( 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};

	};

	// File:src/math/Color.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Color = function ( color ) {

		if ( arguments.length === 3 ) {

			return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

		}

		return this.set( color )

	};

	THREE.Color.prototype = {

		constructor: THREE.Color,

		r: 1, g: 1, b: 1,

		set: function ( value ) {

			if ( value instanceof THREE.Color ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		},

		setHex: function ( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		},

		setRGB: function ( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		},

		setHSL: function ( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				var hue2rgb = function ( p, q, t ) {

					if ( t < 0 ) t += 1;
					if ( t > 1 ) t -= 1;
					if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
					if ( t < 1 / 2 ) return q;
					if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
					return p;

				};

				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		},

		setStyle: function ( style ) {

			// rgb(255,0,0)

			if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

				var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

				this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
				this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
				this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

				return this;

			}

			// rgb(100%,0%,0%)

			if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

				var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

				this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
				this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
				this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

				return this;

			}

			// #ff0000

			if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

				var color = /^\#([0-9a-f]{6})$/i.exec( style );

				this.setHex( parseInt( color[ 1 ], 16 ) );

				return this;

			}

			// #f00

			if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

				var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

				this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

				return this;

			}

			// red

			if ( /^(\w+)$/i.test( style ) ) {

				this.setHex( THREE.ColorKeywords[ style ] );

				return this;

			}


		},

		copy: function ( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		},

		copyGammaToLinear: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );

			return this;

		},

		copyLinearToGamma: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );

			return this;

		},

		convertGammaToLinear: function () {

			var r = this.r, g = this.g, b = this.b;

			this.r = r * r;
			this.g = g * g;
			this.b = b * b;

			return this;

		},

		convertLinearToGamma: function () {

			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );

			return this;

		},

		getHex: function () {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		},

		getHexString: function () {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		},

		getHSL: function ( optionalTarget ) {

			// h,s,l ranges are in 0.0 - 1.0

			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;

			return hsl;

		},

		getStyle: function () {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		},

		offsetHSL: function ( h, s, l ) {

			var hsl = this.getHSL();

			hsl.h += h; hsl.s += s; hsl.l += l;

			this.setHSL( hsl.h, hsl.s, hsl.l );

			return this;

		},

		add: function ( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		},

		addColors: function ( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		},

		addScalar: function ( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		},

		multiply: function ( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		},

		lerp: function ( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		},

		equals: function ( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		},

		fromArray: function ( array ) {

			this.r = array[ 0 ];
			this.g = array[ 1 ];
			this.b = array[ 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;
		},

		clone: function () {

			return new THREE.Color().setRGB( this.r, this.g, this.b );

		}

	};

	THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	// File:src/math/Quaternion.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Quaternion = function ( x, y, z, w ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;

	};

	THREE.Quaternion.prototype = {

		constructor: THREE.Quaternion,

		_x: 0,_y: 0, _z: 0, _w: 0,

		get x () {

			return this._x;

		},

		set x ( value ) {

			this._x = value;
			this.onChangeCallback();

		},

		get y () {

			return this._y;

		},

		set y ( value ) {

			this._y = value;
			this.onChangeCallback();

		},

		get z () {

			return this._z;

		},

		set z ( value ) {

			this._z = value;
			this.onChangeCallback();

		},

		get w () {

			return this._w;

		},

		set w ( value ) {

			this._w = value;
			this.onChangeCallback();

		},

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this.onChangeCallback();

			return this;

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this.onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( euler instanceof THREE.Euler === false ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
			}

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var c1 = Math.cos( euler._x / 2 );
			var c2 = Math.cos( euler._y / 2 );
			var c3 = Math.cos( euler._z / 2 );
			var s1 = Math.sin( euler._x / 2 );
			var s2 = Math.sin( euler._y / 2 );
			var s3 = Math.sin( euler._z / 2 );

			if ( euler.order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( euler.order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( euler.order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( euler.order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( euler.order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( euler.order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this.onChangeCallback();

			return this;

		},

		setFromUnitVectors: function () {

			// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

			// assumes direction vectors vFrom and vTo are normalized

			var v1, r;

			var EPS = 0.000001;

			return function ( vFrom, vTo ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				r = vFrom.dot( vTo ) + 1;

				if ( r < EPS ) {

					r = 0;

					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

						v1.set( - vFrom.y, vFrom.x, 0 );

					} else {

						v1.set( 0, - vFrom.z, vFrom.y );

					}

				} else {

					v1.crossVectors( vFrom, vTo );

				}

				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;

				this.normalize();

				return this;

			}

		}(),

		inverse: function () {

			this.conjugate().normalize();

			return this;

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this.onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this.onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				THREE.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this.onChangeCallback();

			return this;

		},

		multiplyVector3: function ( vector ) {

			THREE.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var halfTheta = Math.acos( cosHalfTheta );
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

			if ( Math.abs( sinHalfTheta ) < 0.001 ) {

				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );

				return this;

			}

			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this.onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {},

		clone: function () {

			return new THREE.Quaternion( this._x, this._y, this._z, this._w );

		}

	};

	THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	}

	// File:src/math/Vector2.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.Vector2 = function ( x, y ) {

		this.x = x || 0;
		this.y = y || 0;

	};

	THREE.Vector2.prototype = {

		constructor: THREE.Vector2,

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.x *= s;
			this.y *= s;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;

			}

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			return this;
		},

		clampScalar: ( function () {

			var min, max;

			return function ( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector2();
					max = new THREE.Vector2();

				}

				min.set( minVal, minVal );
				max.set( maxVal, maxVal );

				return this.clamp( min, max );

			};

		} )(),

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength ) {

				this.multiplyScalar( l / oldLength );
			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];

			return this;

		},

		clone: function () {

			return new THREE.Vector2( this.x, this.y );

		}

	};

	// File:src/math/Vector3.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Vector3 = function ( x, y, z ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	};

	THREE.Vector3.prototype = {

		constructor: THREE.Vector3,

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},
		
		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function () {

			var quaternion;

			return function ( euler ) {

				if ( euler instanceof THREE.Euler === false ) {

					THREE.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

				}

				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

				this.applyQuaternion( quaternion.setFromEuler( euler ) );

				return this;

			};

		}(),

		applyAxisAngle: function () {

			var quaternion;

			return function ( axis, angle ) {

				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

				this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

				return this;

			};

		}(),

		applyMatrix3: function ( m ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyMatrix4: function ( m ) {

			// input: THREE.Matrix4 affine matrix

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

			return this;

		},

		applyProjection: function ( m ) {

			// input: THREE.Matrix4 projection matrix

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;
			var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;

			var qx = q.x;
			var qy = q.y;
			var qz = q.z;
			var qw = q.w;

			// calculate quat * vector

			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function () {

			var matrix;

			return function ( camera ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyProjection( matrix );

			};

		}(),

		unproject: function () {

			var matrix;

			return function ( camera ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyProjection( matrix );

			};

		}(),

		transformDirection: function ( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			this.normalize();

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;
				this.z = 0;

			}

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			if ( this.z > v.z ) {

				this.z = v.z;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			if ( this.z < v.z ) {

				this.z = v.z;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			if ( this.z < min.z ) {

				this.z = min.z;

			} else if ( this.z > max.z ) {

				this.z = max.z;

			}

			return this;

		},

		clampScalar: ( function () {

			var min, max;

			return function ( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector3();
					max = new THREE.Vector3();

				}

				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		} )(),

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		lengthManhattan: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength  ) {

				this.multiplyScalar( l / oldLength );
			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			var x = this.x, y = this.y, z = this.z;

			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;

			return this;

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function () {

			var v1, dot;

			return function ( vector ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				v1.copy( vector ).normalize();

				dot = this.dot( v1 );

				return this.copy( v1 ).multiplyScalar( dot );

			};

		}(),

		projectOnPlane: function () {

			var v1;

			return function ( planeNormal ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				v1.copy( this ).projectOnVector( planeNormal );

				return this.sub( v1 );

			}

		}(),

		reflect: function () {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			var v1;

			return function ( normal ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

			}

		}(),

		angleTo: function ( v ) {

			var theta = this.dot( v ) / ( this.length() * v.length() );

			// clamp, to handle numerical problems

			return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x;
			var dy = this.y - v.y;
			var dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		setEulerFromRotationMatrix: function ( m, order ) {

			THREE.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

		},

		setEulerFromQuaternion: function ( q, order ) {

			THREE.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

		},

		getPositionFromMatrix: function ( m ) {

			THREE.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

			return this.setFromMatrixPosition( m );

		},

		getScaleFromMatrix: function ( m ) {

			THREE.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

			return this.setFromMatrixScale( m );
		},

		getColumnFromMatrix: function ( index, matrix ) {

			THREE.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

			return this.setFromMatrixColumn( index, matrix );

		},

		setFromMatrixPosition: function ( m ) {

			this.x = m.elements[ 12 ];
			this.y = m.elements[ 13 ];
			this.z = m.elements[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
			var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
			var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;
		},

		setFromMatrixColumn: function ( index, matrix ) {
			
			var offset = index * 4;

			var me = matrix.elements;

			this.x = me[ offset ];
			this.y = me[ offset + 1 ];
			this.z = me[ offset + 2 ];

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];

			return this;

		},

		clone: function () {

			return new THREE.Vector3( this.x, this.y, this.z );

		}

	};

	// File:src/math/Vector4.js

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Vector4 = function ( x, y, z, w ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;

	};

	THREE.Vector4.prototype = {

		constructor: THREE.Vector4,

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;
			var w = this.w;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;
				this.w *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 1;

			}

			return this;

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				 this.x = 1;
				 this.y = 0;
				 this.z = 0;

			} else {

				 this.x = q.x / s;
				 this.y = q.y / s;
				 this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon )
			   && ( Math.abs( m13 - m31 ) < epsilon )
			   && ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 )
				   && ( Math.abs( m13 + m31 ) < epsilon2 )
				   && ( Math.abs( m23 + m32 ) < epsilon2 )
				   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) { // m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else { // m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
							  + ( m13 - m31 ) * ( m13 - m31 )
							  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			if ( this.z > v.z ) {

				this.z = v.z;

			}

			if ( this.w > v.w ) {

				this.w = v.w;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			if ( this.z < v.z ) {

				this.z = v.z;

			}

			if ( this.w < v.w ) {

				this.w = v.w;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			if ( this.z < min.z ) {

				this.z = min.z;

			} else if ( this.z > max.z ) {

				this.z = max.z;

			}

			if ( this.w < min.w ) {

				this.w = min.w;

			} else if ( this.w > max.w ) {

				this.w = max.w;

			}

			return this;

		},

		clampScalar: ( function () {

			var min, max;

			return function ( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector4();
					max = new THREE.Vector4();

				}

				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		} )(),

	  floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

	  },

	  ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

	  },

	  round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

	  },

	  roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

	  },

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		lengthManhattan: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength ) {

				this.multiplyScalar( l / oldLength );

			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
			this.w = attribute.array[ index + 3 ];

			return this;

		},

		clone: function () {

			return new THREE.Vector4( this.x, this.y, this.z, this.w );

		}

	};

	// File:src/math/Euler.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Euler = function ( x, y, z, order ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || THREE.Euler.DefaultOrder;

	};

	THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	THREE.Euler.DefaultOrder = 'XYZ';

	THREE.Euler.prototype = {

		constructor: THREE.Euler,

		_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

		get x () {

			return this._x;

		},

		set x ( value ) {

			this._x = value;
			this.onChangeCallback();

		},

		get y () {

			return this._y;

		},

		set y ( value ) {

			this._y = value;
			this.onChangeCallback();

		},

		get z () {

			return this._z;

		},

		set z ( value ) {

			this._z = value;
			this.onChangeCallback();

		},

		get order () {

			return this._order;

		},

		set order ( value ) {

			this._order = value;
			this.onChangeCallback();

		},

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this.onChangeCallback();

			return this;

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = THREE.Math.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.99999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.99999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				THREE.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

			}

			this._order = order;

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromQuaternion: function () {

			var matrix;

			return function ( q, order, update ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();
				matrix.makeRotationFromQuaternion( q );
				this.setFromRotationMatrix( matrix, order, update );

				return this;

			};

		}(),

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function () {

			// WARNING: this discards revolution information -bhouston

			var q = new THREE.Quaternion();

			return function ( newOrder ) {

				q.setFromEuler( this );
				this.setFromQuaternion( q, newOrder );

			};

		}(),

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;
		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new THREE.Vector3( this._x, this._y, this._z );

			}

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {},

		clone: function () {

			return new THREE.Euler( this._x, this._y, this._z, this._order );

		}

	};

	// File:src/math/Line3.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Line3 = function ( start, end ) {

		this.start = ( start !== undefined ) ? start : new THREE.Vector3();
		this.end = ( end !== undefined ) ? end : new THREE.Vector3();

	};

	THREE.Line3.prototype = {

		constructor: THREE.Line3,

		set: function ( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		},

		copy: function ( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		},

		delta: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.end, this.start );

		},

		distanceSq: function () {

			return this.start.distanceToSquared( this.end );

		},

		distance: function () {

			return this.start.distanceTo( this.end );

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		closestPointToPointParameter: function () {

			var startP = new THREE.Vector3();
			var startEnd = new THREE.Vector3();

			return function ( point, clampToLine ) {

				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );

				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );

				var t = startEnd_startP / startEnd2;

				if ( clampToLine ) {

					t = THREE.Math.clamp( t, 0, 1 );

				}

				return t;

			};

		}(),

		closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

			var t = this.closestPointToPointParameter( point, clampToLine );

			var result = optionalTarget || new THREE.Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		applyMatrix4: function ( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		},

		equals: function ( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		},

		clone: function () {

			return new THREE.Line3().copy( this );

		}

	};

	// File:src/math/Box2.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Box2 = function ( min, max ) {

		this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

	};

	THREE.Box2.prototype = {

		constructor: THREE.Box2,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] )

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new THREE.Vector2();

			return function ( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		},

		empty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		size: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;
		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;
		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;
		},

		containsPoint: function ( point ) {

			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ) {

				return false;

			}

			return true;

		},

		containsBox: function ( box ) {

			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

				return true;

			}

			return false;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new THREE.Vector2();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		},

		isIntersectionBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.

			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ) {

				return false;

			}

			return true;

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector2();

			return function ( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		},

		clone: function () {

			return new THREE.Box2().copy( this );

		}

	};

	// File:src/math/Box3.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Box3 = function ( min, max ) {

		this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

	};

	THREE.Box3.prototype = {

		constructor: THREE.Box3,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] )

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new THREE.Vector3();

			return function ( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		setFromObject: function () {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and childrens', world transforms

			var v1 = new THREE.Vector3();

			return function ( object ) {

				var scope = this;

				object.updateMatrixWorld( true );

				this.makeEmpty();

				object.traverse( function ( node ) {

					var geometry = node.geometry;

					if ( geometry !== undefined ) {

						if ( geometry instanceof THREE.Geometry ) {

							var vertices = geometry.vertices;

							for ( var i = 0, il = vertices.length; i < il; i ++ ) {

								v1.copy( vertices[ i ] );

								v1.applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

							var positions = geometry.attributes[ 'position' ].array;

							for ( var i = 0, il = positions.length; i < il; i += 3 ) {

								v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

								v1.applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				} );

				return this;

			};

		}(),

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = this.min.z = Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		},

		empty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		size: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ||
			     point.z < this.min.z || point.z > this.max.z ) {

				return false;

			}

			return true;

		},

		containsBox: function ( box ) {

			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
				 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

				return true;

			}

			return false;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new THREE.Vector3();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		},

		isIntersectionBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.

			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ||
			     box.max.z < this.min.z || box.min.z > this.max.z ) {

				return false;

			}

			return true;

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector3();

			return function ( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		getBoundingSphere: function () {

			var v1 = new THREE.Vector3();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Sphere();

				result.center = this.center();
				result.radius = this.size( v1 ).length() * 0.5;

				return result;

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		applyMatrix4: function () {

			var points = [
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3()
			];

			return function ( matrix ) {

				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

				this.makeEmpty();
				this.setFromPoints( points );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		},

		clone: function () {

			return new THREE.Box3().copy( this );

		}

	};

	// File:src/math/Matrix3.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Matrix3 = function () {

		this.elements = new Float32Array( [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		] );

		if ( arguments.length > 0 ) {

			THREE.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	THREE.Matrix3.prototype = {

		constructor: THREE.Matrix3,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
			te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
			te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		copy: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 3 ], me[ 6 ],
				me[ 1 ], me[ 4 ], me[ 7 ],
				me[ 2 ], me[ 5 ], me[ 8 ]

			);

			return this;

		},

		multiplyVector3: function ( vector ) {

			THREE.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );

		},

		multiplyVector3Array: function ( a ) {

			THREE.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );

		},

		applyToVector3Array: function () {

			var v1 = new THREE.Vector3();

			return function ( array, offset, length ) {

				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;

				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

					v1.x = array[ j ];
					v1.y = array[ j + 1 ];
					v1.z = array[ j + 2 ];

					v1.applyMatrix3( this );

					array[ j ]     = v1.x;
					array[ j + 1 ] = v1.y;
					array[ j + 2 ] = v1.z;

				}

				return array;

			};

		}(),

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnInvertible ) {

			// input: THREE.Matrix4
			// ( based on http://code.google.com/p/webgl-mjs/ )

			var me = matrix.elements;
			var te = this.elements;

			te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
			te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
			te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
			te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
			te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
			te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
			te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
			te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
			te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

			var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

			// no inverse

			if ( det === 0 ) {

				var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

				if ( throwOnInvertible || false ) {

					throw new Error( msg );

				} else {

					THREE.warn( msg );

				}

				this.identity();

				return this;

			}

			this.multiplyScalar( 1.0 / det );

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		flattenToArrayOffset: function ( array, offset ) {

			var te = this.elements;

			array[ offset     ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ]  = te[ 8 ];

			return array;

		},

		getNormalMatrix: function ( m ) {

			// input: THREE.Matrix4

			this.getInverse( m ).transpose();

			return this;

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		fromArray: function ( array ) {

			this.elements.set( array );

			return this;

		},

		toArray: function () {

			var te = this.elements;

			return [
				te[ 0 ], te[ 1 ], te[ 2 ],
				te[ 3 ], te[ 4 ], te[ 5 ],
				te[ 6 ], te[ 7 ], te[ 8 ]
			];

		},

		clone: function () {

			return new THREE.Matrix3().fromArray( this.elements );

		}

	};

	// File:src/math/Matrix4.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://exocortex.com
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Matrix4 = function () {

		this.elements = new Float32Array( [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		] );

		if ( arguments.length > 0 ) {

			THREE.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	THREE.Matrix4.prototype = {

		constructor: THREE.Matrix4,

		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		copy: function ( m ) {

			this.elements.set( m.elements );

			return this;

		},

		extractPosition: function ( m ) {

			THREE.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );

		},

		copyPosition: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {
	 
			var te = this.elements;
	 
			xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
			yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
			zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );
	 
			return this;
	 		
		},
	 
		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0,       0,       0,       1
			);

			return this;

		},

		extractRotation: function () {

			var v1 = new THREE.Vector3();

			return function ( m ) {

				var te = this.elements;
				var me = m.elements;

				var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
				var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
				var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;

				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;

				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;

				return this;

			};

		}(),

		makeRotationFromEuler: function ( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				THREE.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		setRotationFromQuaternion: function ( q ) {

			THREE.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

			return this.makeRotationFromQuaternion( q );

		},

		makeRotationFromQuaternion: function ( q ) {

			var te = this.elements;

			var x = q.x, y = q.y, z = q.z, w = q.w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			te[ 0 ] = 1 - ( yy + zz );
			te[ 4 ] = xy - wz;
			te[ 8 ] = xz + wy;

			te[ 1 ] = xy + wz;
			te[ 5 ] = 1 - ( xx + zz );
			te[ 9 ] = yz - wx;

			te[ 2 ] = xz - wy;
			te[ 6 ] = yz + wx;
			te[ 10 ] = 1 - ( xx + yy );

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		lookAt: function () {

			var x = new THREE.Vector3();
			var y = new THREE.Vector3();
			var z = new THREE.Vector3();

			return function ( eye, target, up ) {

				var te = this.elements;

				z.subVectors( eye, target ).normalize();

				if ( z.length() === 0 ) {

					z.z = 1;

				}

				x.crossVectors( up, z ).normalize();

				if ( x.length() === 0 ) {

					z.x += 0.0001;
					x.crossVectors( up, z ).normalize();

				}

				y.crossVectors( z, x );


				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

				return this;

			};

		}(),

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				THREE.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyToArray: function ( a, b, r ) {

			var te = this.elements;

			this.multiplyMatrices( a, b );

			r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
			r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
			r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
			r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		multiplyVector3: function ( vector ) {

			THREE.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
			return vector.applyProjection( this );

		},

		multiplyVector4: function ( vector ) {

			THREE.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},

		multiplyVector3Array: function ( a ) {

			THREE.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );

		},

		applyToVector3Array: function () {

			var v1 = new THREE.Vector3();

			return function ( array, offset, length ) {

				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;

				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

					v1.x = array[ j ];
					v1.y = array[ j + 1 ];
					v1.z = array[ j + 2 ];

					v1.applyMatrix4( this );

					array[ j ]     = v1.x;
					array[ j + 1 ] = v1.y;
					array[ j + 2 ] = v1.z;

				}

				return array;

			};

		}(),

		rotateAxis: function ( v ) {

			THREE.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

			v.transformDirection( this );

		},

		crossVector: function ( vector ) {

			THREE.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		flattenToArrayOffset: function ( array, offset ) {

			var te = this.elements;

			array[ offset     ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ]  = te[ 8 ];
			array[ offset + 9 ]  = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		},

		getPosition: function () {

			var v1 = new THREE.Vector3();

			return function () {

				THREE.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

				var te = this.elements;
				return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

			};

		}(),

		setPosition: function ( v ) {

			var te = this.elements;

			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;

			return this;

		},

		getInverse: function ( m, throwOnInvertible ) {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements;
			var me = m.elements;

			var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
			var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
			var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
			var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

			te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
			te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
			te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
			te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
			te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
			te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
			te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
			te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
			te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
			te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
			te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
			te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
			te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
			te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
			te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

			var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

			if ( det == 0 ) {

				var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

				if ( throwOnInvertible || false ) {

					throw new Error( msg );

				} else {

					THREE.warn( msg );

				}

				this.identity();

				return this;
			}

			this.multiplyScalar( 1 / det );

			return this;

		},

		translate: function ( v ) {

			THREE.error( 'THREE.Matrix4: .translate() has been removed.' );

		},

		rotateX: function ( angle ) {

			THREE.error( 'THREE.Matrix4: .rotateX() has been removed.' );

		},

		rotateY: function ( angle ) {

			THREE.error( 'THREE.Matrix4: .rotateY() has been removed.' );

		},

		rotateZ: function ( angle ) {

			THREE.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

		},

		rotateByAxis: function ( axis, angle ) {

			THREE.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0,  0, 0,
				0, c, - s, 0,
				0, s,  c, 0,
				0, 0,  0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s,  c, 0, 0,
				0,  0, 1, 0,
				0,  0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );

			return this;

		},

		decompose: function () {

			var vector = new THREE.Vector3();
			var matrix = new THREE.Matrix4();

			return function ( position, quaternion, scale ) {

				var te = this.elements;

				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) {
					sx = - sx;
				}

				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];

				// scale the rotation part

				matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;

				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;

				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;

				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;

				quaternion.setFromRotationMatrix( matrix );

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;

			};

		}(),

		makeFrustum: function ( left, right, bottom, top, near, far ) {

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makePerspective: function ( fov, aspect, near, far ) {

			var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
			var ymin = - ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;

			return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = right - left;
			var h = top - bottom;
			var p = far - near;

			var x = ( right + left ) / w;
			var y = ( top + bottom ) / h;
			var z = ( far + near ) / p;

			te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		fromArray: function ( array ) {

			this.elements.set( array );

			return this;

		},

		toArray: function () {

			var te = this.elements;

			return [
				te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
				te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
				te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
				te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
			];

		},

		clone: function () {

			return new THREE.Matrix4().fromArray( this.elements );

		}

	};

	// File:src/math/Ray.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Ray = function ( origin, direction ) {

		this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
		this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

	};

	THREE.Ray.prototype = {

		constructor: THREE.Ray,

		set: function ( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		},

		copy: function ( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		},

		recast: function () {

			var v1 = new THREE.Vector3();

			return function ( t ) {

				this.origin.copy( this.at( t, v1 ) );

				return this;

			};

		}(),

		closestPointToPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );

			if ( directionDistance < 0 ) {

				return result.copy( this.origin );

			}

			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector3();

			return function ( point ) {

				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

				// point behind the ray

				if ( directionDistance < 0 ) {

					return this.origin.distanceTo( point );

				}

				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

				return v1.distanceTo( point );

			};

		}(),

		distanceSqToSegment: function () {

			var segCenter = new THREE.Vector3();
			var segDir = new THREE.Vector3();
			var diff = new THREE.Vector3();

			return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

				// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment

				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );

				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;

				if ( det > 0 ) {

					// The ray and segment are not parallel.

					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;

					if ( s0 >= 0 ) {

						if ( s1 >= - extDet ) {

							if ( s1 <= extDet ) {

								// region 0
								// Minimum at interior points of ray and segment.

								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

							} else {

								// region 1

								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							// region 5

							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						if ( s1 <= - extDet ) {

							// region 4

							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						} else if ( s1 <= extDet ) {

							// region 3

							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;

						} else {

							// region 2

							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					}

				} else {

					// Ray and segment are parallel.

					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

				if ( optionalPointOnRay ) {

					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

				}

				if ( optionalPointOnSegment ) {

					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

				}

				return sqrDist;

			};

		}(),


		isIntersectionSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) <= sphere.radius;

		},

		intersectSphere: function () {

			// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

			var v1 = new THREE.Vector3();

			return function ( sphere, optionalTarget ) {

				v1.subVectors( sphere.center, this.origin );

				var tca = v1.dot( this.direction );

				var d2 = v1.dot( v1 ) - tca * tca;

				var radius2 = sphere.radius * sphere.radius;

				if ( d2 > radius2 ) return null;

				var thc = Math.sqrt( radius2 - d2 );

				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, optionalTarget );

				// else t0 is in front of the ray, so return the first collision point scaled by t0 
				return this.at( t0, optionalTarget );

			}

		}(),

		isIntersectionPlane: function ( plane ) {

			// check if the ray lies on the plane first

			var distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			var denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		},

		distanceToPlane: function ( plane ) {

			var denominator = plane.normal.dot( this.direction );
			if ( denominator == 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) == 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t :  null;

		},

		intersectPlane: function ( plane, optionalTarget ) {

			var t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;
			}

			return this.at( t, optionalTarget );

		},

		isIntersectionBox: function () {

			var v = new THREE.Vector3();

			return function ( box ) {

				return this.intersectBox( box, v ) !== null;

			};

		}(),

		intersectBox: function ( box, optionalTarget ) {

			// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

			var tmin,tmax,tymin,tymax,tzmin,tzmax;

			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			var origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;
			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;
			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;
			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

		},

		intersectTriangle: function () {

			// Compute the offset origin, edges, and normal.
			var diff = new THREE.Vector3();
			var edge1 = new THREE.Vector3();
			var edge2 = new THREE.Vector3();
			var normal = new THREE.Vector3();

			return function ( a, b, c, backfaceCulling, optionalTarget ) {

				// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;

				if ( DdN > 0 ) {

					if ( backfaceCulling ) return null;
					sign = 1;

				} else if ( DdN < 0 ) {

					sign = - 1;
					DdN = - DdN;

				} else {

					return null;

				}

				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {

					return null;

				}

				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {

					return null;

				}

				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {

					return null;

				}

				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );

				// t < 0, no intersection
				if ( QdN < 0 ) {

					return null;

				}

				// Ray intersects triangle.
				return this.at( QdN / DdN, optionalTarget );

			};

		}(),

		applyMatrix4: function ( matrix4 ) {

			this.direction.add( this.origin ).applyMatrix4( matrix4 );
			this.origin.applyMatrix4( matrix4 );
			this.direction.sub( this.origin );
			this.direction.normalize();

			return this;
		},

		equals: function ( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		},

		clone: function () {

			return new THREE.Ray().copy( this );

		}

	};

	// File:src/math/Sphere.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Sphere = function ( center, radius ) {

		this.center = ( center !== undefined ) ? center : new THREE.Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;

	};

	THREE.Sphere.prototype = {

		constructor: THREE.Sphere,

		set: function ( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;
		},

		setFromPoints: function () {

			var box = new THREE.Box3();

			return function ( points, optionalCenter ) {

				var center = this.center;

				if ( optionalCenter !== undefined ) {

					center.copy( optionalCenter );

				} else {

					box.setFromPoints( points ).center( center );

				}

				var maxRadiusSq = 0;

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

				}

				this.radius = Math.sqrt( maxRadiusSq );

				return this;

			};

		}(),

		copy: function ( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		},

		empty: function () {

			return ( this.radius <= 0 );

		},

		containsPoint: function ( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		},

		distanceToPoint: function ( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		},

		intersectsSphere: function ( sphere ) {

			var radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		},

		clampPoint: function ( point, optionalTarget ) {

			var deltaLengthSq = this.center.distanceToSquared( point );

			var result = optionalTarget || new THREE.Vector3();
			result.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );

			}

			return result;

		},

		getBoundingBox: function ( optionalTarget ) {

			var box = optionalTarget || new THREE.Box3();

			box.set( this.center, this.center );
			box.expandByScalar( this.radius );

			return box;

		},

		applyMatrix4: function ( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		},

		translate: function ( offset ) {

			this.center.add( offset );

			return this;

		},

		equals: function ( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		},

		clone: function () {

			return new THREE.Sphere().copy( this );

		}

	};

	// File:src/math/Frustum.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

		this.planes = [

			( p0 !== undefined ) ? p0 : new THREE.Plane(),
			( p1 !== undefined ) ? p1 : new THREE.Plane(),
			( p2 !== undefined ) ? p2 : new THREE.Plane(),
			( p3 !== undefined ) ? p3 : new THREE.Plane(),
			( p4 !== undefined ) ? p4 : new THREE.Plane(),
			( p5 !== undefined ) ? p5 : new THREE.Plane()

		];

	};

	THREE.Frustum.prototype = {

		constructor: THREE.Frustum,

		set: function ( p0, p1, p2, p3, p4, p5 ) {

			var planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		},

		copy: function ( frustum ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		},

		setFromMatrix: function ( m ) {

			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		},

		intersectsObject: function () {

			var sphere = new THREE.Sphere();

			return function ( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( object.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;

			for ( var i = 0; i < 6; i ++ ) {

				var distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		},

		intersectsBox: function () {

			var p1 = new THREE.Vector3(),
				p2 = new THREE.Vector3();

			return function ( box ) {

				var planes = this.planes;

				for ( var i = 0; i < 6 ; i ++ ) {

					var plane = planes[ i ];

					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );

					// if both outside plane, no intersection

					if ( d1 < 0 && d2 < 0 ) {

						return false;

					}
				}

				return true;
			};

		}(),


		containsPoint: function ( point ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		},

		clone: function () {

			return new THREE.Frustum().copy( this );

		}

	};

	// File:src/math/Plane.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Plane = function ( normal, constant ) {

		this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;

	};

	THREE.Plane.prototype = {

		constructor: THREE.Plane,

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

			return this;

		},

		setFromCoplanarPoints: function () {

			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();

			return function ( a, b, c ) {

				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint( normal, a );

				return this;

			};

		}(),


		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, optionalTarget ) {

			return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

		},

		orthoPoint: function ( point, optionalTarget ) {

			var perpendicularMagnitude = this.distanceToPoint( point );

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

		},

		isIntersectionLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectLine: function () {

			var v1 = new THREE.Vector3();

			return function ( line, optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				var direction = line.delta( v1 );

				var denominator = this.normal.dot( direction );

				if ( denominator == 0 ) {

					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) == 0 ) {

						return result.copy( line.start );

					}

					// Unsure if this is the correct method to handle this case.
					return undefined;

				}

				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

				if ( t < 0 || t > 1 ) {

					return undefined;

				}

				return result.copy( direction ).multiplyScalar( t ).add( line.start );

			};

		}(),


		coplanarPoint: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function () {

			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
			var m1 = new THREE.Matrix3();

			return function ( matrix, optionalNormalMatrix ) {

				// compute new normal based on theory here:
				// http://www.songho.ca/opengl/gl_normaltransform.html
				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
				var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

				var newCoplanarPoint = this.coplanarPoint( v2 );
				newCoplanarPoint.applyMatrix4( matrix );

				this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.constant = this.constant - offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );

		},

		clone: function () {

			return new THREE.Plane().copy( this );

		}

	};

	// File:src/math/Math.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Math = {

		generateUUID: function () {

			// http://www.broofa.com/Tools/Math.uuid.htm

			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
			var uuid = new Array( 36 );
			var rnd = 0, r;

			return function () {

				for ( var i = 0; i < 36; i ++ ) {

					if ( i == 8 || i == 13 || i == 18 || i == 23 ) {

						uuid[ i ] = '-';

					} else if ( i == 14 ) {

						uuid[ i ] = '4';

					} else {

						if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];

					}
				}

				return uuid.join( '' );

			};

		}(),

		// Clamp value to range <a, b>

		clamp: function ( x, a, b ) {

			return ( x < a ) ? a : ( ( x > b ) ? b : x );

		},

		// Clamp value to range <a, inf)

		clampBottom: function ( x, a ) {

			return x < a ? a : x;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random float from <0, 1> with 16 bits of randomness
		// (standard Math.random() creates repetitive patterns when applied over larger space)

		random16: function () {

			return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return Math.floor( this.randFloat( low, high ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function () {

			var degreeToRadiansFactor = Math.PI / 180;

			return function ( degrees ) {

				return degrees * degreeToRadiansFactor;

			};

		}(),

		radToDeg: function () {

			var radianToDegreesFactor = 180 / Math.PI;

			return function ( radians ) {

				return radians * radianToDegreesFactor;

			};

		}(),

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		nextPowerOfTwo: function ( value ) {

			value --;
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			value ++;

			return value;

		}

	};

	// File:src/math/Spline.js

	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Spline = function ( points ) {

		this.points = points;

		var c = [], v3 = { x: 0, y: 0, z: 0 },
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;

		this.initFromArray = function ( a ) {

			this.points = [];

			for ( var i = 0; i < a.length; i ++ ) {

				this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

			}

		};

		this.getPoint = function ( k ) {

			point = ( this.points.length - 1 ) * k;
			intPoint = Math.floor( point );
			weight = point - intPoint;

			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

			pa = this.points[ c[ 0 ] ];
			pb = this.points[ c[ 1 ] ];
			pc = this.points[ c[ 2 ] ];
			pd = this.points[ c[ 3 ] ];

			w2 = weight * weight;
			w3 = weight * w2;

			v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
			v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
			v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

			return v3;

		};

		this.getControlPointsArray = function () {

			var i, p, l = this.points.length,
				coords = [];

			for ( i = 0; i < l; i ++ ) {

				p = this.points[ i ];
				coords[ i ] = [ p.x, p.y, p.z ];

			}

			return coords;

		};

		// approximate length by summing linear segments

		this.getLength = function ( nSubDivisions ) {

			var i, index, nSamples, position,
				point = 0, intPoint = 0, oldIntPoint = 0,
				oldPosition = new THREE.Vector3(),
				tmpVec = new THREE.Vector3(),
				chunkLengths = [],
				totalLength = 0;

			// first point has 0 length

			chunkLengths[ 0 ] = 0;

			if ( ! nSubDivisions ) nSubDivisions = 100;

			nSamples = this.points.length * nSubDivisions;

			oldPosition.copy( this.points[ 0 ] );

			for ( i = 1; i < nSamples; i ++ ) {

				index = i / nSamples;

				position = this.getPoint( index );
				tmpVec.copy( position );

				totalLength += tmpVec.distanceTo( oldPosition );

				oldPosition.copy( position );

				point = ( this.points.length - 1 ) * index;
				intPoint = Math.floor( point );

				if ( intPoint != oldIntPoint ) {

					chunkLengths[ intPoint ] = totalLength;
					oldIntPoint = intPoint;

				}

			}

			// last point ends with total length

			chunkLengths[ chunkLengths.length ] = totalLength;

			return { chunks: chunkLengths, total: totalLength };

		};

		this.reparametrizeByArcLength = function ( samplingCoef ) {

			var i, j,
				index, indexCurrent, indexNext,
				realDistance,
				sampling, position,
				newpoints = [],
				tmpVec = new THREE.Vector3(),
				sl = this.getLength();

			newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

			for ( i = 1; i < this.points.length; i ++ ) {

				//tmpVec.copy( this.points[ i - 1 ] );
				//linearDistance = tmpVec.distanceTo( this.points[ i ] );

				realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

				sampling = Math.ceil( samplingCoef * realDistance / sl.total );

				indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
				indexNext = i / ( this.points.length - 1 );

				for ( j = 1; j < sampling - 1; j ++ ) {

					index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

					position = this.getPoint( index );
					newpoints.push( tmpVec.copy( position ).clone() );

				}

				newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

			}

			this.points = newpoints;

		};

		// Catmull-Rom

		function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

			var v0 = ( p2 - p0 ) * 0.5,
				v1 = ( p3 - p1 ) * 0.5;

			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		};

	};

	// File:src/math/Triangle.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Triangle = function ( a, b, c ) {

		this.a = ( a !== undefined ) ? a : new THREE.Vector3();
		this.b = ( b !== undefined ) ? b : new THREE.Vector3();
		this.c = ( c !== undefined ) ? c : new THREE.Vector3();

	};

	THREE.Triangle.normal = function () {

		var v0 = new THREE.Vector3();

		return function ( a, b, c, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );

			var resultLengthSq = result.lengthSq();
			if ( resultLengthSq > 0 ) {

				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

			}

			return result.set( 0, 0, 0 );

		};

	}();

	// static/instance method to calculate barycoordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	THREE.Triangle.barycoordFromPoint = function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( point, a, b, c, optionalTarget ) {

			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );

			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );

			var denom = ( dot00 * dot11 - dot01 * dot01 );

			var result = optionalTarget || new THREE.Vector3();

			// colinear or singular triangle
			if ( denom == 0 ) {
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set( - 2, - 1, - 1 );
			}

			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycoordinates must always sum to 1
			return result.set( 1 - u - v, v, u );

		};

	}();

	THREE.Triangle.containsPoint = function () {

		var v1 = new THREE.Vector3();

		return function ( point, a, b, c ) {

			var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

		};

	}();

	THREE.Triangle.prototype = {

		constructor: THREE.Triangle,

		set: function ( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		},

		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		},

		copy: function ( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		},

		area: function () {

			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();

			return function () {

				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );

				return v0.cross( v1 ).length() * 0.5;

			};

		}(),

		midpoint: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		},

		normal: function ( optionalTarget ) {

			return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

		},

		plane: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Plane();

			return result.setFromCoplanarPoints( this.a, this.b, this.c );

		},

		barycoordFromPoint: function ( point, optionalTarget ) {

			return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

		},

		containsPoint: function ( point ) {

			return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

		},

		equals: function ( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		},

		clone: function () {

			return new THREE.Triangle().copy( this );

		}

	};

	// File:src/core/Clock.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Clock = function ( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	};

	THREE.Clock.prototype = {

		constructor: THREE.Clock,

		start: function () {

			this.startTime = self.performance !== undefined && self.performance.now !== undefined
						 ? self.performance.now()
						 : Date.now();

			this.oldTime = this.startTime;
			this.running = true;
		},

		stop: function () {

			this.getElapsedTime();
			this.running = false;

		},

		getElapsedTime: function () {

			this.getDelta();
			return this.elapsedTime;

		},

		getDelta: function () {

			var diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();

			}

			if ( this.running ) {

				var newTime = self.performance !== undefined && self.performance.now !== undefined
						 ? self.performance.now()
						 : Date.now();

				diff = 0.001 * ( newTime - this.oldTime );
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	};

	// File:src/core/EventDispatcher.js

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	THREE.EventDispatcher = function () {}

	THREE.EventDispatcher.prototype = {

		constructor: THREE.EventDispatcher,

		apply: function ( object ) {

			object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
			object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
			object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
			object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

		},

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			var listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			var listeners = this._listeners;

			if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

				return true;

			}

			return false;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				var index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var array = [];
				var length = listenerArray.length;

				for ( var i = 0; i < length; i ++ ) {

					array[ i ] = listenerArray[ i ];

				}

				for ( var i = 0; i < length; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	};

	// File:src/core/Raycaster.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://exocortex.com/
	 * @author stephomi / http://stephaneginier.com/
	 */

	( function ( THREE ) {

		THREE.Raycaster = function ( origin, direction, near, far ) {

			this.ray = new THREE.Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near || 0;
			this.far = far || Infinity;

			this.params = {
				Sprite: {},
				Mesh: {},
				PointCloud: { threshold: 1 },
				LOD: {},
				Line: {}
			};

		};

		var descSort = function ( a, b ) {

			return a.distance - b.distance;

		};

		var intersectObject = function ( object, raycaster, intersects, recursive ) {

			object.raycast( raycaster, intersects );

			if ( recursive === true ) {

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					intersectObject( children[ i ], raycaster, intersects, true );

				}

			}

		};

		//

		THREE.Raycaster.prototype = {

			constructor: THREE.Raycaster,

			precision: 0.0001,
			linePrecision: 1,

			set: function ( origin, direction ) {

				// direction is assumed to be normalized (for accurate distance calculations)

				this.ray.set( origin, direction );

			},

			setFromCamera: function ( coords, camera ) {

				// camera is assumed _not_ to be a child of a transformed object

				if ( camera instanceof THREE.PerspectiveCamera ) {

					this.ray.origin.copy( camera.position );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( camera.position ).normalize();

				} else if ( camera instanceof THREE.OrthographicCamera ) {

					this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

				} else {

					THREE.error( 'THREE.Raycaster: Unsupported camera type.' );

				}

			},

			intersectObject: function ( object, recursive ) {

				var intersects = [];

				intersectObject( object, this, intersects, recursive );

				intersects.sort( descSort );

				return intersects;

			},

			intersectObjects: function ( objects, recursive ) {

				var intersects = [];

				if ( objects instanceof Array === false ) {

					THREE.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;

				}

				for ( var i = 0, l = objects.length; i < l; i ++ ) {

					intersectObject( objects[ i ], this, intersects, recursive );

				}

				intersects.sort( descSort );

				return intersects;

			}

		};

	}( THREE ) );

	// File:src/core/Object3D.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Object3D = function () {

		Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = undefined;
		this.children = [];

		this.up = THREE.Object3D.DefaultUp.clone();

		var position = new THREE.Vector3();
		var rotation = new THREE.Euler();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3( 1, 1, 1 );

		var onRotationChange = function () {
			quaternion.setFromEuler( rotation, false );
		};

		var onQuaternionChange = function () {
			rotation.setFromQuaternion( quaternion, undefined, false );
		};

		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			}
		} );

		this.rotationAutoUpdate = true;

		this.matrix = new THREE.Matrix4();
		this.matrixWorld = new THREE.Matrix4();

		this.matrixAutoUpdate = true;
		this.matrixWorldNeedsUpdate = false;

		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.userData = {};

	};

	THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );

	THREE.Object3D.prototype = {

		constructor: THREE.Object3D,

		get eulerOrder () {

			THREE.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

			return this.rotation.order;

		},

		set eulerOrder ( value ) {

			THREE.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

			this.rotation.order = value;

		},

		get useQuaternion () {

			THREE.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},

		set useQuaternion ( value ) {

			THREE.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},

		applyMatrix: function ( matrix ) {

			this.matrix.multiplyMatrices( matrix, this.matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function () {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			var q1 = new THREE.Quaternion();

			return function ( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.multiply( q1 );

				return this;

			}

		}(),

		rotateX: function () {

			var v1 = new THREE.Vector3( 1, 0, 0 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateY: function () {

			var v1 = new THREE.Vector3( 0, 1, 0 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateZ: function () {

			var v1 = new THREE.Vector3( 0, 0, 1 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		translateOnAxis: function () {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			var v1 = new THREE.Vector3();

			return function ( axis, distance ) {

				v1.copy( axis ).applyQuaternion( this.quaternion );

				this.position.add( v1.multiplyScalar( distance ) );

				return this;

			}

		}(),

		translate: function ( distance, axis ) {

			THREE.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );

		},

		translateX: function () {

			var v1 = new THREE.Vector3( 1, 0, 0 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateY: function () {

			var v1 = new THREE.Vector3( 0, 1, 0 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateZ: function () {

			var v1 = new THREE.Vector3( 0, 0, 1 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function () {

			var m1 = new THREE.Matrix4();

			return function ( vector ) {

				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

			};

		}(),

		lookAt: function () {

			// This routine does not support objects with rotated and/or translated parent(s)

			var m1 = new THREE.Matrix4();

			return function ( vector ) {

				m1.lookAt( vector, this.position, this.up );

				this.quaternion.setFromRotationMatrix( m1 );

			};

		}(),

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			};

			if ( object === this ) {

				THREE.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;

			}

			if ( object instanceof THREE.Object3D ) {

				if ( object.parent !== undefined ) {

					object.parent.remove( object );

				}

				object.parent = this;
				object.dispatchEvent( { type: 'added' } );

				this.children.push( object );

			} else {

				THREE.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

			};

			var index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = undefined;

				object.dispatchEvent( { type: 'removed' } );

				this.children.splice( index, 1 );

			}

		},

		getChildByName: function ( name ) {

			THREE.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld( true );

			return result.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function () {

			var position = new THREE.Vector3();
			var scale = new THREE.Vector3();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Quaternion();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, result, scale );

				return result;

			}

		}(),

		getWorldRotation: function () {

			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Euler();

				this.getWorldQuaternion( quaternion );

				return result.setFromQuaternion( quaternion, this.rotation.order, false );

			}

		}(),

		getWorldScale: function () {

			var position = new THREE.Vector3();
			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, quaternion, result );

				return result;

			}

		}(),

		getWorldDirection: function () {

			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				this.getWorldQuaternion( quaternion );

				return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

			}

		}(),

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			if ( this.parent ) {

				callback( this.parent );

				this.parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate === true ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate === true || force === true ) {

				if ( this.parent === undefined ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].updateMatrixWorld( force );

			}

		},

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.3,
					type: 'Object',
					generator: 'ObjectExporter'
				}
			};

			//

			var geometries = {};

			var parseGeometry = function ( geometry ) {

				if ( output.geometries === undefined ) {

					output.geometries = [];

				}

				if ( geometries[ geometry.uuid ] === undefined ) {

					var json = geometry.toJSON();

					delete json.metadata;

					geometries[ geometry.uuid ] = json;

					output.geometries.push( json );

				}

				return geometry.uuid;

			};

			//

			var materials = {};

			var parseMaterial = function ( material ) {

				if ( output.materials === undefined ) {

					output.materials = [];

				}

				if ( materials[ material.uuid ] === undefined ) {

					var json = material.toJSON();

					delete json.metadata;

					materials[ material.uuid ] = json;

					output.materials.push( json );

				}

				return material.uuid;

			};

			//

			var parseObject = function ( object ) {

				var data = {};

				data.uuid = object.uuid;
				data.type = object.type;

				if ( object.name !== '' ) data.name = object.name;
				if ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;
				if ( object.visible !== true ) data.visible = object.visible;

				if ( object instanceof THREE.PerspectiveCamera ) {

					data.fov = object.fov;
					data.aspect = object.aspect;
					data.near = object.near;
					data.far = object.far;

				} else if ( object instanceof THREE.OrthographicCamera ) {

					data.left = object.left;
					data.right = object.right;
					data.top = object.top;
					data.bottom = object.bottom;
					data.near = object.near;
					data.far = object.far;

				} else if ( object instanceof THREE.AmbientLight ) {

					data.color = object.color.getHex();

				} else if ( object instanceof THREE.DirectionalLight ) {

					data.color = object.color.getHex();
					data.intensity = object.intensity;

				} else if ( object instanceof THREE.PointLight ) {

					data.color = object.color.getHex();
					data.intensity = object.intensity;
					data.distance = object.distance;
					data.decay = object.decay;

				} else if ( object instanceof THREE.SpotLight ) {

					data.color = object.color.getHex();
					data.intensity = object.intensity;
					data.distance = object.distance;
					data.angle = object.angle;
					data.exponent = object.exponent;
					data.decay = object.decay;

				} else if ( object instanceof THREE.HemisphereLight ) {

					data.color = object.color.getHex();
					data.groundColor = object.groundColor.getHex();

				} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.PointCloud ) {

					data.geometry = parseGeometry( object.geometry );
					data.material = parseMaterial( object.material );

					if ( object instanceof THREE.Line ) data.mode = object.mode;

				} else if ( object instanceof THREE.Sprite ) {

					data.material = parseMaterial( object.material );

				}

				data.matrix = object.matrix.toArray();

				if ( object.children.length > 0 ) {

					data.children = [];

					for ( var i = 0; i < object.children.length; i ++ ) {

						data.children.push( parseObject( object.children[ i ] ) );

					}

				}

				return data;

			}

			output.object = parseObject( this );

			return output;

		},

		clone: function ( object, recursive ) {

			if ( object === undefined ) object = new THREE.Object3D();
			if ( recursive === undefined ) recursive = true;

			object.name = this.name;

			object.up.copy( this.up );

			object.position.copy( this.position );
			object.quaternion.copy( this.quaternion );
			object.scale.copy( this.scale );

			object.rotationAutoUpdate = this.rotationAutoUpdate;

			object.matrix.copy( this.matrix );
			object.matrixWorld.copy( this.matrixWorld );

			object.matrixAutoUpdate = this.matrixAutoUpdate;
			object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

			object.visible = this.visible;

			object.castShadow = this.castShadow;
			object.receiveShadow = this.receiveShadow;

			object.frustumCulled = this.frustumCulled;

			object.userData = JSON.parse( JSON.stringify( this.userData ) );

			if ( recursive === true ) {

				for ( var i = 0; i < this.children.length; i ++ ) {

					var child = this.children[ i ];
					object.add( child.clone() );

				}

			}

			return object;

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

	THREE.Object3DIdCount = 0;

	// File:src/core/Face3.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = normal instanceof Array ? normal : [];

		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = color instanceof Array ? color : [];

		this.vertexTangents = [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	};

	THREE.Face3.prototype = {

		constructor: THREE.Face3,

		clone: function () {

			var face = new THREE.Face3( this.a, this.b, this.c );

			face.normal.copy( this.normal );
			face.color.copy( this.color );

			face.materialIndex = this.materialIndex;

			for ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {

				face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();

			}

			for ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {

				face.vertexColors[ i ] = this.vertexColors[ i ].clone();

			}

			for ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {

				face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

			}

			return face;

		}

	};

	// File:src/core/Face4.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

		THREE.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' )
		return new THREE.Face3( a, b, c, normal, color, materialIndex );

	};

	// File:src/core/BufferAttribute.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferAttribute = function ( array, itemSize ) {

		this.array = array;
		this.itemSize = itemSize;

		this.needsUpdate = false;

	};

	THREE.BufferAttribute.prototype = {

		constructor: THREE.BufferAttribute,

		get length () {

			return this.array.length;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index     ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index     ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index     ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		clone: function () {

			return new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );

		}

	};

	//

	THREE.Int8Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Uint8Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Uint8ClampedAttribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );


	};

	THREE.Int16Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Uint16Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Int32Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Uint32Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Float32Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Float64Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	// File:src/core/DynamicBufferAttribute.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.DynamicBufferAttribute = function ( array, itemSize ) {

		THREE.BufferAttribute.call( this, array, itemSize );

		this.updateRange = { offset: 0, count: -1 };

	};

	THREE.DynamicBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
	THREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;

	THREE.DynamicBufferAttribute.prototype.clone = function () {

		return new THREE.DynamicBufferAttribute( new this.array.constructor( this.array ), this.itemSize );

	};

	// File:src/core/BufferGeometry.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferGeometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.attributes = {};
		this.attributesKeys = [];

		this.drawcalls = [];
		this.offsets = this.drawcalls; // backwards compatibility

		this.boundingBox = null;
		this.boundingSphere = null;

	};

	THREE.BufferGeometry.prototype = {

		constructor: THREE.BufferGeometry,

		addAttribute: function ( name, attribute ) {

			if ( attribute instanceof THREE.BufferAttribute === false ) {

				THREE.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

				this.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };

				return;

			}

			this.attributes[ name ] = attribute;
			this.attributesKeys = Object.keys( this.attributes );

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		addDrawCall: function ( start, count, indexOffset ) {

			this.drawcalls.push( {

				start: start,
				count: count,
				index: indexOffset !== undefined ? indexOffset : 0

			} );

		},

		applyMatrix: function ( matrix ) {

			var position = this.attributes.position;

			if ( position !== undefined ) {

				matrix.applyToVector3Array( position.array );
				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if ( normal !== undefined ) {

				var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

				normalMatrix.applyToVector3Array( normal.array );
				normal.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

		},

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.center().negate();

			this.applyMatrix( new THREE.Matrix4().setPosition( offset ) );

			return offset;

		},

		fromGeometry: function ( geometry, settings ) {

			settings = settings || { 'vertexColors': THREE.NoColors };

			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var faceVertexUvs = geometry.faceVertexUvs;
			var vertexColors = settings.vertexColors;
			var hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexNormals = faces[ 0 ].vertexNormals.length == 3;

			var positions = new Float32Array( faces.length * 3 * 3 );
			this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

			var normals = new Float32Array( faces.length * 3 * 3 );
			this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

			if ( vertexColors !== THREE.NoColors ) {

				var colors = new Float32Array( faces.length * 3 * 3 );
				this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

			}

			if ( hasFaceVertexUv === true ) {

				var uvs = new Float32Array( faces.length * 3 * 2 );
				this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

			}

			for ( var i = 0, i2 = 0, i3 = 0; i < faces.length; i ++, i2 += 6, i3 += 9 ) {

				var face = faces[ i ];

				var a = vertices[ face.a ];
				var b = vertices[ face.b ];
				var c = vertices[ face.c ];

				positions[ i3     ] = a.x;
				positions[ i3 + 1 ] = a.y;
				positions[ i3 + 2 ] = a.z;

				positions[ i3 + 3 ] = b.x;
				positions[ i3 + 4 ] = b.y;
				positions[ i3 + 5 ] = b.z;

				positions[ i3 + 6 ] = c.x;
				positions[ i3 + 7 ] = c.y;
				positions[ i3 + 8 ] = c.z;

				if ( hasFaceVertexNormals === true ) {

					var na = face.vertexNormals[ 0 ];
					var nb = face.vertexNormals[ 1 ];
					var nc = face.vertexNormals[ 2 ];

					normals[ i3     ] = na.x;
					normals[ i3 + 1 ] = na.y;
					normals[ i3 + 2 ] = na.z;

					normals[ i3 + 3 ] = nb.x;
					normals[ i3 + 4 ] = nb.y;
					normals[ i3 + 5 ] = nb.z;

					normals[ i3 + 6 ] = nc.x;
					normals[ i3 + 7 ] = nc.y;
					normals[ i3 + 8 ] = nc.z;

				} else {

					var n = face.normal;

					normals[ i3     ] = n.x;
					normals[ i3 + 1 ] = n.y;
					normals[ i3 + 2 ] = n.z;

					normals[ i3 + 3 ] = n.x;
					normals[ i3 + 4 ] = n.y;
					normals[ i3 + 5 ] = n.z;

					normals[ i3 + 6 ] = n.x;
					normals[ i3 + 7 ] = n.y;
					normals[ i3 + 8 ] = n.z;

				}

				if ( vertexColors === THREE.FaceColors ) {

					var fc = face.color;

					colors[ i3     ] = fc.r;
					colors[ i3 + 1 ] = fc.g;
					colors[ i3 + 2 ] = fc.b;

					colors[ i3 + 3 ] = fc.r;
					colors[ i3 + 4 ] = fc.g;
					colors[ i3 + 5 ] = fc.b;

					colors[ i3 + 6 ] = fc.r;
					colors[ i3 + 7 ] = fc.g;
					colors[ i3 + 8 ] = fc.b;

				} else if ( vertexColors === THREE.VertexColors ) {

					var vca = face.vertexColors[ 0 ];
					var vcb = face.vertexColors[ 1 ];
					var vcc = face.vertexColors[ 2 ];

					colors[ i3     ] = vca.r;
					colors[ i3 + 1 ] = vca.g;
					colors[ i3 + 2 ] = vca.b;

					colors[ i3 + 3 ] = vcb.r;
					colors[ i3 + 4 ] = vcb.g;
					colors[ i3 + 5 ] = vcb.b;

					colors[ i3 + 6 ] = vcc.r;
					colors[ i3 + 7 ] = vcc.g;
					colors[ i3 + 8 ] = vcc.b;

				}

				if ( hasFaceVertexUv === true ) {

					var uva = faceVertexUvs[ 0 ][ i ][ 0 ];
					var uvb = faceVertexUvs[ 0 ][ i ][ 1 ];
					var uvc = faceVertexUvs[ 0 ][ i ][ 2 ];

					uvs[ i2     ] = uva.x;
					uvs[ i2 + 1 ] = uva.y;

					uvs[ i2 + 2 ] = uvb.x;
					uvs[ i2 + 3 ] = uvb.y;

					uvs[ i2 + 4 ] = uvc.x;
					uvs[ i2 + 5 ] = uvc.y;

				}

			}

			this.computeBoundingSphere()

			return this;

		},

		computeBoundingBox: function () {

			var vector = new THREE.Vector3();

			return function () {

				if ( this.boundingBox === null ) {

					this.boundingBox = new THREE.Box3();

				}

				var positions = this.attributes.position.array;

				if ( positions ) {

					var bb = this.boundingBox;
					bb.makeEmpty();

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
						bb.expandByPoint( vector );

					}

				}

				if ( positions === undefined || positions.length === 0 ) {

					this.boundingBox.min.set( 0, 0, 0 );
					this.boundingBox.max.set( 0, 0, 0 );

				}

				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

					THREE.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.' );

				}

			}

		}(),

		computeBoundingSphere: function () {

			var box = new THREE.Box3();
			var vector = new THREE.Vector3();

			return function () {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new THREE.Sphere();

				}

				var positions = this.attributes.position.array;

				if ( positions ) {

					box.makeEmpty();

					var center = this.boundingSphere.center;

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
						box.expandByPoint( vector );

					}

					box.center( center );

					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox:  sqrt(3) smaller in the best case

					var maxRadiusSq = 0;

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

					}

					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

					if ( isNaN( this.boundingSphere.radius ) ) {

						THREE.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.' );

					}

				}

			}

		}(),

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			var attributes = this.attributes;

			if ( attributes.position ) {

				var positions = attributes.position.array;

				if ( attributes.normal === undefined ) {

					this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

				} else {

					// reset existing normals to zero

					var normals = attributes.normal.array;

					for ( var i = 0, il = normals.length; i < il; i ++ ) {

						normals[ i ] = 0;

					}

				}

				var normals = attributes.normal.array;

				var vA, vB, vC,

				pA = new THREE.Vector3(),
				pB = new THREE.Vector3(),
				pC = new THREE.Vector3(),

				cb = new THREE.Vector3(),
				ab = new THREE.Vector3();

				// indexed elements

				if ( attributes.index ) {

					var indices = attributes.index.array;

					var offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );

					for ( var j = 0, jl = offsets.length; j < jl; ++ j ) {

						var start = offsets[ j ].start;
						var count = offsets[ j ].count;
						var index = offsets[ j ].index;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							vA = ( index + indices[ i     ] ) * 3;
							vB = ( index + indices[ i + 1 ] ) * 3;
							vC = ( index + indices[ i + 2 ] ) * 3;

							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ vA     ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;

							normals[ vB     ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;

							normals[ vC     ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;

						}

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( var i = 0, il = positions.length; i < il; i += 9 ) {

						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ i     ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;

						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;

						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;

					}

				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;

			}

		},

		computeTangents: function () {

			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if ( this.attributes.index === undefined ||
				 this.attributes.position === undefined ||
				 this.attributes.normal === undefined ||
				 this.attributes.uv === undefined ) {

				THREE.warn( 'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );
				return;

			}

			var indices = this.attributes.index.array;
			var positions = this.attributes.position.array;
			var normals = this.attributes.normal.array;
			var uvs = this.attributes.uv.array;

			var nVertices = positions.length / 3;

			if ( this.attributes.tangent === undefined ) {

				this.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

			}

			var tangents = this.attributes.tangent.array;

			var tan1 = [], tan2 = [];

			for ( var k = 0; k < nVertices; k ++ ) {

				tan1[ k ] = new THREE.Vector3();
				tan2[ k ] = new THREE.Vector3();

			}

			var vA = new THREE.Vector3(),
				vB = new THREE.Vector3(),
				vC = new THREE.Vector3(),

				uvA = new THREE.Vector2(),
				uvB = new THREE.Vector2(),
				uvC = new THREE.Vector2(),

				x1, x2, y1, y2, z1, z2,
				s1, s2, t1, t2, r;

			var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

			function handleTriangle( a, b, c ) {

				vA.fromArray( positions, a * 3 );
				vB.fromArray( positions, b * 3 );
				vC.fromArray( positions, c * 3 );

				uvA.fromArray( uvs, a * 2 );
				uvB.fromArray( uvs, b * 2 );
				uvC.fromArray( uvs, c * 2 );

				x1 = vB.x - vA.x;
				x2 = vC.x - vA.x;

				y1 = vB.y - vA.y;
				y2 = vC.y - vA.y;

				z1 = vB.z - vA.z;
				z2 = vC.z - vA.z;

				s1 = uvB.x - uvA.x;
				s2 = uvC.x - uvA.x;

				t1 = uvB.y - uvA.y;
				t2 = uvC.y - uvA.y;

				r = 1.0 / ( s1 * t2 - s2 * t1 );

				sdir.set(
					( t2 * x1 - t1 * x2 ) * r,
					( t2 * y1 - t1 * y2 ) * r,
					( t2 * z1 - t1 * z2 ) * r
				);

				tdir.set(
					( s1 * x2 - s2 * x1 ) * r,
					( s1 * y2 - s2 * y1 ) * r,
					( s1 * z2 - s2 * z1 ) * r
				);

				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );

				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );

			}

			var i, il;
			var j, jl;
			var iA, iB, iC;

			if ( this.drawcalls.length === 0 ) {

				this.addDrawCall( 0, indices.length, 0 );

			}

			var drawcalls = this.drawcalls;

			for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

				var start = drawcalls[ j ].start;
				var count = drawcalls[ j ].count;
				var index = drawcalls[ j ].index;

				for ( i = start, il = start + count; i < il; i += 3 ) {

					iA = index + indices[ i ];
					iB = index + indices[ i + 1 ];
					iC = index + indices[ i + 2 ];

					handleTriangle( iA, iB, iC );

				}

			}

			var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
			var n = new THREE.Vector3(), n2 = new THREE.Vector3();
			var w, t, test;

			function handleVertex( v ) {

				n.fromArray( normals, v * 3 );
				n2.copy( n );

				t = tan1[ v ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( n2, t );
				test = tmp2.dot( tan2[ v ] );
				w = ( test < 0.0 ) ? - 1.0 : 1.0;

				tangents[ v * 4     ] = tmp.x;
				tangents[ v * 4 + 1 ] = tmp.y;
				tangents[ v * 4 + 2 ] = tmp.z;
				tangents[ v * 4 + 3 ] = w;

			}

			for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

				var start = drawcalls[ j ].start;
				var count = drawcalls[ j ].count;
				var index = drawcalls[ j ].index;

				for ( i = start, il = start + count; i < il; i += 3 ) {

					iA = index + indices[ i ];
					iB = index + indices[ i + 1 ];
					iC = index + indices[ i + 2 ];

					handleVertex( iA );
					handleVertex( iB );
					handleVertex( iC );

				}

			}

		},

		/*
		Compute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.
		This method will effectively rewrite the index buffer and remap all attributes to match the new indices.
		WARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.
		size - Defaults to 65535, but allows for larger or smaller chunks.
		*/
		computeOffsets: function ( size ) {

			if ( size === undefined ) size = 65535; // WebGL limits type of index buffer values to 16-bit.

			var indices = this.attributes.index.array;
			var vertices = this.attributes.position.array;

			var facesCount = ( indices.length / 3 );

			/*
			console.log("Computing buffers in offsets of "+size+" -> indices:"+indices.length+" vertices:"+vertices.length);
			console.log("Faces to process: "+(indices.length/3));
			console.log("Reordering "+verticesCount+" vertices.");
			*/

			var sortedIndices = new Uint16Array( indices.length ); //16-bit buffers
			var indexPtr = 0;
			var vertexPtr = 0;

			var offsets = [ { start:0, count:0, index:0 } ];
			var offset = offsets[ 0 ];

			var duplicatedVertices = 0;
			var newVerticeMaps = 0;
			var faceVertices = new Int32Array( 6 );
			var vertexMap = new Int32Array( vertices.length );
			var revVertexMap = new Int32Array( vertices.length );
			for ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }

			/*
				Traverse every face and reorder vertices in the proper offsets of 65k.
				We can have more than 65k entries in the index buffer per offset, but only reference 65k values.
			*/
			for ( var findex = 0; findex < facesCount; findex ++ ) {
				newVerticeMaps = 0;

				for ( var vo = 0; vo < 3; vo ++ ) {
					var vid = indices[ findex * 3 + vo ];
					if ( vertexMap[ vid ] == - 1 ) {
						//Unmapped vertice
						faceVertices[ vo * 2 ] = vid;
						faceVertices[ vo * 2 + 1 ] = - 1;
						newVerticeMaps ++;
					} else if ( vertexMap[ vid ] < offset.index ) {
						//Reused vertices from previous block (duplicate)
						faceVertices[ vo * 2 ] = vid;
						faceVertices[ vo * 2 + 1 ] = - 1;
						duplicatedVertices ++;
					} else {
						//Reused vertice in the current block
						faceVertices[ vo * 2 ] = vid;
						faceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];
					}
				}

				var faceMax = vertexPtr + newVerticeMaps;
				if ( faceMax > ( offset.index + size ) ) {
					var new_offset = { start:indexPtr, count:0, index:vertexPtr };
					offsets.push( new_offset );
					offset = new_offset;

					//Re-evaluate reused vertices in light of new offset.
					for ( var v = 0; v < 6; v += 2 ) {
						var new_vid = faceVertices[ v + 1 ];
						if ( new_vid > - 1 && new_vid < offset.index )
							faceVertices[ v + 1 ] = - 1;
					}
				}

				//Reindex the face.
				for ( var v = 0; v < 6; v += 2 ) {
					var vid = faceVertices[ v ];
					var new_vid = faceVertices[ v + 1 ];

					if ( new_vid === - 1 )
						new_vid = vertexPtr ++;

					vertexMap[ vid ] = new_vid;
					revVertexMap[ new_vid ] = vid;
					sortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit
					offset.count ++;
				}
			}

			/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */
			this.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );
			this.offsets = offsets; // TODO: Deprecate
			this.drawcalls = offsets;

			/*
			var orderTime = Date.now();
			console.log("Reorder time: "+(orderTime-s)+"ms");
			console.log("Duplicated "+duplicatedVertices+" vertices.");
			console.log("Compute Buffers time: "+(Date.now()-s)+"ms");
			console.log("Draw offsets: "+offsets.length);
			*/

			return offsets;

		},

		merge: function ( geometry, offset ) {

			if ( geometry instanceof THREE.BufferGeometry === false ) {

				THREE.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) offset = 0;

			var attributes = this.attributes;

			for ( var key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;

				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;

				var attributeSize = attribute2.itemSize;

				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			var normals = this.attributes.normal.array;

			var x, y, z, n;

			for ( var i = 0, il = normals.length; i < il; i += 3 ) {

				x = normals[ i ];
				y = normals[ i + 1 ];
				z = normals[ i + 2 ];

				n = 1.0 / Math.sqrt( x * x + y * y + z * z );

				normals[ i     ] *= n;
				normals[ i + 1 ] *= n;
				normals[ i + 2 ] *= n;

			}

		},

		/*
			reoderBuffers:
			Reorder attributes based on a new indexBuffer and indexMap.
			indexBuffer - Uint16Array of the new ordered indices.
			indexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.
			vertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).
		*/
		reorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {

			/* Create a copy of all attributes for reordering. */
			var sortedAttributes = {};
			for ( var attr in this.attributes ) {
				if ( attr == 'index' )
					continue;
				var sourceArray = this.attributes[ attr ].array;
				sortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );
			}

			/* Move attribute positions based on the new index map */
			for ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {
				var vid = indexMap[ new_vid ];
				for ( var attr in this.attributes ) {
					if ( attr == 'index' )
						continue;
					var attrArray = this.attributes[ attr ].array;
					var attrSize = this.attributes[ attr ].itemSize;
					var sortedAttr = sortedAttributes[ attr ];
					for ( var k = 0; k < attrSize; k ++ )
						sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];
				}
			}

			/* Carry the new sorted buffers locally */
			this.attributes[ 'index' ].array = indexBuffer;
			for ( var attr in this.attributes ) {
				if ( attr == 'index' )
					continue;
				this.attributes[ attr ].array = sortedAttributes[ attr ];
				this.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;
			}
		},

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.0,
					type: 'BufferGeometry',
					generator: 'BufferGeometryExporter'
				},
				uuid: this.uuid,
				type: this.type,
				data: {
					attributes: {}
				}
			};

			var attributes = this.attributes;
			var offsets = this.offsets;
			var boundingSphere = this.boundingSphere;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];

				var array = Array.prototype.slice.call( attribute.array );

				output.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array
				}

			}

			if ( offsets.length > 0 ) {

				output.data.offsets = JSON.parse( JSON.stringify( offsets ) );

			}

			if ( boundingSphere !== null ) {

				output.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				}

			}

			return output;

		},

		clone: function () {

			var geometry = new THREE.BufferGeometry();

			for ( var attr in this.attributes ) {

				var sourceAttr = this.attributes[ attr ];
				geometry.addAttribute( attr, sourceAttr.clone() );

			}

			for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {

				var offset = this.offsets[ i ];

				geometry.offsets.push( {

					start: offset.start,
					index: offset.index,
					count: offset.count

				} );

			}

			return geometry;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

	// File:src/core/Geometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Geometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];  // one-to-one vertex colors, used in Points and Line

		this.faces = [];

		this.faceVertexUvs = [ [] ];

		this.morphTargets = [];
		this.morphColors = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.hasTangents = false;

		this.dynamic = true; // the intermediate typed arrays will be deleted when set to false

		// update flags

		this.verticesNeedUpdate = false;
		this.elementsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.tangentsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;

		this.groupsNeedUpdate = false;

	};

	THREE.Geometry.prototype = {

		constructor: THREE.Geometry,

		applyMatrix: function ( matrix ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );

			}

			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

				}

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;

		},

		fromBufferGeometry: function ( geometry ) {

			var scope = this;

			var attributes = geometry.attributes;

			var vertices = attributes.position.array;
			var indices = attributes.index !== undefined ? attributes.index.array : undefined;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;

			var tempNormals = [];
			var tempUVs = [];

			for ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {

				scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

				if ( normals !== undefined ) {

					tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

				}

				if ( colors !== undefined ) {

					scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

				}

				if ( uvs !== undefined ) {

					tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

				}

			}

			var addFace = function ( a, b, c ) {

				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

				scope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );

				if ( uvs !== undefined ) {

					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

				}

			};

			if ( indices !== undefined ) {

				var drawcalls = geometry.drawcalls;

				if ( drawcalls.length > 0 ) {

					for ( var i = 0; i < drawcalls.length; i ++ ) {

						var drawcall = drawcalls[ i ];

						var start = drawcall.start;
						var count = drawcall.count;
						var index = drawcall.index;

						for ( var j = start, jl = start + count; j < jl; j += 3 ) {

							addFace( index + indices[ j ], index + indices[ j + 1 ], index + indices[ j + 2 ] );

						}

					}

				} else {

					for ( var i = 0; i < indices.length; i += 3 ) {

						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

					}

				}

			} else {

				for ( var i = 0; i < vertices.length / 3; i += 3 ) {

					addFace( i, i + 1, i + 2 );

				}

			}

			this.computeFaceNormals();

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			return this;

		},

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.center().negate();

			this.applyMatrix( new THREE.Matrix4().setPosition( offset ) );

			return offset;

		},

		computeFaceNormals: function () {

			var cb = new THREE.Vector3(), ab = new THREE.Vector3();

			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

				var face = this.faces[ f ];

				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				cb.normalize();

				face.normal.copy( cb );

			}

		},

		computeVertexNormals: function ( areaWeighted ) {

			var v, vl, f, fl, face, vertices;

			vertices = new Array( this.vertices.length );

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new THREE.Vector3();

			}

			if ( areaWeighted ) {

				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				var vA, vB, vC;
				var cb = new THREE.Vector3(), ab = new THREE.Vector3();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );

				}

			} else {

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );

				}

			}

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].normalize();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.vertexNormals[ 0 ] = vertices[ face.a ].clone();
				face.vertexNormals[ 1 ] = vertices[ face.b ].clone();
				face.vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		},

		computeMorphNormals: function () {

			var i, il, f, fl, face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( ! face.__originalFaceNormal ) {

					face.__originalFaceNormal = face.normal.clone();

				} else {

					face.__originalFaceNormal.copy( face.normal );

				}

				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

					if ( ! face.__originalVertexNormals[ i ] ) {

						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

					} else {

						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

					}

				}

			}

			// use temp geometry to compute face and vertex normals for each morph

			var tmpGeo = new THREE.Geometry();
			tmpGeo.faces = this.faces;

			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

				// create on first access

				if ( ! this.morphNormals[ i ] ) {

					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];

					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						faceNormal = new THREE.Vector3();
						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );

					}

				}

				var morphNormals = this.morphNormals[ i ];

				// set vertices to morph target

				tmpGeo.vertices = this.morphTargets[ i ].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];

					faceNormal.copy( face.normal );

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

				}

			}

			// restore original normals

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;

			}

		},

		computeTangents: function () {

			// based on http://www.terathon.com/code/tangent.html
			// tangents go to vertices

			var f, fl, v, vl, i, vertexIndex,
				face, uv, vA, vB, vC, uvA, uvB, uvC,
				x1, x2, y1, y2, z1, z2,
				s1, s2, t1, t2, r, t, test,
				tan1 = [], tan2 = [],
				sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
				tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
				n = new THREE.Vector3(), w;

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				tan1[ v ] = new THREE.Vector3();
				tan2[ v ] = new THREE.Vector3();

			}

			function handleTriangle( context, a, b, c, ua, ub, uc ) {

				vA = context.vertices[ a ];
				vB = context.vertices[ b ];
				vC = context.vertices[ c ];

				uvA = uv[ ua ];
				uvB = uv[ ub ];
				uvC = uv[ uc ];

				x1 = vB.x - vA.x;
				x2 = vC.x - vA.x;
				y1 = vB.y - vA.y;
				y2 = vC.y - vA.y;
				z1 = vB.z - vA.z;
				z2 = vC.z - vA.z;

				s1 = uvB.x - uvA.x;
				s2 = uvC.x - uvA.x;
				t1 = uvB.y - uvA.y;
				t2 = uvC.y - uvA.y;

				r = 1.0 / ( s1 * t2 - s2 * t1 );
				sdir.set( ( t2 * x1 - t1 * x2 ) * r,
						  ( t2 * y1 - t1 * y2 ) * r,
						  ( t2 * z1 - t1 * z2 ) * r );
				tdir.set( ( s1 * x2 - s2 * x1 ) * r,
						  ( s1 * y2 - s2 * y1 ) * r,
						  ( s1 * z2 - s2 * z1 ) * r );

				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );

				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];
				uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

				handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

			}

			var faceIndex = [ 'a', 'b', 'c', 'd' ];

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {

					n.copy( face.vertexNormals[ i ] );

					vertexIndex = face[ faceIndex[ i ] ];

					t = tan1[ vertexIndex ];

					// Gram-Schmidt orthogonalize

					tmp.copy( t );
					tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

					// Calculate handedness

					tmp2.crossVectors( face.vertexNormals[ i ], t );
					test = tmp2.dot( tan2[ vertexIndex ] );
					w = ( test < 0.0 ) ? - 1.0 : 1.0;

					face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

				}

			}

			this.hasTangents = true;

		},

		computeLineDistances: function () {

			var d = 0;
			var vertices = this.vertices;

			for ( var i = 0, il = vertices.length; i < il; i ++ ) {

				if ( i > 0 ) {

					d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

				}

				this.lineDistances[ i ] = d;

			}

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new THREE.Box3();

			}

			this.boundingBox.setFromPoints( this.vertices );

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			this.boundingSphere.setFromPoints( this.vertices );

		},

		merge: function ( geometry, matrix, materialIndexOffset ) {

			if ( geometry instanceof THREE.Geometry === false ) {

				THREE.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;

			}

			var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			uvs1 = this.faceVertexUvs[ 0 ],
			uvs2 = geometry.faceVertexUvs[ 0 ];

			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

			if ( matrix !== undefined ) {

				normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			}

			// vertices

			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

				var vertex = vertices2[ i ];

				var vertexCopy = vertex.clone();

				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

				vertices1.push( vertexCopy );

			}

			// faces

			for ( i = 0, il = faces2.length; i < il; i ++ ) {

				var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;

				faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );

				if ( normalMatrix !== undefined ) {

					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

				}

				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

					normal = faceVertexNormals[ j ].clone();

					if ( normalMatrix !== undefined ) {

						normal.applyMatrix3( normalMatrix ).normalize();

					}

					faceCopy.vertexNormals.push( normal );

				}

				faceCopy.color.copy( face.color );

				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );

				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push( faceCopy );

			}

			// uvs

			for ( i = 0, il = uvs2.length; i < il; i ++ ) {

				var uv = uvs2[ i ], uvCopy = [];

				if ( uv === undefined ) {

					continue;

				}

				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

					uvCopy.push( uv[ j ].clone() );

				}

				uvs1.push( uvCopy );

			}

		},

		mergeMesh: function ( mesh ) {

			if ( mesh instanceof THREE.Mesh === false ) {

				THREE.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;

			}

			mesh.matrixAutoUpdate && mesh.updateMatrix();

			this.merge( mesh.geometry, mesh.matrix );

		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices: function () {

			var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
			var unique = [], changes = [];

			var v, key;
			var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;

			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

				if ( verticesMap[ key ] === undefined ) {

					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;

				} else {

					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];

				}

			};


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];

			for ( i = 0, il = this.faces.length; i < il; i ++ ) {

				face = this.faces[ i ];

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

				indices = [ face.a, face.b, face.c ];

				var dupIndex = - 1;

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {
					if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {

						dupIndex = n;
						faceIndicesToRemove.push( i );
						break;

					}
				}

			}

			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
				var idx = faceIndicesToRemove[ i ];

				this.faces.splice( idx, 1 );

				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

					this.faceVertexUvs[ j ].splice( idx, 1 );

				}

			}

			// Use unique set of vertices

			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;

		},

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.0,
					type: 'BufferGeometry',
					generator: 'BufferGeometryExporter'
				},
				uuid: this.uuid,
				type: this.type
			};

			if ( this.name !== "" ) output.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) output[ key ] = parameters[ key ];

				}

				return output;

			}

			var vertices = [];

			for ( var i = 0; i < this.vertices.length; i ++ ) {

				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};

			for ( var i = 0; i < this.faces.length; i ++ ) {

				var face = this.faces[ i ];

				var hasMaterial = false; // face.materialIndex !== undefined;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;

				var faceType = 0;

				faceType = setBit( faceType, 0, 0 );
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );

				faces.push( faceType );
				faces.push( face.a, face.b, face.c );


				/*
				if ( hasMaterial ) {

					faces.push( face.materialIndex );

				}
				*/

				if ( hasFaceVertexUv ) {

					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);

				}

				if ( hasFaceNormal ) {

					faces.push( getNormalIndex( face.normal ) );

				}

				if ( hasFaceVertexNormal ) {

					var vertexNormals = face.vertexNormals;

					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);

				}

				if ( hasFaceColor ) {

					faces.push( getColorIndex( face.color ) );

				}

				if ( hasFaceVertexColor ) {

					var vertexColors = face.vertexColors;

					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);

				}

			}

			function setBit( value, position, enabled ) {

				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );

			}

			function getNormalIndex( normal ) {

				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if ( normalsHash[ hash ] !== undefined ) {

					return normalsHash[ hash ];

				}

				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );

				return normalsHash[ hash ];

			}

			function getColorIndex( color ) {

				var hash = color.r.toString() + color.g.toString() + color.b.toString();

				if ( colorsHash[ hash ] !== undefined ) {

					return colorsHash[ hash ];

				}

				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );

				return colorsHash[ hash ];

			}

			function getUvIndex( uv ) {

				var hash = uv.x.toString() + uv.y.toString();

				if ( uvsHash[ hash ] !== undefined ) {

					return uvsHash[ hash ];

				}

				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );

				return uvsHash[ hash ];

			}

			output.data = {};

			output.data.vertices = vertices;
			output.data.normals = normals;
			if ( colors.length > 0 ) output.data.colors = colors;
			if ( uvs.length > 0 ) output.data.uvs = [ uvs ]; // temporal backward compatibility
			output.data.faces = faces;

			//

			return output;

		},

		clone: function () {

			var geometry = new THREE.Geometry();

			var vertices = this.vertices;

			for ( var i = 0, il = vertices.length; i < il; i ++ ) {

				geometry.vertices.push( vertices[ i ].clone() );

			}

			var faces = this.faces;

			for ( var i = 0, il = faces.length; i < il; i ++ ) {

				geometry.faces.push( faces[ i ].clone() );

			}

			for ( var i = 0, il = this.faceVertexUvs.length; i < il; i ++ ) {

				var faceVertexUvs = this.faceVertexUvs[ i ];

				if ( geometry.faceVertexUvs[ i ] === undefined ) {

					geometry.faceVertexUvs[ i ] = [];

				}

				for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

					var uvs = faceVertexUvs[ j ], uvsCopy = [];

					for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

						var uv = uvs[ k ];

						uvsCopy.push( uv.clone() );

					}

					geometry.faceVertexUvs[ i ].push( uvsCopy );

				}

			}

			return geometry;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

	THREE.GeometryIdCount = 0;

	// File:src/cameras/Camera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.Camera = function () {

		THREE.Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new THREE.Matrix4();
		this.projectionMatrix = new THREE.Matrix4();

	};

	THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Camera.prototype.constructor = THREE.Camera;

	THREE.Camera.prototype.getWorldDirection = function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

		}

	}();

	THREE.Camera.prototype.lookAt = function () {

		// This routine does not support cameras with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( this.position, vector, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}();

	THREE.Camera.prototype.clone = function ( camera ) {

		if ( camera === undefined ) camera = new THREE.Camera();

		THREE.Object3D.prototype.clone.call( this, camera );

		camera.matrixWorldInverse.copy( this.matrixWorldInverse );
		camera.projectionMatrix.copy( this.projectionMatrix );

		return camera;
	};

	// File:src/cameras/CubeCamera.js

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.CubeCamera = function ( near, far, cubeResolution ) {

		THREE.Object3D.call( this );

		this.type = 'CubeCamera';

		var fov = 90, aspect = 1;

		var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

		this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

		this.updateCubeMap = function ( renderer, scene ) {

			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.generateMipmaps;

			renderTarget.generateMipmaps = false;

			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );

			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );

			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );

			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );

			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );

			renderTarget.generateMipmaps = generateMipmaps;

			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );

		};

	};

	THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

	// File:src/cameras/OrthographicCamera.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

		THREE.Camera.call( this );

		this.type = 'OrthographicCamera';

		this.zoom = 1;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;

		this.updateProjectionMatrix();

	};

	THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

	THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;

		this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

	};

	THREE.OrthographicCamera.prototype.clone = function () {

		var camera = new THREE.OrthographicCamera();

		THREE.Camera.prototype.clone.call( this, camera );

		camera.zoom = this.zoom;

		camera.left = this.left;
		camera.right = this.right;
		camera.top = this.top;
		camera.bottom = this.bottom;

		camera.near = this.near;
		camera.far = this.far;

		camera.projectionMatrix.copy( this.projectionMatrix );

		return camera;
	};

	// File:src/cameras/PerspectiveCamera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

		THREE.Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.zoom = 1;

		this.fov = fov !== undefined ? fov : 50;
		this.aspect = aspect !== undefined ? aspect : 1;
		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;

		this.updateProjectionMatrix();

	};

	THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


	/**
	 * Uses Focal Length (in mm) to estimate and set FOV
	 * 35mm (fullframe) camera is used if frame size is not specified;
	 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	 */

	THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

		if ( frameHeight === undefined ) frameHeight = 24;

		this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
		this.updateProjectionMatrix();

	}


	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */

	THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

		this.fullWidth = fullWidth;
		this.fullHeight = fullHeight;
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;

		this.updateProjectionMatrix();

	};


	THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

		var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

		if ( this.fullWidth ) {

			var aspect = this.fullWidth / this.fullHeight;
			var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
			var bottom = - top;
			var left = aspect * bottom;
			var right = aspect * top;
			var width = Math.abs( right - left );
			var height = Math.abs( top - bottom );

			this.projectionMatrix.makeFrustum(
				left + this.x * width / this.fullWidth,
				left + ( this.x + this.width ) * width / this.fullWidth,
				top - ( this.y + this.height ) * height / this.fullHeight,
				top - this.y * height / this.fullHeight,
				this.near,
				this.far
			);

		} else {

			this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

		}

	};

	THREE.PerspectiveCamera.prototype.clone = function () {

		var camera = new THREE.PerspectiveCamera();

		THREE.Camera.prototype.clone.call( this, camera );

		camera.zoom = this.zoom;

		camera.fov = this.fov;
		camera.aspect = this.aspect;
		camera.near = this.near;
		camera.far = this.far;

		camera.projectionMatrix.copy( this.projectionMatrix );

		return camera;

	};

	// File:src/lights/Light.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Light = function ( color ) {

		THREE.Object3D.call( this );

		this.type = 'Light';
		
		this.color = new THREE.Color( color );

	};

	THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Light.prototype.constructor = THREE.Light;

	THREE.Light.prototype.clone = function ( light ) {

		if ( light === undefined ) light = new THREE.Light();

		THREE.Object3D.prototype.clone.call( this, light );

		light.color.copy( this.color );

		return light;

	};

	// File:src/lights/AmbientLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AmbientLight = function ( color ) {

		THREE.Light.call( this, color );

		this.type = 'AmbientLight';

	};

	THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
	THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

	THREE.AmbientLight.prototype.clone = function () {

		var light = new THREE.AmbientLight();

		THREE.Light.prototype.clone.call( this, light );

		return light;

	};

	// File:src/lights/AreaLight.js

	/**
	 * @author MPanknin / http://www.redplant.de/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.AreaLight = function ( color, intensity ) {

		THREE.Light.call( this, color );

		this.type = 'AreaLight';

		this.normal = new THREE.Vector3( 0, - 1, 0 );
		this.right = new THREE.Vector3( 1, 0, 0 );

		this.intensity = ( intensity !== undefined ) ? intensity : 1;

		this.width = 1.0;
		this.height = 1.0;

		this.constantAttenuation = 1.5;
		this.linearAttenuation = 0.5;
		this.quadraticAttenuation = 0.1;

	};

	THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );
	THREE.AreaLight.prototype.constructor = THREE.AreaLight;


	// File:src/lights/DirectionalLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DirectionalLight = function ( color, intensity ) {

		THREE.Light.call( this, color );

		this.type = 'DirectionalLight';

		this.position.set( 0, 1, 0 );
		this.target = new THREE.Object3D();

		this.intensity = ( intensity !== undefined ) ? intensity : 1;

		this.castShadow = false;
		this.onlyShadow = false;

		//

		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;

		this.shadowCameraLeft = - 500;
		this.shadowCameraRight = 500;
		this.shadowCameraTop = 500;
		this.shadowCameraBottom = - 500;

		this.shadowCameraVisible = false;

		this.shadowBias = 0;
		this.shadowDarkness = 0.5;

		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;

		//

		this.shadowCascade = false;

		this.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );
		this.shadowCascadeCount = 2;

		this.shadowCascadeBias = [ 0, 0, 0 ];
		this.shadowCascadeWidth = [ 512, 512, 512 ];
		this.shadowCascadeHeight = [ 512, 512, 512 ];

		this.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];
		this.shadowCascadeFarZ  = [ 0.990, 0.998, 1.000 ];

		this.shadowCascadeArray = [];

		//

		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;

	};

	THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
	THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

	THREE.DirectionalLight.prototype.clone = function () {

		var light = new THREE.DirectionalLight();

		THREE.Light.prototype.clone.call( this, light );

		light.target = this.target.clone();

		light.intensity = this.intensity;

		light.castShadow = this.castShadow;
		light.onlyShadow = this.onlyShadow;

		//

		light.shadowCameraNear = this.shadowCameraNear;
		light.shadowCameraFar = this.shadowCameraFar;

		light.shadowCameraLeft = this.shadowCameraLeft;
		light.shadowCameraRight = this.shadowCameraRight;
		light.shadowCameraTop = this.shadowCameraTop;
		light.shadowCameraBottom = this.shadowCameraBottom;

		light.shadowCameraVisible = this.shadowCameraVisible;

		light.shadowBias = this.shadowBias;
		light.shadowDarkness = this.shadowDarkness;

		light.shadowMapWidth = this.shadowMapWidth;
		light.shadowMapHeight = this.shadowMapHeight;

		//

		light.shadowCascade = this.shadowCascade;

		light.shadowCascadeOffset.copy( this.shadowCascadeOffset );
		light.shadowCascadeCount = this.shadowCascadeCount;

		light.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );
		light.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );
		light.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );

		light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );
		light.shadowCascadeFarZ  = this.shadowCascadeFarZ.slice( 0 );

		return light;

	};

	// File:src/lights/HemisphereLight.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

		THREE.Light.call( this, skyColor );

		this.type = 'HemisphereLight';

		this.position.set( 0, 100, 0 );

		this.groundColor = new THREE.Color( groundColor );
		this.intensity = ( intensity !== undefined ) ? intensity : 1;

	};

	THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
	THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

	THREE.HemisphereLight.prototype.clone = function () {

		var light = new THREE.HemisphereLight();

		THREE.Light.prototype.clone.call( this, light );

		light.groundColor.copy( this.groundColor );
		light.intensity = this.intensity;

		return light;

	};

	// File:src/lights/PointLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.PointLight = function ( color, intensity, distance, decay ) {

		THREE.Light.call( this, color );

		this.type = 'PointLight';

		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	};

	THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
	THREE.PointLight.prototype.constructor = THREE.PointLight;

	THREE.PointLight.prototype.clone = function () {

		var light = new THREE.PointLight();

		THREE.Light.prototype.clone.call( this, light );

		light.intensity = this.intensity;
		light.distance = this.distance;
		light.decay = this.decay;

		return light;

	};

	// File:src/lights/SpotLight.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {

		THREE.Light.call( this, color );

		this.type = 'SpotLight';

		this.position.set( 0, 1, 0 );
		this.target = new THREE.Object3D();

		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.exponent = ( exponent !== undefined ) ? exponent : 10;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.castShadow = false;
		this.onlyShadow = false;

		//

		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;
		this.shadowCameraFov = 50;

		this.shadowCameraVisible = false;

		this.shadowBias = 0;
		this.shadowDarkness = 0.5;

		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;

		//

		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;

	};

	THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
	THREE.SpotLight.prototype.constructor = THREE.SpotLight;

	THREE.SpotLight.prototype.clone = function () {

		var light = new THREE.SpotLight();

		THREE.Light.prototype.clone.call( this, light );

		light.target = this.target.clone();

		light.intensity = this.intensity;
		light.distance = this.distance;
		light.angle = this.angle;
		light.exponent = this.exponent;
		light.decay = this.decay;

		light.castShadow = this.castShadow;
		light.onlyShadow = this.onlyShadow;

		//

		light.shadowCameraNear = this.shadowCameraNear;
		light.shadowCameraFar = this.shadowCameraFar;
		light.shadowCameraFov = this.shadowCameraFov;

		light.shadowCameraVisible = this.shadowCameraVisible;

		light.shadowBias = this.shadowBias;
		light.shadowDarkness = this.shadowDarkness;

		light.shadowMapWidth = this.shadowMapWidth;
		light.shadowMapHeight = this.shadowMapHeight;

		return light;

	};

	// File:src/loaders/Cache.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Cache = {

		files: {},

		add: function ( key, file ) {

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {}

		}

	};

	// File:src/loaders/Loader.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Loader = function ( showStatus ) {

		this.showStatus = showStatus;
		this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

		this.imageLoader = new THREE.ImageLoader();

		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};

	};

	THREE.Loader.prototype = {

		constructor: THREE.Loader,

		crossOrigin: undefined,

		addStatusElement: function () {

			var e = document.createElement( 'div' );

			e.style.position = 'absolute';
			e.style.right = '0px';
			e.style.top = '0px';
			e.style.fontSize = '0.8em';
			e.style.textAlign = 'left';
			e.style.background = 'rgba(0,0,0,0.25)';
			e.style.color = '#fff';
			e.style.width = '120px';
			e.style.padding = '0.5em 0.5em 0.5em 0.5em';
			e.style.zIndex = 1000;

			e.innerHTML = 'Loading ...';

			return e;

		},

		updateProgress: function ( progress ) {

			var message = 'Loaded ';

			if ( progress.total ) {

				message += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';


			} else {

				message += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';

			}

			this.statusDomElement.innerHTML = message;

		},

		extractUrlBase: function ( url ) {

			var parts = url.split( '/' );

			if ( parts.length === 1 ) return './';

			parts.pop();

			return parts.join( '/' ) + '/';

		},

		initMaterials: function ( materials, texturePath ) {

			var array = [];

			for ( var i = 0; i < materials.length; ++ i ) {

				array[ i ] = this.createMaterial( materials[ i ], texturePath );

			}

			return array;

		},

		needsTangents: function ( materials ) {

			for ( var i = 0, il = materials.length; i < il; i ++ ) {

				var m = materials[ i ];

				if ( m instanceof THREE.ShaderMaterial ) return true;

			}

			return false;

		},

		createMaterial: function ( m, texturePath ) {

			var scope = this;

			function nearest_pow2( n ) {

				var l = Math.log( n ) / Math.LN2;
				return Math.pow( 2, Math.round(  l ) );

			}

			function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

				var fullPath = texturePath + sourceFile;

				var texture;

				var loader = THREE.Loader.Handlers.get( fullPath );

				if ( loader !== null ) {

					texture = loader.load( fullPath );

				} else {

					texture = new THREE.Texture();

					loader = scope.imageLoader;
					loader.crossOrigin = scope.crossOrigin;
					loader.load( fullPath, function ( image ) {

						if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
							 THREE.Math.isPowerOfTwo( image.height ) === false ) {

							var width = nearest_pow2( image.width );
							var height = nearest_pow2( image.height );

							var canvas = document.createElement( 'canvas' );
							canvas.width = width;
							canvas.height = height;

							var context = canvas.getContext( '2d' );
							context.drawImage( image, 0, 0, width, height );

							texture.image = canvas;

						} else {

							texture.image = image;

						}

						texture.needsUpdate = true;

					} );

				}

				texture.sourceFile = sourceFile;

				if ( repeat ) {

					texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

					if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

				}

				if ( offset ) {

					texture.offset.set( offset[ 0 ], offset[ 1 ] );

				}

				if ( wrap ) {

					var wrapMap = {
						'repeat': THREE.RepeatWrapping,
						'mirror': THREE.MirroredRepeatWrapping
					}

					if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
					if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

				}

				if ( anisotropy ) {

					texture.anisotropy = anisotropy;

				}

				where[ name ] = texture;

			}

			function rgb2hex( rgb ) {

				return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

			}

			// defaults

			var mtype = 'MeshLambertMaterial';
			var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

			// parameters from model file

			if ( m.shading ) {

				var shading = m.shading.toLowerCase();

				if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
				else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

			}

			if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

				mpars.blending = THREE[ m.blending ];

			}

			if ( m.transparent !== undefined ) {

				mpars.transparent = m.transparent;

			}

			if ( m.opacity !== undefined && m.opacity < 1.0 ) {

				mpars.transparent = true;

			}

			if ( m.depthTest !== undefined ) {

				mpars.depthTest = m.depthTest;

			}

			if ( m.depthWrite !== undefined ) {

				mpars.depthWrite = m.depthWrite;

			}

			if ( m.visible !== undefined ) {

				mpars.visible = m.visible;

			}

			if ( m.flipSided !== undefined ) {

				mpars.side = THREE.BackSide;

			}

			if ( m.doubleSided !== undefined ) {

				mpars.side = THREE.DoubleSide;

			}

			if ( m.wireframe !== undefined ) {

				mpars.wireframe = m.wireframe;

			}

			if ( m.vertexColors !== undefined ) {

				if ( m.vertexColors === 'face' ) {

					mpars.vertexColors = THREE.FaceColors;

				} else if ( m.vertexColors ) {

					mpars.vertexColors = THREE.VertexColors;

				}

			}

			// colors

			if ( m.colorDiffuse ) {

				mpars.color = rgb2hex( m.colorDiffuse );

			} else if ( m.DbgColor ) {

				mpars.color = m.DbgColor;

			}

			if ( m.colorSpecular ) {

				mpars.specular = rgb2hex( m.colorSpecular );

			}

			if ( m.colorEmissive ) {

				mpars.emissive = rgb2hex( m.colorEmissive );

			}

			// modifiers

			if ( m.transparency !== undefined ) {

				console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
				m.opacity = m.transparency;

			}

			if ( m.opacity !== undefined ) {

				mpars.opacity = m.opacity;

			}

			if ( m.specularCoef ) {

				mpars.shininess = m.specularCoef;

			}

			// textures

			if ( m.mapDiffuse && texturePath ) {

				create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

			}

			if ( m.mapLight && texturePath ) {

				create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

			}

			if ( m.mapBump && texturePath ) {

				create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

			}

			if ( m.mapNormal && texturePath ) {

				create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

			}

			if ( m.mapSpecular && texturePath ) {

				create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

			}

			if ( m.mapAlpha && texturePath ) {

				create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

			}

			//

			if ( m.mapBumpScale ) {

				mpars.bumpScale = m.mapBumpScale;

			}

			if ( m.mapNormalFactor ) {

				mpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );

			}

			var material = new THREE[ mtype ]( mpars );

			if ( m.DbgName !== undefined ) material.name = m.DbgName;

			return material;

		}

	};

	THREE.Loader.Handlers = {

		handlers: [],

		add: function ( regex, loader ) {

			this.handlers.push( regex, loader );

		},

		get: function ( file ) {

			for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

				var regex = this.handlers[ i ];
				var loader  = this.handlers[ i + 1 ];

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		}

	};

	// File:src/loaders/XHRLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.XHRLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.XHRLoader.prototype = {

		constructor: THREE.XHRLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var cached = THREE.Cache.get( url );

			if ( cached !== undefined ) {

				if ( onLoad ) onLoad( cached );
				return;

			}

			var request = new XMLHttpRequest();
			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				THREE.Cache.add( url, this.response );

				if ( onLoad ) onLoad( this.response );

				scope.manager.itemEnd( url );

			}, false );

			if ( onProgress !== undefined ) {

				request.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			if ( onError !== undefined ) {

				request.addEventListener( 'error', function ( event ) {

					onError( event );

				}, false );

			}

			if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
			if ( this.responseType !== undefined ) request.responseType = this.responseType;

			request.send( null );

			scope.manager.itemStart( url );

		},

		setResponseType: function ( value ) {

			this.responseType = value;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/ImageLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ImageLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.ImageLoader.prototype = {

		constructor: THREE.ImageLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var cached = THREE.Cache.get( url );

			if ( cached !== undefined ) {

				onLoad( cached );
				return;

			}

			var image = document.createElement( 'img' );

			image.addEventListener( 'load', function ( event ) {

				THREE.Cache.add( url, this );

				if ( onLoad ) onLoad( this );
				
				scope.manager.itemEnd( url );

			}, false );

			if ( onProgress !== undefined ) {

				image.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			if ( onError !== undefined ) {

				image.addEventListener( 'error', function ( event ) {

					onError( event );

				}, false );

			}

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			image.src = url;

			scope.manager.itemStart( url );

			return image;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	}

	// File:src/loaders/JSONLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.JSONLoader = function ( showStatus ) {

		THREE.Loader.call( this, showStatus );

		this.withCredentials = false;

	};

	THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );
	THREE.JSONLoader.prototype.constructor = THREE.JSONLoader;

	THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

		// todo: unify load API to for easier SceneLoader use

		texturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );

		this.onLoadStart();
		this.loadAjaxJSON( this, url, callback, texturePath );

	};

	THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

		var xhr = new XMLHttpRequest();

		var length = 0;

		xhr.onreadystatechange = function () {

			if ( xhr.readyState === xhr.DONE ) {

				if ( xhr.status === 200 || xhr.status === 0 ) {

					if ( xhr.responseText ) {

						var json = JSON.parse( xhr.responseText );
						var metadata = json.metadata;

						if ( metadata !== undefined ) {

							if ( metadata.type === 'object' ) {

								THREE.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
								return;

							}

							if ( metadata.type === 'scene' ) {

								THREE.error( 'THREE.JSONLoader: ' + url + ' seems to be a Scene. Use THREE.SceneLoader instead.' );
								return;

							}

						}

						var result = context.parse( json, texturePath );
						callback( result.geometry, result.materials );

					} else {

						THREE.error( 'THREE.JSONLoader: ' + url + ' seems to be unreachable or the file is empty.' );

					}

					// in context of more complex asset initialization
					// do not block on single failed file
					// maybe should go even one more level up

					context.onLoadComplete();

				} else {

					THREE.error( 'THREE.JSONLoader: Couldn\'t load ' + url + ' (' + xhr.status + ')' );

				}

			} else if ( xhr.readyState === xhr.LOADING ) {

				if ( callbackProgress ) {

					if ( length === 0 ) {

						length = xhr.getResponseHeader( 'Content-Length' );

					}

					callbackProgress( { total: length, loaded: xhr.responseText.length } );

				}

			} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

				if ( callbackProgress !== undefined ) {

					length = xhr.getResponseHeader( 'Content-Length' );

				}

			}

		};

		xhr.open( 'GET', url, true );
		xhr.withCredentials = this.withCredentials;
		xhr.send( null );

	};

	THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {

		var geometry = new THREE.Geometry(),
		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

		parseModel( scale );

		parseSkin();
		parseMorphing( scale );

		geometry.computeFaceNormals();
		geometry.computeBoundingSphere();

		function parseModel( scale ) {

			function isBitSet( value, position ) {

				return value & ( 1 << position );

			}

			var i, j, fi,

			offset, zLength,

			colorIndex, normalIndex, uvIndex, materialIndex,

			type,
			isQuad,
			hasMaterial,
			hasFaceVertexUv,
			hasFaceNormal, hasFaceVertexNormal,
			hasFaceColor, hasFaceVertexColor,

			vertex, face, faceA, faceB, hex, normal,

			uvLayer, uv, u, v,

			faces = json.faces,
			vertices = json.vertices,
			normals = json.normals,
			colors = json.colors,

			nUvLayers = 0;

			if ( json.uvs !== undefined ) {

				// disregard empty arrays

				for ( i = 0; i < json.uvs.length; i ++ ) {

					if ( json.uvs[ i ].length ) nUvLayers ++;

				}

				for ( i = 0; i < nUvLayers; i ++ ) {

					geometry.faceVertexUvs[ i ] = [];

				}

			}

			offset = 0;
			zLength = vertices.length;

			while ( offset < zLength ) {

				vertex = new THREE.Vector3();

				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;

				geometry.vertices.push( vertex );

			}

			offset = 0;
			zLength = faces.length;

			while ( offset < zLength ) {

				type = faces[ offset ++ ];


				isQuad              = isBitSet( type, 0 );
				hasMaterial         = isBitSet( type, 1 );
				hasFaceVertexUv     = isBitSet( type, 3 );
				hasFaceNormal       = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor	     = isBitSet( type, 6 );
				hasFaceVertexColor  = isBitSet( type, 7 );

				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

				if ( isQuad ) {

					faceA = new THREE.Face3();
					faceA.a = faces[ offset ];
					faceA.b = faces[ offset + 1 ];
					faceA.c = faces[ offset + 3 ];

					faceB = new THREE.Face3();
					faceB.a = faces[ offset + 1 ];
					faceB.b = faces[ offset + 2 ];
					faceB.c = faces[ offset + 3 ];

					offset += 4;

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];
							geometry.faceVertexUvs[ i ][ fi + 1 ] = []

							for ( j = 0; j < 4; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new THREE.Vector2( u, v );

								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						faceA.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						faceB.normal.copy( faceA.normal );

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 4; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);


							if ( i !== 2 ) faceA.vertexNormals.push( normal );
							if ( i !== 0 ) faceB.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						faceA.color.setHex( hex );
						faceB.color.setHex( hex );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 4; i ++ ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
							if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

						}

					}

					geometry.faces.push( faceA );
					geometry.faces.push( faceB );

				} else {

					face = new THREE.Face3();
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						face.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];

							for ( j = 0; j < 3; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new THREE.Vector2( u, v );

								geometry.faceVertexUvs[ i ][ fi ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						face.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 3; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							face.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						face.color.setHex( colors[ colorIndex ] );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 3; i ++ ) {

							colorIndex = faces[ offset ++ ];
							face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

						}

					}

					geometry.faces.push( face );

				}

			}

		};

		function parseSkin() {
			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

			if ( json.skinWeights ) {

				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

					var x =                               json.skinWeights[ i     ];
					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

					geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

				}

			}

			if ( json.skinIndices ) {

				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

					var a =                               json.skinIndices[ i     ];
					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

					geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

				}

			}

			geometry.bones = json.bones;

			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				THREE.warn( 'THREE.JSONLoader: When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

			}


			// could change this to json.animations[0] or remove completely

			geometry.animation = json.animation;
			geometry.animations = json.animations;

		};

		function parseMorphing( scale ) {

			if ( json.morphTargets !== undefined ) {

				var i, l, v, vl, dstVertices, srcVertices;

				for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];

					dstVertices = geometry.morphTargets[ i ].vertices;
					srcVertices = json.morphTargets [ i ].vertices;

					for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

						var vertex = new THREE.Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;

						dstVertices.push( vertex );

					}

				}

			}

			if ( json.morphColors !== undefined ) {

				var i, l, c, cl, dstColors, srcColors, color;

				for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {

					geometry.morphColors[ i ] = {};
					geometry.morphColors[ i ].name = json.morphColors[ i ].name;
					geometry.morphColors[ i ].colors = [];

					dstColors = geometry.morphColors[ i ].colors;
					srcColors = json.morphColors [ i ].colors;

					for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

						color = new THREE.Color( 0xffaa00 );
						color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
						dstColors.push( color );

					}

				}

			}

		};

		if ( json.materials === undefined || json.materials.length === 0 ) {

			return { geometry: geometry };

		} else {

			var materials = this.initMaterials( json.materials, texturePath );

			if ( this.needsTangents( materials ) ) {

				geometry.computeTangents();

			}

			return { geometry: geometry, materials: materials };

		}

	};

	// File:src/loaders/LoadingManager.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

		var scope = this;

		var loaded = 0, total = 0;

		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			total ++;

		};

		this.itemEnd = function ( url ) {

			loaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, loaded, total );

			}

			if ( loaded === total && scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		};

	};

	THREE.DefaultLoadingManager = new THREE.LoadingManager();

	// File:src/loaders/BufferGeometryLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferGeometryLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.BufferGeometryLoader.prototype = {

		constructor: THREE.BufferGeometryLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json ) {

			var geometry = new THREE.BufferGeometry();

			var attributes = json.data.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];
				var typedArray = new self[ attribute.type ]( attribute.array );

				geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

			}

			var offsets = json.data.offsets;

			if ( offsets !== undefined ) {

				geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

			}

			var boundingSphere = json.data.boundingSphere;

			if ( boundingSphere !== undefined ) {

				var center = new THREE.Vector3();

				if ( boundingSphere.center !== undefined ) {

					center.fromArray( boundingSphere.center );

				}

				geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

			}

			return geometry;

		}

	};

	// File:src/loaders/MaterialLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.MaterialLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.MaterialLoader.prototype = {

		constructor: THREE.MaterialLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json ) {

			var material = new THREE[ json.type ];

			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.shading !== undefined ) material.shading = json.shading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;

			// for PointCloudMaterial
			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

			if ( json.materials !== undefined ) {

				for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

					material.materials.push( this.parse( json.materials[ i ] ) );

				}

			}

			return material;

		}

	};

	// File:src/loaders/ObjectLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ObjectLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.texturePath = '';

	};

	THREE.ObjectLoader.prototype = {

		constructor: THREE.ObjectLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			if ( this.texturePath === '' ) {

				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

			}

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				scope.parse( JSON.parse( text ), onLoad );

			}, onProgress, onError );

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json, onLoad ) {

			var geometries = this.parseGeometries( json.geometries );

			var images = this.parseImages( json.images, function () {

				if ( onLoad !== undefined ) onLoad( object );

			} );
			var textures  = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );
			var object = this.parseObject( json.object, geometries, materials );

			if ( json.images === undefined || json.images.length === 0 ) {

				if ( onLoad !== undefined ) onLoad( object );

			}

			return object;

		},

		parseGeometries: function ( json ) {

			var geometries = {};

			if ( json !== undefined ) {

				var geometryLoader = new THREE.JSONLoader();
				var bufferGeometryLoader = new THREE.BufferGeometryLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var geometry;
					var data = json[ i ];

					switch ( data.type ) {

						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':

							geometry = new THREE[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);

							break;

						case 'BoxGeometry':
						case 'CubeGeometry': // backwards compatible

							geometry = new THREE.BoxGeometry(
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);

							break;

						case 'CircleGeometry':

							geometry = new THREE.CircleGeometry(
								data.radius,
								data.segments
							);

							break;

						case 'CylinderGeometry':

							geometry = new THREE.CylinderGeometry(
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded
							);

							break;

						case 'SphereGeometry':

							geometry = new THREE.SphereGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'IcosahedronGeometry':

							geometry = new THREE.IcosahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'TorusGeometry':

							geometry = new THREE.TorusGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);

							break;

						case 'TorusKnotGeometry':

							geometry = new THREE.TorusKnotGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.p,
								data.q,
								data.heightScale
							);

							break;

						case 'BufferGeometry':

							geometry = bufferGeometryLoader.parse( data );

							break;

						case 'Geometry':

							geometry = geometryLoader.parse( data.data ).geometry;

							break;

					}

					geometry.uuid = data.uuid;

					if ( data.name !== undefined ) geometry.name = data.name;

					geometries[ data.uuid ] = geometry;

				}

			}

			return geometries;

		},

		parseMaterials: function ( json, textures ) {

			var materials = {};

			if ( json !== undefined ) {

				var getTexture = function ( name ) {

					if ( textures[ name ] === undefined ) {

						THREE.warn( 'THREE.ObjectLoader: Undefined texture', name );

					}

					return textures[ name ];

				};

				var loader = new THREE.MaterialLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];
					var material = loader.parse( data );

					material.uuid = data.uuid;

					if ( data.name !== undefined ) material.name = data.name;

					if ( data.map !== undefined ) {

						material.map = getTexture( data.map );

					}

					if ( data.bumpMap !== undefined ) {

						material.bumpMap = getTexture( data.bumpMap );
						if ( data.bumpScale ) {
							material.bumpScale = new THREE.Vector2( data.bumpScale, data.bumpScale );
						}

					}

					if ( data.alphaMap !== undefined ) {

						material.alphaMap = getTexture( data.alphaMap );

					}

					if ( data.envMap !== undefined ) {

						material.envMap = getTexture( data.envMap );

					}

					if ( data.normalMap !== undefined ) {

						material.normalMap = getTexture( data.normalMap );
						if ( data.normalScale ) {
							material.normalScale = new THREE.Vector2( data.normalScale, data.normalScale );
						}

					}

					if ( data.lightMap !== undefined ) {

						material.lightMap = getTexture( data.lightMap );

					}

					if ( data.specularMap !== undefined ) {

						material.specularMap = getTexture( data.specularMap );

					}

					materials[ data.uuid ] = material;

				}

			}

			return materials;

		},

		parseImages: function ( json, onLoad ) {

			var scope = this;
			var images = {};

			if ( json !== undefined && json.length > 0 ) {

				var manager = new THREE.LoadingManager( onLoad );

				var loader = new THREE.ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );

				var loadImage = function ( url ) {

					scope.manager.itemStart( url );

					return loader.load( url, function () {

						scope.manager.itemEnd( url );

					} );

				};

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var image = json[ i ];
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

					images[ image.uuid ] = loadImage( path );

				}

			}

			return images;

		},

		parseTextures: function ( json, images ) {

			var textures = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.image === undefined ) {

						THREE.warn( 'THREE.ObjectLoader: No "image" speficied for', data.uuid );

					}

					if ( images[ data.image ] === undefined ) {

						THREE.warn( 'THREE.ObjectLoader: Undefined image', data.image );

					}

					var texture = new THREE.Texture( images[ data.image ] );
					texture.needsUpdate = true;

					texture.uuid = data.uuid;

					if ( data.name !== undefined ) texture.name = data.name;
					if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
					if ( data.minFilter !== undefined ) texture.minFilter = THREE[ data.minFilter ];
					if ( data.magFilter !== undefined ) texture.magFilter = THREE[ data.magFilter ];
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
					if ( data.wrap instanceof Array ) {

						texture.wrapS = THREE[ data.wrap[ 0 ] ];
						texture.wrapT = THREE[ data.wrap[ 1 ] ];

					}

					textures[ data.uuid ] = texture;

				}

			}

			return textures;

		},

		parseObject: function () {

			var matrix = new THREE.Matrix4();

			return function ( data, geometries, materials ) {

				var object;

				var getGeometry = function ( name ) {

					if ( geometries[ name ] === undefined ) {

						THREE.warn( 'THREE.ObjectLoader: Undefined geometry', name );

					}

					return geometries[ name ];

				};

				var getMaterial = function ( name ) {

					if ( materials[ name ] === undefined ) {

						THREE.warn( 'THREE.ObjectLoader: Undefined material', name );

					}

					return materials[ name ];

				};

				switch ( data.type ) {

					case 'Scene':

						object = new THREE.Scene();

						break;

					case 'PerspectiveCamera':

						object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

						break;

					case 'OrthographicCamera':

						object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

						break;

					case 'AmbientLight':

						object = new THREE.AmbientLight( data.color );

						break;

					case 'DirectionalLight':

						object = new THREE.DirectionalLight( data.color, data.intensity );

						break;

					case 'PointLight':

						object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

						break;

					case 'SpotLight':

						object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

						break;

					case 'HemisphereLight':

						object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

						break;

					case 'Mesh':

						object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'Line':

						object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

						break;

					case 'PointCloud':

						object = new THREE.PointCloud( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'Sprite':

						object = new THREE.Sprite( getMaterial( data.material ) );

						break;

					case 'Group':

						object = new THREE.Group();

						break;

					default:

						object = new THREE.Object3D();

				}

				object.uuid = data.uuid;

				if ( data.name !== undefined ) object.name = data.name;
				if ( data.matrix !== undefined ) {

					matrix.fromArray( data.matrix );
					matrix.decompose( object.position, object.quaternion, object.scale );

				} else {

					if ( data.position !== undefined ) object.position.fromArray( data.position );
					if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
					if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

				}

				if ( data.visible !== undefined ) object.visible = data.visible;
				if ( data.userData !== undefined ) object.userData = data.userData;

				if ( data.children !== undefined ) {

					for ( var child in data.children ) {

						object.add( this.parseObject( data.children[ child ], geometries, materials ) );

					}

				}

				return object;

			}

		}()

	};

	// File:src/loaders/TextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.TextureLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.TextureLoader.prototype = {

		constructor: THREE.TextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.ImageLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( image ) {

				var texture = new THREE.Texture( image );
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/BinaryTextureLoader.js

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */

	THREE.DataTextureLoader = THREE.BinaryTextureLoader = function () {

		// override in sub classes
		this._parser = null;

	};

	THREE.BinaryTextureLoader.prototype = {

		constructor: THREE.BinaryTextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texture = new THREE.DataTexture( );

			var loader = new THREE.XHRLoader();
			loader.setResponseType( 'arraybuffer' );

			loader.load( url, function ( buffer ) {

				var texData = scope._parser( buffer );

				if ( !texData ) return;

				if ( undefined !== texData.image ) {

					texture.image = texData.image;

				} else if ( undefined !== texData.data ) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

				if ( undefined !== texData.format ) {

					texture.format = texData.format;

				}
				if ( undefined !== texData.type ) {

					texture.type = texData.type;

				}

				if ( undefined !== texData.mipmaps ) {

					texture.mipmaps = texData.mipmaps;

				}

				if ( 1 === texData.mipmapCount ) {

					texture.minFilter = THREE.LinearFilter;

				}

				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture, texData );

			}, onProgress, onError );


			return texture;

		}

	};

	// File:src/loaders/CompressedTextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */

	THREE.CompressedTextureLoader = function () {

		// override in sub classes
		this._parser = null;

	};


	THREE.CompressedTextureLoader.prototype = {

		constructor: THREE.CompressedTextureLoader,

		load: function ( url, onLoad, onError ) {

			var scope = this;

			var images = [];

			var texture = new THREE.CompressedTexture();
			texture.image = images;

			var loader = new THREE.XHRLoader();
			loader.setResponseType( 'arraybuffer' );

			if ( url instanceof Array ) {

				var loaded = 0;

				var loadTexture = function ( i ) {

					loader.load( url[ i ], function ( buffer ) {

						var texDatas = scope._parser( buffer, true );

						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};

						loaded += 1;

						if ( loaded === 6 ) {

							if (texDatas.mipmapCount == 1)
	 							texture.minFilter = THREE.LinearFilter;

							texture.format = texDatas.format;
							texture.needsUpdate = true;

							if ( onLoad ) onLoad( texture );

						}

					} );

				};

				for ( var i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					if ( texDatas.isCubemap ) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( var f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps : [] };

							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = THREE.LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				} );

			}

			return texture;

		}

	};

	// File:src/materials/Material.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Material = function () {

		Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.side = THREE.FrontSide;

		this.opacity = 1;
		this.transparent = false;

		this.blending = THREE.NormalBlending;

		this.blendSrc = THREE.SrcAlphaFactor;
		this.blendDst = THREE.OneMinusSrcAlphaFactor;
		this.blendEquation = THREE.AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthTest = true;
		this.depthWrite = true;

		this.colorWrite = true;

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.alphaTest = 0;

		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

		this.visible = true;

		this._needsUpdate = true;

	};

	THREE.Material.prototype = {

		constructor: THREE.Material,

		get needsUpdate () {

			return this._needsUpdate;

		},

		set needsUpdate ( value ) {

			if ( value === true ) this.update();

			this._needsUpdate = value;

		},

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( var key in values ) {

				var newValue = values[ key ];

				if ( newValue === undefined ) {

					THREE.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;

				}

				if ( key in this ) {

					var currentValue = this[ key ];

					if ( currentValue instanceof THREE.Color ) {

						currentValue.set( newValue );

					} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

						currentValue.copy( newValue );

					} else if ( key == 'overdraw' ) {

						// ensure overdraw is backwards-compatable with legacy boolean type
						this[ key ] = Number( newValue );

					} else {

						this[ key ] = newValue;

					}

				}

			}

		},

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type
			};

			if ( this.name !== "" ) output.name = this.name;

			if ( this instanceof THREE.MeshBasicMaterial ) {

				output.color = this.color.getHex();
				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.MeshLambertMaterial ) {

				output.color = this.color.getHex();
				output.emissive = this.emissive.getHex();
				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.shading !== THREE.SmoothShading ) output.shading = this.shading;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.MeshPhongMaterial ) {

				output.color = this.color.getHex();
				output.emissive = this.emissive.getHex();
				output.specular = this.specular.getHex();
				output.shininess = this.shininess;
				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.shading !== THREE.SmoothShading ) output.shading = this.shading;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.MeshNormalMaterial ) {

				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.MeshDepthMaterial ) {

				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.PointCloudMaterial ) {

				output.size  = this.size;
				output.sizeAttenuation = this.sizeAttenuation;
				output.color = this.color.getHex();

				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;

			} else if ( this instanceof THREE.ShaderMaterial ) {

				output.uniforms = this.uniforms;
				output.vertexShader = this.vertexShader;
				output.fragmentShader = this.fragmentShader;

			} else if ( this instanceof THREE.SpriteMaterial ) {

				output.color = this.color.getHex();

			}

			if ( this.opacity < 1 ) output.opacity = this.opacity;
			if ( this.transparent !== false ) output.transparent = this.transparent;
			if ( this.wireframe !== false ) output.wireframe = this.wireframe;

			return output;

		},

		clone: function ( material ) {

			if ( material === undefined ) material = new THREE.Material();

			material.name = this.name;

			material.side = this.side;

			material.opacity = this.opacity;
			material.transparent = this.transparent;

			material.blending = this.blending;

			material.blendSrc = this.blendSrc;
			material.blendDst = this.blendDst;
			material.blendEquation = this.blendEquation;
			material.blendSrcAlpha = this.blendSrcAlpha;
			material.blendDstAlpha = this.blendDstAlpha;
			material.blendEquationAlpha = this.blendEquationAlpha;

			material.depthTest = this.depthTest;
			material.depthWrite = this.depthWrite;

			material.polygonOffset = this.polygonOffset;
			material.polygonOffsetFactor = this.polygonOffsetFactor;
			material.polygonOffsetUnits = this.polygonOffsetUnits;

			material.alphaTest = this.alphaTest;

			material.overdraw = this.overdraw;

			material.visible = this.visible;

			return material;

		},

		update: function () {

			this.dispatchEvent( { type: 'update' } );

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

	THREE.MaterialIdCount = 0;

	// File:src/materials/LineBasicMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round",
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.LineBasicMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'LineBasicMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

	THREE.LineBasicMaterial.prototype.clone = function () {

		var material = new THREE.LineBasicMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );

		material.linewidth = this.linewidth;
		material.linecap = this.linecap;
		material.linejoin = this.linejoin;

		material.vertexColors = this.vertexColors;

		material.fog = this.fog;

		return material;

	};

	// File:src/materials/LineDashedMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>,
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.LineDashedMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'LineDashedMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.linewidth = 1;

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.vertexColors = false;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

	THREE.LineDashedMaterial.prototype.clone = function () {

		var material = new THREE.LineDashedMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );

		material.linewidth = this.linewidth;

		material.scale = this.scale;
		material.dashSize = this.dashSize;
		material.gapSize = this.gapSize;

		material.vertexColors = this.vertexColors;

		material.fog = this.fog;

		return material;

	};

	// File:src/materials/MeshBasicMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.MeshBasicMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshBasicMaterial';

		this.color = new THREE.Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;

		this.setValues( parameters );

	};

	THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

	THREE.MeshBasicMaterial.prototype.clone = function () {

		var material = new THREE.MeshBasicMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );

		material.map = this.map;

		material.lightMap = this.lightMap;

		material.specularMap = this.specularMap;

		material.alphaMap = this.alphaMap;

		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;

		material.fog = this.fog;

		material.shading = this.shading;

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;

		material.vertexColors = this.vertexColors;

		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;

		return material;

	};

	// File:src/materials/MeshLambertMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  emissive: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.MeshLambertMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshLambertMaterial';

		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.emissive = new THREE.Color( 0x000000 );

		this.wrapAround = false;
		this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

		this.map = null;

		this.lightMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	};

	THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

	THREE.MeshLambertMaterial.prototype.clone = function () {

		var material = new THREE.MeshLambertMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );
		material.emissive.copy( this.emissive );

		material.wrapAround = this.wrapAround;
		material.wrapRGB.copy( this.wrapRGB );

		material.map = this.map;

		material.lightMap = this.lightMap;

		material.specularMap = this.specularMap;

		material.alphaMap = this.alphaMap;

		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;

		material.fog = this.fog;

		material.shading = this.shading;

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;

		material.vertexColors = this.vertexColors;

		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;

		return material;

	};

	// File:src/materials/MeshPhongMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  emissive: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.MeshPhongMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshPhongMaterial';

		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.emissive = new THREE.Color( 0x000000 );
		this.specular = new THREE.Color( 0x111111 );
		this.shininess = 30;

		this.metal = false;

		this.wrapAround = false;
		this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

		this.map = null;

		this.lightMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	};

	THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

	THREE.MeshPhongMaterial.prototype.clone = function () {

		var material = new THREE.MeshPhongMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );
		material.emissive.copy( this.emissive );
		material.specular.copy( this.specular );
		material.shininess = this.shininess;

		material.metal = this.metal;

		material.wrapAround = this.wrapAround;
		material.wrapRGB.copy( this.wrapRGB );

		material.map = this.map;

		material.lightMap = this.lightMap;

		material.bumpMap = this.bumpMap;
		material.bumpScale = this.bumpScale;

		material.normalMap = this.normalMap;
		material.normalScale.copy( this.normalScale );

		material.specularMap = this.specularMap;

		material.alphaMap = this.alphaMap;

		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;

		material.fog = this.fog;

		material.shading = this.shading;

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;

		material.vertexColors = this.vertexColors;

		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;

		return material;

	};

	// File:src/materials/MeshDepthMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	THREE.MeshDepthMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshDepthMaterial';

		this.morphTargets = false;
		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.setValues( parameters );

	};

	THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

	THREE.MeshDepthMaterial.prototype.clone = function () {

		var material = new THREE.MeshDepthMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;

		return material;

	};

	// File:src/materials/MeshNormalMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  shading: THREE.FlatShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	THREE.MeshNormalMaterial = function ( parameters ) {

		THREE.Material.call( this, parameters );

		this.type = 'MeshNormalMaterial';

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.morphTargets = false;

		this.setValues( parameters );

	};

	THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

	THREE.MeshNormalMaterial.prototype.clone = function () {

		var material = new THREE.MeshNormalMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;

		return material;

	};

	// File:src/materials/MeshFaceMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.MeshFaceMaterial = function ( materials ) {

		this.uuid = THREE.Math.generateUUID();

		this.type = 'MeshFaceMaterial';
		
		this.materials = materials instanceof Array ? materials : [];

	};

	THREE.MeshFaceMaterial.prototype = {

		constructor: THREE.MeshFaceMaterial,

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type,
				materials: []
			};

			for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

				output.materials.push( this.materials[ i ].toJSON() );

			}

			return output;

		},

		clone: function () {

			var material = new THREE.MeshFaceMaterial();

			for ( var i = 0; i < this.materials.length; i ++ ) {

				material.materials.push( this.materials[ i ].clone() );

			}

			return material;

		}

	};

	// File:src/materials/PointCloudMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  vertexColors: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.PointCloudMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'PointCloudMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.map = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.vertexColors = THREE.NoColors;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;

	THREE.PointCloudMaterial.prototype.clone = function () {

		var material = new THREE.PointCloudMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );

		material.map = this.map;

		material.size = this.size;
		material.sizeAttenuation = this.sizeAttenuation;

		material.vertexColors = this.vertexColors;

		material.fog = this.fog;

		return material;

	};

	// backwards compatibility

	THREE.ParticleBasicMaterial = function ( parameters ) {

		THREE.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );
		return new THREE.PointCloudMaterial( parameters );

	};

	THREE.ParticleSystemMaterial = function ( parameters ) {

		THREE.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );
		return new THREE.PointCloudMaterial( parameters );

	};

	// File:src/materials/ShaderMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.ShaderMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};
		this.attributes = null;

		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

		this.shading = THREE.SmoothShading;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog

		this.lights = false; // set to use scene lights

		this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

		this.skinning = false; // set to use skinning attribute streams

		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;

		this.setValues( parameters );

	};

	THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

	THREE.ShaderMaterial.prototype.clone = function () {

		var material = new THREE.ShaderMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.fragmentShader = this.fragmentShader;
		material.vertexShader = this.vertexShader;

		material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

		material.attributes = this.attributes;
		material.defines = this.defines;

		material.shading = this.shading;

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;

		material.fog = this.fog;

		material.lights = this.lights;

		material.vertexColors = this.vertexColors;

		material.skinning = this.skinning;

		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;

		return material;

	};

	// File:src/materials/RawShaderMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.RawShaderMaterial = function ( parameters ) {

		THREE.ShaderMaterial.call( this, parameters );

		this.type = 'RawShaderMaterial';

	};

	THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
	THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;

	THREE.RawShaderMaterial.prototype.clone = function () {

		var material = new THREE.RawShaderMaterial();

		THREE.ShaderMaterial.prototype.clone.call( this, material );

		return material;

	};

	// File:src/materials/SpriteMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2(),
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.SpriteMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'SpriteMaterial';

		this.color = new THREE.Color( 0xffffff );
		this.map = null;

		this.rotation = 0;

		this.fog = false;

		// set parameters

		this.setValues( parameters );

	};

	THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

	THREE.SpriteMaterial.prototype.clone = function () {

		var material = new THREE.SpriteMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );
		material.map = this.map;

		material.rotation = this.rotation;

		material.fog = this.fog;

		return material;

	};

	// File:src/textures/Texture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.sourceFile = '';

		this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : THREE.RGBAFormat;
		this.type = type !== undefined ? type : THREE.UnsignedByteType;

		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		this._needsUpdate = false;
		this.onUpdate = null;

	};

	THREE.Texture.DEFAULT_IMAGE = undefined;
	THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

	THREE.Texture.prototype = {

		constructor: THREE.Texture,

		get needsUpdate () {

			return this._needsUpdate;

		},

		set needsUpdate ( value ) {

			if ( value === true ) this.update();

			this._needsUpdate = value;

		},

		clone: function ( texture ) {

			if ( texture === undefined ) texture = new THREE.Texture();

			texture.image = this.image;
			texture.mipmaps = this.mipmaps.slice( 0 );

			texture.mapping = this.mapping;

			texture.wrapS = this.wrapS;
			texture.wrapT = this.wrapT;

			texture.magFilter = this.magFilter;
			texture.minFilter = this.minFilter;

			texture.anisotropy = this.anisotropy;

			texture.format = this.format;
			texture.type = this.type;

			texture.offset.copy( this.offset );
			texture.repeat.copy( this.repeat );

			texture.generateMipmaps = this.generateMipmaps;
			texture.premultiplyAlpha = this.premultiplyAlpha;
			texture.flipY = this.flipY;
			texture.unpackAlignment = this.unpackAlignment;

			return texture;

		},

		update: function () {

			this.dispatchEvent( { type: 'update' } );

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

	THREE.TextureIdCount = 0;

	// File:src/textures/CubeTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
		
		THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.images = images;

	};

	THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

	THREE.CubeTexture.clone = function ( texture ) {

		if ( texture === undefined ) texture = new THREE.CubeTexture();

		THREE.Texture.prototype.clone.call( this, texture );

		texture.images = this.images;

		return texture;

	};

	// File:src/textures/CompressedTexture.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	};

	THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

	THREE.CompressedTexture.prototype.clone = function () {

		var texture = new THREE.CompressedTexture();

		THREE.Texture.prototype.clone.call( this, texture );

		return texture;

	};

	// File:src/textures/DataTexture.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { data: data, width: width, height: height };

	};

	THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.DataTexture.prototype.constructor = THREE.DataTexture;

	THREE.DataTexture.prototype.clone = function () {

		var texture = new THREE.DataTexture();

		THREE.Texture.prototype.clone.call( this, texture );

		return texture;

	};

	// File:src/textures/VideoTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.generateMipmaps = false;

		var scope = this;

		var update = function () {

			requestAnimationFrame( update );

			if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

				scope.needsUpdate = true;

			}

		};

		update();

	};

	THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

	// File:src/objects/Group.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Group = function () {

		THREE.Object3D.call( this );

		this.type = 'Group';

	};

	THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Group.prototype.constructor = THREE.Group;

	// File:src/objects/PointCloud.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.PointCloud = function ( geometry, material ) {

		THREE.Object3D.call( this );

		this.type = 'PointCloud';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );

	};

	THREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );
	THREE.PointCloud.prototype.constructor = THREE.PointCloud;

	THREE.PointCloud.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();

		return function ( raycaster, intersects ) {

			var object = this;
			var geometry = object.geometry;
			var threshold = raycaster.params.PointCloud.threshold;

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

					return;

				}

			}

			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var position = new THREE.Vector3();

			var testPoint = function ( point, index ) {

				var rayPointDistance = ray.distanceToPoint( point );

				if ( rayPointDistance < localThreshold ) {

					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( object.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

					intersects.push( {

						distance: distance,
						distanceToRay: rayPointDistance,
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object

					} );

				}

			};

			if ( geometry instanceof THREE.BufferGeometry ) {

				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( attributes.index !== undefined ) {

					var indices = attributes.index.array;
					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						var offset = {
							start: 0,
							count: indices.length,
							index: 0
						};

						offsets = [ offset ];

					}

					for ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {

						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;

						for ( var i = start, il = start + count; i < il; i ++ ) {

							var a = index + indices[ i ];

							position.fromArray( positions, a * 3 );

							testPoint( position, a );

						}

					}

				} else {

					var pointCount = positions.length / 3;

					for ( var i = 0; i < pointCount; i ++ ) {

						position.set(
							positions[ 3 * i ],
							positions[ 3 * i + 1 ],
							positions[ 3 * i + 2 ]
						);

						testPoint( position, i );

					}

				}

			} else {

				var vertices = this.geometry.vertices;

				for ( var i = 0; i < vertices.length; i ++ ) {

					testPoint( vertices[ i ], i );

				}

			}

		};

	}() );

	THREE.PointCloud.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );

		THREE.Object3D.prototype.clone.call( this, object );

		return object;

	};

	// Backwards compatibility

	THREE.ParticleSystem = function ( geometry, material ) {

		THREE.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );
		return new THREE.PointCloud( geometry, material );

	};

	// File:src/objects/Line.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Line = function ( geometry, material, mode ) {

		THREE.Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

		this.mode = mode !== undefined ? mode : THREE.LineStrip;

	};

	THREE.LineStrip = 0;
	THREE.LinePieces = 1;

	THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Line.prototype.constructor = THREE.Line;

	THREE.Line.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		return function ( raycaster, intersects ) {

			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;

			var geometry = this.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			// Checking boundingSphere distance to ray

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( this.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return;

			}

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var vStart = new THREE.Vector3();
			var vEnd = new THREE.Vector3();
			var interSegment = new THREE.Vector3();
			var interRay = new THREE.Vector3();
			var step = this.mode === THREE.LineStrip ? 1 : 2;

			if ( geometry instanceof THREE.BufferGeometry ) {

				var attributes = geometry.attributes;

				if ( attributes.index !== undefined ) {

					var indices = attributes.index.array;
					var positions = attributes.position.array;
					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						offsets = [ { start: 0, count: indices.length, index: 0 } ];

					}

					for ( var oi = 0; oi < offsets.length; oi ++) {

						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;

						for ( var i = start; i < start + count - 1; i += step ) {

							var a = index + indices[ i ];
							var b = index + indices[ i + 1 ];

							vStart.fromArray( positions, a * 3 );
							vEnd.fromArray( positions, b * 3 );

							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > precisionSq ) continue;

							var distance = ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								offsetIndex: oi,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					}

				} else {

					var positions = attributes.position.array;

					for ( var i = 0; i < positions.length / 3 - 1; i += step ) {

						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						var distance = ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;

				for ( var i = 0; i < nbVertices - 1; i += step ) {

					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					var distance = ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		};

	}() );

	THREE.Line.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.mode );

		THREE.Object3D.prototype.clone.call( this, object );

		return object;

	};

	// File:src/objects/Mesh.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	THREE.Mesh = function ( geometry, material ) {

		THREE.Object3D.call( this );

		this.type = 'Mesh';
		
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

		this.updateMorphTargets();

	};

	THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Mesh.prototype.constructor = THREE.Mesh;

	THREE.Mesh.prototype.updateMorphTargets = function () {

		if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

			this.morphTargetBase = - 1;
			this.morphTargetForcedOrder = [];
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};

			for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

			}

		}

	};

	THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

		if ( this.morphTargetDictionary[ name ] !== undefined ) {

			return this.morphTargetDictionary[ name ];

		}

		THREE.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

		return 0;

	};


	THREE.Mesh.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		var vA = new THREE.Vector3();
		var vB = new THREE.Vector3();
		var vC = new THREE.Vector3();

		return function ( raycaster, intersects ) {

			var geometry = this.geometry;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( this.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return;

			}

			// Check boundingBox before continuing

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

					return;

				}

			}

			if ( geometry instanceof THREE.BufferGeometry ) {

				var material = this.material;

				if ( material === undefined ) return;

				var attributes = geometry.attributes;

				var a, b, c;
				var precision = raycaster.precision;

				if ( attributes.index !== undefined ) {

					var indices = attributes.index.array;
					var positions = attributes.position.array;
					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						offsets = [ { start: 0, count: indices.length, index: 0 } ];

					}

					for ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {

						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							a = index + indices[ i ];
							b = index + indices[ i + 1 ];
							c = index + indices[ i + 2 ];

							vA.fromArray( positions, a * 3 );
							vB.fromArray( positions, b * 3 );
							vC.fromArray( positions, c * 3 );

							if ( material.side === THREE.BackSide ) {

								var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

							} else {

								var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

							}

							if ( intersectionPoint === null ) continue;

							intersectionPoint.applyMatrix4( this.matrixWorld );

							var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

							if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								point: intersectionPoint,
								face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
								faceIndex: null,
								object: this

							} );

						}

					}

				} else {

					var positions = attributes.position.array;

					for ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {

						a = i;
						b = i + 1;
						c = i + 2;

						vA.fromArray( positions, j );
						vB.fromArray( positions, j + 3 );
						vC.fromArray( positions, j + 6 );

						if ( material.side === THREE.BackSide ) {

							var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

						} else {

							var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

						}

						if ( intersectionPoint === null ) continue;

						intersectionPoint.applyMatrix4( this.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

						if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							point: intersectionPoint,
							face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;
				var objectMaterials = isFaceMaterial === true ? this.material.materials : null;

				var a, b, c;
				var precision = raycaster.precision;

				var vertices = geometry.vertices;

				for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

					var face = geometry.faces[ f ];

					var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;

					if ( material === undefined ) continue;

					a = vertices[ face.a ];
					b = vertices[ face.b ];
					c = vertices[ face.c ];

					if ( material.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;

						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) continue;

							var targets = morphTargets[ t ].vertices;

							vA.x += ( targets[ face.a ].x - a.x ) * influence;
							vA.y += ( targets[ face.a ].y - a.y ) * influence;
							vA.z += ( targets[ face.a ].z - a.z ) * influence;

							vB.x += ( targets[ face.b ].x - b.x ) * influence;
							vB.y += ( targets[ face.b ].y - b.y ) * influence;
							vB.z += ( targets[ face.b ].z - b.z ) * influence;

							vC.x += ( targets[ face.c ].x - c.x ) * influence;
							vC.y += ( targets[ face.c ].y - c.y ) * influence;
							vC.z += ( targets[ face.c ].z - c.z ) * influence;

						}

						vA.add( a );
						vB.add( b );
						vC.add( c );

						a = vA;
						b = vB;
						c = vC;

					}

					if ( material.side === THREE.BackSide ) {

						var intersectionPoint = ray.intersectTriangle( c, b, a, true );

					} else {

						var intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );

					}

					if ( intersectionPoint === null ) continue;

					intersectionPoint.applyMatrix4( this.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

					if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						point: intersectionPoint,
						face: face,
						faceIndex: f,
						object: this

					} );

				}

			}

		};

	}() );

	THREE.Mesh.prototype.clone = function ( object, recursive ) {

		if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

		THREE.Object3D.prototype.clone.call( this, object, recursive );

		return object;

	};

	// File:src/objects/Bone.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.Bone = function ( skin ) {

		THREE.Object3D.call( this );

		this.type = 'Bone';

		this.skin = skin;

	};

	THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Bone.prototype.constructor = THREE.Bone;

	// File:src/objects/Skeleton.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

		this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

		this.identityMatrix = new THREE.Matrix4();

		// copy the bone array

		bones = bones || [];

		this.bones = bones.slice( 0 );

		// create a bone texture or an array of floats

		if ( this.useVertexTexture ) {

			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
			//       16x16 pixel texture max   64 bones (16 * 16 / 4)
			//       32x32 pixel texture max  256 bones (32 * 32 / 4)
			//       64x64 pixel texture max 1024 bones (64 * 64 / 4)

			var size;

			if ( this.bones.length > 256 )
				size = 64;
			else if ( this.bones.length > 64 )
				size = 32;
			else if ( this.bones.length > 16 )
				size = 16;
			else
				size = 8;

			this.boneTextureWidth = size;
			this.boneTextureHeight = size;

			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
			this.boneTexture.minFilter = THREE.NearestFilter;
			this.boneTexture.magFilter = THREE.NearestFilter;
			this.boneTexture.generateMipmaps = false;
			this.boneTexture.flipY = false;

		} else {

			this.boneMatrices = new Float32Array( 16 * this.bones.length );

		}

		// use the supplied bone inverses or calculate the inverses

		if ( boneInverses === undefined ) {

			this.calculateInverses();

		} else {

			if ( this.bones.length === boneInverses.length ) {

				this.boneInverses = boneInverses.slice( 0 );

			} else {

				THREE.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

				this.boneInverses = [];

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					this.boneInverses.push( new THREE.Matrix4() );

				}

			}

		}

	};

	THREE.Skeleton.prototype.calculateInverses = function () {

		this.boneInverses = [];

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			var inverse = new THREE.Matrix4();

			if ( this.bones[ b ] ) {

				inverse.getInverse( this.bones[ b ].matrixWorld );

			}

			this.boneInverses.push( inverse );

		}

	};

	THREE.Skeleton.prototype.pose = function () {

		var bone;

		// recover the bind-time world matrices

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				bone.matrixWorld.getInverse( this.boneInverses[ b ] );

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				if ( bone.parent ) {

					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	};

	THREE.Skeleton.prototype.update = ( function () {

		var offsetMatrix = new THREE.Matrix4();
		
		return function () {

			// flatten bone matrices to array

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				// compute the offset between the current and the original transform

				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
				offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

			}

			if ( this.useVertexTexture ) {

				this.boneTexture.needsUpdate = true;

			}
			
		};

	} )();


	// File:src/objects/SkinnedMesh.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

		THREE.Mesh.call( this, geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = "attached";
		this.bindMatrix = new THREE.Matrix4();
		this.bindMatrixInverse = new THREE.Matrix4();

		// init bones

		// TODO: remove bone creation as there is no reason (other than
		// convenience) for THREE.SkinnedMesh to do this.

		var bones = [];

		if ( this.geometry && this.geometry.bones !== undefined ) {

			var bone, gbone, p, q, s;

			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

				gbone = this.geometry.bones[ b ];

				p = gbone.pos;
				q = gbone.rotq;
				s = gbone.scl;

				bone = new THREE.Bone( this );
				bones.push( bone );

				bone.name = gbone.name;
				bone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );
				bone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );

				if ( s !== undefined ) {

					bone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );

				} else {

					bone.scale.set( 1, 1, 1 );

				}

			}

			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

				gbone = this.geometry.bones[ b ];

				if ( gbone.parent !== - 1 ) {

					bones[ gbone.parent ].add( bones[ b ] );

				} else {

					this.add( bones[ b ] );

				}

			}

		}

		this.normalizeSkinWeights();

		this.updateMatrixWorld( true );
		this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );

	};


	THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

	THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );

	};

	THREE.SkinnedMesh.prototype.pose = function () {

		this.skeleton.pose();

	};

	THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

		if ( this.geometry instanceof THREE.Geometry ) {

			for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

				var sw = this.geometry.skinWeights[ i ];

				var scale = 1.0 / sw.lengthManhattan();

				if ( scale !== Infinity ) {

					sw.multiplyScalar( scale );

				} else {

					sw.set( 1 ); // this will be normalized by the shader anyway

				}

			}

		} else {

			// skinning weights assumed to be normalized for THREE.BufferGeometry

		}

	};

	THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

		THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

		if ( this.bindMode === "attached" ) {

			this.bindMatrixInverse.getInverse( this.matrixWorld );

		} else if ( this.bindMode === "detached" ) {

			this.bindMatrixInverse.getInverse( this.bindMatrix );

		} else {

			THREE.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );

		}

	};

	THREE.SkinnedMesh.prototype.clone = function( object ) {

		if ( object === undefined ) {

			object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );

		}

		THREE.Mesh.prototype.clone.call( this, object );

		return object;

	};


	// File:src/objects/MorphAnimMesh.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.MorphAnimMesh = function ( geometry, material ) {

		THREE.Mesh.call( this, geometry, material );

		this.type = 'MorphAnimMesh';

		// API

		this.duration = 1000; // milliseconds
		this.mirroredLoop = false;
		this.time = 0;

		// internals

		this.lastKeyframe = 0;
		this.currentKeyframe = 0;

		this.direction = 1;
		this.directionBackwards = false;

		this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

	};

	THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;

	THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

		this.startKeyframe = start;
		this.endKeyframe = end;

		this.length = this.endKeyframe - this.startKeyframe + 1;

	};

	THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

		this.direction = 1;
		this.directionBackwards = false;

	};

	THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

		this.direction = - 1;
		this.directionBackwards = true;

	};

	THREE.MorphAnimMesh.prototype.parseAnimations = function () {

		var geometry = this.geometry;

		if ( ! geometry.animations ) geometry.animations = {};

		var firstAnimation, animations = geometry.animations;

		var pattern = /([a-z]+)_?(\d+)/;

		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

			var morph = geometry.morphTargets[ i ];
			var parts = morph.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				var label = parts[ 1 ];

				if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };

				var animation = animations[ label ];

				if ( i < animation.start ) animation.start = i;
				if ( i > animation.end ) animation.end = i;

				if ( ! firstAnimation ) firstAnimation = label;

			}

		}

		geometry.firstAnimation = firstAnimation;

	};

	THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

		if ( ! this.geometry.animations ) this.geometry.animations = {};

		this.geometry.animations[ label ] = { start: start, end: end };

	};

	THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

		var animation = this.geometry.animations[ label ];

		if ( animation ) {

			this.setFrameRange( animation.start, animation.end );
			this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
			this.time = 0;

		} else {

			THREE.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );

		}

	};

	THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

		var frameTime = this.duration / this.length;

		this.time += this.direction * delta;

		if ( this.mirroredLoop ) {

			if ( this.time > this.duration || this.time < 0 ) {

				this.direction *= - 1;

				if ( this.time > this.duration ) {

					this.time = this.duration;
					this.directionBackwards = true;

				}

				if ( this.time < 0 ) {

					this.time = 0;
					this.directionBackwards = false;

				}

			}

		} else {

			this.time = this.time % this.duration;

			if ( this.time < 0 ) this.time += this.duration;

		}

		var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

		if ( keyframe !== this.currentKeyframe ) {

			this.morphTargetInfluences[ this.lastKeyframe ] = 0;
			this.morphTargetInfluences[ this.currentKeyframe ] = 1;

			this.morphTargetInfluences[ keyframe ] = 0;

			this.lastKeyframe = this.currentKeyframe;
			this.currentKeyframe = keyframe;

		}

		var mix = ( this.time % frameTime ) / frameTime;

		if ( this.directionBackwards ) {

			mix = 1 - mix;

		}

		this.morphTargetInfluences[ this.currentKeyframe ] = mix;
		this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

	};

	THREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {

		var influences = this.morphTargetInfluences;

		for ( var i = 0, l = influences.length; i < l; i ++ ) {

			influences[ i ] = 0;

		}

		if ( a > -1 ) influences[ a ] = 1 - t;
		if ( b > -1 ) influences[ b ] = t;

	};

	THREE.MorphAnimMesh.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

		object.duration = this.duration;
		object.mirroredLoop = this.mirroredLoop;
		object.time = this.time;

		object.lastKeyframe = this.lastKeyframe;
		object.currentKeyframe = this.currentKeyframe;

		object.direction = this.direction;
		object.directionBackwards = this.directionBackwards;

		THREE.Mesh.prototype.clone.call( this, object );

		return object;

	};

	// File:src/objects/LOD.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LOD = function () {

		THREE.Object3D.call( this );

		this.objects = [];

	};


	THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LOD.prototype.constructor = THREE.LOD;

	THREE.LOD.prototype.addLevel = function ( object, distance ) {

		if ( distance === undefined ) distance = 0;

		distance = Math.abs( distance );

		for ( var l = 0; l < this.objects.length; l ++ ) {

			if ( distance < this.objects[ l ].distance ) {

				break;

			}

		}

		this.objects.splice( l, 0, { distance: distance, object: object } );
		this.add( object );

	};

	THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

		for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

			if ( distance < this.objects[ i ].distance ) {

				break;

			}

		}

		return this.objects[ i - 1 ].object;

	};

	THREE.LOD.prototype.raycast = ( function () {

		var matrixPosition = new THREE.Vector3();

		return function ( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		};

	}() );

	THREE.LOD.prototype.update = function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( camera ) {

			if ( this.objects.length > 1 ) {

				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );

				var distance = v1.distanceTo( v2 );

				this.objects[ 0 ].object.visible = true;

				for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

					if ( distance >= this.objects[ i ].distance ) {

						this.objects[ i - 1 ].object.visible = false;
						this.objects[ i     ].object.visible = true;

					} else {

						break;

					}

				}

				for ( ; i < l; i ++ ) {

					this.objects[ i ].object.visible = false;

				}

			}

		};

	}();

	THREE.LOD.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.LOD();

		THREE.Object3D.prototype.clone.call( this, object );

		for ( var i = 0, l = this.objects.length; i < l; i ++ ) {
			var x = this.objects[ i ].object.clone();
			x.visible = i === 0;
			object.addLevel( x, this.objects[ i ].distance );
		}

		return object;

	};

	// File:src/objects/Sprite.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Sprite = ( function () {

		var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
		var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
		var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		return function ( material ) {

			THREE.Object3D.call( this );

			this.type = 'Sprite';

			this.geometry = geometry;
			this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

		};

	} )();

	THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Sprite.prototype.constructor = THREE.Sprite;

	THREE.Sprite.prototype.raycast = ( function () {

		var matrixPosition = new THREE.Vector3();

		return function ( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.distanceToPoint( matrixPosition );

			if ( distance > this.scale.x ) {

				return;

			}

			intersects.push( {

				distance: distance,
				point: this.position,
				face: null,
				object: this

			} );

		};

	}() );

	THREE.Sprite.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.Sprite( this.material );

		THREE.Object3D.prototype.clone.call( this, object );

		return object;

	};

	// Backwards compatibility

	THREE.Particle = THREE.Sprite;

	// File:src/objects/LensFlare.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.LensFlare = function ( texture, size, distance, blending, color ) {

		THREE.Object3D.call( this );

		this.lensFlares = [];

		this.positionScreen = new THREE.Vector3();
		this.customUpdateCallback = undefined;

		if ( texture !== undefined ) {

			this.add( texture, size, distance, blending, color );

		}

	};

	THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LensFlare.prototype.constructor = THREE.LensFlare;


	/*
	 * Add: adds another flare
	 */

	THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new THREE.Color( 0xffffff );
		if ( blending === undefined ) blending = THREE.NormalBlending;

		distance = Math.min( distance, Math.max( 0, distance ) );

		this.lensFlares.push( {
			texture: texture, 			// THREE.Texture
			size: size, 				// size in pixels (-1 = use texture.width)
			distance: distance, 		// distance (0-1) from light source (0=at light source)
			x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
			scale: 1, 					// scale
			rotation: 1, 				// rotation
			opacity: opacity,			// opacity
			color: color,				// color
			blending: blending			// blending
		} );

	};

	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */

	THREE.LensFlare.prototype.updateLensFlares = function () {

		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;

		for ( f = 0; f < fl; f ++ ) {

			flare = this.lensFlares[ f ];

			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;

			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

		}

	};


	// File:src/scenes/Scene.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Scene = function () {

		THREE.Object3D.call( this );

		this.type = 'Scene';

		this.fog = null;
		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

	};

	THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Scene.prototype.constructor = THREE.Scene;

	THREE.Scene.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.Scene();

		THREE.Object3D.prototype.clone.call( this, object );

		if ( this.fog !== null ) object.fog = this.fog.clone();
		if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

		object.autoUpdate = this.autoUpdate;
		object.matrixAutoUpdate = this.matrixAutoUpdate;

		return object;

	};

	// File:src/scenes/Fog.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Fog = function ( color, near, far ) {

		this.name = '';

		this.color = new THREE.Color( color );

		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;

	};

	THREE.Fog.prototype.clone = function () {

		return new THREE.Fog( this.color.getHex(), this.near, this.far );

	};

	// File:src/scenes/FogExp2.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.FogExp2 = function ( color, density ) {

		this.name = '';

		this.color = new THREE.Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;

	};

	THREE.FogExp2.prototype.clone = function () {

		return new THREE.FogExp2( this.color.getHex(), this.density );

	};

	// File:src/renderers/shaders/ShaderChunk.js

	THREE.ShaderChunk = {};

	// File:src/renderers/shaders/ShaderChunk/common.glsl

	THREE.ShaderChunk[ 'common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n	float distance = dot( planeNormal, point-pointOnPlane );\n	return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n	if ( decayExponent > 0.0 ) {\n	  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n	}\n	return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n	return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n	return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n	return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n	return a;\n#endif\n}\n";

	// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

	THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

	THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack += ambientLightColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

	THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl

	THREE.ShaderChunk[ 'default_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n	vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

	// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

	THREE.ShaderChunk[ 'map_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

	THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

	THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'lightmap_pars_vertex'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

	THREE.ShaderChunk[ 'lights_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		totalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		totalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			totalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\n\n			// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			totalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n		// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		totalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		totalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalDiffuseLight += hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		totalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\n#ifdef METAL\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\n\n#else\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

	THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

	THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

	THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n	// Per-Pixel Tangent Space Normal Mapping\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

	THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

	THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

	THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

	THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lightmap_vertex.glsl

	THREE.ShaderChunk[ 'lightmap_vertex'] = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

	THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

	THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

	THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = inputToLinear( color.xyz );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

	THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

	THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";

	// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

	THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

	THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_pars_vertex.glsl

	THREE.ShaderChunk[ 'map_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

	THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// Transforming Normal Vectors with the Inverse Transformation\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

	THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

	THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

	THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

	THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n		fogFactor = whiteCompliment( fogFactor );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

	THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef USE_SKINNING\n\n	vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n	vec3 objectNormal = morphedNormal;\n\n#else\n\n	vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

	THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

	THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_vertex.glsl

	THREE.ShaderChunk[ 'map_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

	THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	outgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

	THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

	THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

	THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

	THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n	shadowColor = inputToLinear( shadowColor );\n\n	outgoingLight = outgoingLight * shadowColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

	THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#elif defined( USE_MORPHTARGETS )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

	THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

	THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

	THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

	THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

	// File:src/renderers/shaders/UniformsUtils.js

	/**
	 * Uniform Utilities
	 */

	THREE.UniformsUtils = {

		merge: function ( uniforms ) {

			var merged = {};

			for ( var u = 0; u < uniforms.length; u ++ ) {

				var tmp = this.clone( uniforms[ u ] );

				for ( var p in tmp ) {

					merged[ p ] = tmp[ p ];

				}

			}

			return merged;

		},

		clone: function ( uniforms_src ) {

			var uniforms_dst = {};

			for ( var u in uniforms_src ) {

				uniforms_dst[ u ] = {};

				for ( var p in uniforms_src[ u ] ) {

					var parameter_src = uniforms_src[ u ][ p ];

					if ( parameter_src instanceof THREE.Color ||
						 parameter_src instanceof THREE.Vector2 ||
						 parameter_src instanceof THREE.Vector3 ||
						 parameter_src instanceof THREE.Vector4 ||
						 parameter_src instanceof THREE.Matrix4 ||
						 parameter_src instanceof THREE.Texture ) {

						uniforms_dst[ u ][ p ] = parameter_src.clone();

					} else if ( parameter_src instanceof Array ) {

						uniforms_dst[ u ][ p ] = parameter_src.slice();

					} else {

						uniforms_dst[ u ][ p ] = parameter_src;

					}

				}

			}

			return uniforms_dst;

		}

	};

	// File:src/renderers/shaders/UniformsLib.js

	/**
	 * Uniforms library for shared webgl shaders
	 */

	THREE.UniformsLib = {

		common: {

			"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },

			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

			"lightMap" : { type: "t", value: null },
			"specularMap" : { type: "t", value: null },
			"alphaMap" : { type: "t", value: null },

			"envMap" : { type: "t", value: null },
			"flipEnvMap" : { type: "f", value: - 1 },
			"reflectivity" : { type: "f", value: 1.0 },
			"refractionRatio" : { type: "f", value: 0.98 },

			"morphTargetInfluences" : { type: "f", value: 0 }

		},

		bump: {

			"bumpMap" : { type: "t", value: null },
			"bumpScale" : { type: "f", value: 1 }

		},

		normalmap: {

			"normalMap" : { type: "t", value: null },
			"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
		},

		fog : {

			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

		},

		lights: {

			"ambientLightColor" : { type: "fv", value: [] },

			"directionalLightDirection" : { type: "fv", value: [] },
			"directionalLightColor" : { type: "fv", value: [] },

			"hemisphereLightDirection" : { type: "fv", value: [] },
			"hemisphereLightSkyColor" : { type: "fv", value: [] },
			"hemisphereLightGroundColor" : { type: "fv", value: [] },

			"pointLightColor" : { type: "fv", value: [] },
			"pointLightPosition" : { type: "fv", value: [] },
			"pointLightDistance" : { type: "fv1", value: [] },
			"pointLightDecay" : { type: "fv1", value: [] },

			"spotLightColor" : { type: "fv", value: [] },
			"spotLightPosition" : { type: "fv", value: [] },
			"spotLightDirection" : { type: "fv", value: [] },
			"spotLightDistance" : { type: "fv1", value: [] },
			"spotLightAngleCos" : { type: "fv1", value: [] },
			"spotLightExponent" : { type: "fv1", value: [] },
			"spotLightDecay" : { type: "fv1", value: [] }

		},

		particle: {

			"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },
			"size" : { type: "f", value: 1.0 },
			"scale" : { type: "f", value: 1.0 },
			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

		},

		shadowmap: {

			"shadowMap": { type: "tv", value: [] },
			"shadowMapSize": { type: "v2v", value: [] },

			"shadowBias" : { type: "fv1", value: [] },
			"shadowDarkness": { type: "fv1", value: [] },

			"shadowMatrix" : { type: "m4v", value: [] }

		}

	};

	// File:src/renderers/shaders/ShaderLib.js

	/**
	 * Webgl Shader Library for three.js
	 *
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */


	THREE.ShaderLib = {

		'basic': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "shadowmap" ]

			] ),

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],

				"	#ifdef USE_ENVMAP",

					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"	#endif",

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],

				"	outgoingLight = diffuseColor.rgb;", // simple shader

					THREE.ShaderChunk[ "lightmap_fragment" ],		// TODO: Light map on an otherwise unlit surface doesn't make sense.
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],		// TODO: Shadows on an otherwise unlit surface doesn't make sense.

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

				"}"

			].join("\n")

		},

		'lambert': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],

				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
				}

			] ),

			vertexShader: [

				"#define LAMBERT",

				"varying vec3 vLightFront;",

				"#ifdef DOUBLE_SIDED",

				"	varying vec3 vLightBack;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],

					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_lambert_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform float opacity;",

				"varying vec3 vLightFront;",

				"#ifdef DOUBLE_SIDED",

				"	varying vec3 vLightBack;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],

				"	#ifdef DOUBLE_SIDED",

						//"float isFront = float( gl_FrontFacing );",
						//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

				"		if ( gl_FrontFacing )",
				"			outgoingLight += diffuseColor.rgb * vLightFront + emissive;",
				"		else",
				"			outgoingLight += diffuseColor.rgb * vLightBack + emissive;",

				"	#else",

				"		outgoingLight += diffuseColor.rgb * vLightFront + emissive;",

				"	#endif",

					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

				"}"

			].join("\n")

		},

		'phong': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "bump" ],
				THREE.UniformsLib[ "normalmap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],

				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
					"shininess": { type: "f", value: 30 },
					"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
				}

			] ),

			vertexShader: [

				"#define PHONG",

				"varying vec3 vViewPosition;",

				"#ifndef FLAT_SHADED",

				"	varying vec3 vNormal;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],

					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

				"	vNormal = normalize( transformedNormal );",

				"#endif",

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"	vViewPosition = -mvPosition.xyz;",

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_phong_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"#define PHONG",

				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform vec3 specular;",
				"uniform float shininess;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
				THREE.ShaderChunk[ "normalmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],

					THREE.ShaderChunk[ "lights_phong_fragment" ],

					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

				"}"

			].join("\n")

		},

		'particle_basic': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "particle" ],
				THREE.UniformsLib[ "shadowmap" ]

			] ),

			vertexShader: [

				"uniform float size;",
				"uniform float scale;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "color_vertex" ],

				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				"	#ifdef USE_SIZEATTENUATION",
				"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
				"	#else",
				"		gl_PointSize = size;",
				"	#endif",

				"	gl_Position = projectionMatrix * mvPosition;",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform vec3 psColor;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_particle_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( psColor, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_particle_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],

				"	outgoingLight = diffuseColor.rgb;", // simple shader

					THREE.ShaderChunk[ "shadowmap_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

				"}"

			].join("\n")

		},

		'dashed': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],

				{
					"scale"    : { type: "f", value: 1 },
					"dashSize" : { type: "f", value: 1 },
					"totalSize": { type: "f", value: 2 }
				}

			] ),

			vertexShader: [

				"uniform float scale;",
				"attribute float lineDistance;",

				"varying float vLineDistance;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "color_vertex" ],

				"	vLineDistance = scale * lineDistance;",

				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"	gl_Position = projectionMatrix * mvPosition;",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform float opacity;",

				"uniform float dashSize;",
				"uniform float totalSize;",

				"varying float vLineDistance;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

				"		discard;",

				"	}",

				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],

				"	outgoingLight = diffuseColor.rgb;", // simple shader

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

				"}"

			].join("\n")

		},

		'depth': {

			uniforms: {

				"mNear": { type: "f", value: 1.0 },
				"mFar" : { type: "f", value: 2000.0 },
				"opacity" : { type: "f", value: 1.0 }

			},

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform float mNear;",
				"uniform float mFar;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"	#ifdef USE_LOGDEPTHBUF_EXT",

				"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

				"	#else",

				"		float depth = gl_FragCoord.z / gl_FragCoord.w;",

				"	#endif",

				"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"	gl_FragColor = vec4( vec3( color ), opacity );",   // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

				"}"

			].join("\n")

		},

		'normal': {

			uniforms: {

				"opacity" : { type: "f", value: 1.0 }

			},

			vertexShader: [

				"varying vec3 vNormal;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vNormal = normalize( normalMatrix * normal );",

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform float opacity;",
				"varying vec3 vNormal;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join("\n")

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		'cube': {

			uniforms: { "tCube": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },

			vertexShader: [

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vWorldPosition = transformDirection( position, modelMatrix );",

				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform samplerCube tCube;",
				"uniform float tFlip;",

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join("\n")

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		'equirect': {

			uniforms: { "tEquirect": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },

			vertexShader: [

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vWorldPosition = transformDirection( position, modelMatrix );",

				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform sampler2D tEquirect;",
				"uniform float tFlip;",

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

					// "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
					"vec3 direction = normalize( vWorldPosition );",
					"vec2 sampleUV;",
					"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
					"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
					"gl_FragColor = texture2D( tEquirect, sampleUV );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join("\n")

		},

		/* Depth encoding into RGBA texture
		 *
		 * based on SpiderGL shadow map example
		 * http://spidergl.org/example.php?id=6
		 *
		 * originally from
		 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
		 *
		 * see also
		 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
		 */

		'depthRGBA': {

			uniforms: {},

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"vec4 pack_depth( const in float depth ) {",

				"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
				"	res -= res.xxyz * bit_mask;",
				"	return res;",

				"}",

				"void main() {",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"	#ifdef USE_LOGDEPTHBUF_EXT",

				"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

				"	#else",

				"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

				"	#endif",

					//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
					//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
					//"gl_FragData[ 0 ] = pack_depth( z );",
					//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

				"}"

			].join("\n")

		}

	};

	// File:src/renderers/WebGLRenderer.js

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	THREE.WebGLRenderer = function ( parameters ) {

		console.log( 'THREE.WebGLRenderer', THREE.REVISION );

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,

		pixelRatio = 1,

		_precision = parameters.precision !== undefined ? parameters.precision : 'highp',

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,

		_clearColor = new THREE.Color( 0x000000 ),
		_clearAlpha = 0;

		var lights = [];

		var _webglObjects = {};
		var _webglObjectsImmediate = [];

		var opaqueObjects = [];
		var transparentObjects = [];

		var sprites = [];
		var lensFlares = [];

		// public properties

		this.domElement = _canvas;
		this.context = null;

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;

		// shadow map

		this.shadowMapEnabled = false;
		this.shadowMapType = THREE.PCFShadowMap;
		this.shadowMapCullFace = THREE.CullFaceFront;
		this.shadowMapDebug = false;
		this.shadowMapCascade = false;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// flags

		this.autoScaleCubemaps = true;

		// info

		this.info = {

			memory: {

				programs: 0,
				geometries: 0,
				textures: 0

			},

			render: {

				calls: 0,
				vertices: 0,
				faces: 0,
				points: 0

			}

		};

		// internal properties

		var _this = this,

		_programs = [],

		// internal state cache

		_currentProgram = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryProgram = '',
		_currentCamera = null,

		_usedTextureUnits = 0,

		_viewportX = 0,
		_viewportY = 0,
		_viewportWidth = _canvas.width,
		_viewportHeight = _canvas.height,
		_currentWidth = 0,
		_currentHeight = 0,

		// frustum

		_frustum = new THREE.Frustum(),

		 // camera matrices cache

		_projScreenMatrix = new THREE.Matrix4(),

		_vector3 = new THREE.Vector3(),

		// light arrays cache

		_direction = new THREE.Vector3(),

		_lightsNeedUpdate = true,

		_lights = {

			ambient: [ 0, 0, 0 ],
			directional: { length: 0, colors:[], positions: [] },
			point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
			spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
			hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

		};

		// initialize

		var _gl;

		try {

			var attributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};

			_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

			if ( _gl === null ) {

				if ( _canvas.getContext( 'webgl') !== null ) {

					throw 'Error creating WebGL context with your selected attributes.';

				} else {

					throw 'Error creating WebGL context.';

				}

			}

			_canvas.addEventListener( 'webglcontextlost', function ( event ) {

				event.preventDefault();

				resetGLState();
				setDefaultGLState();

				_webglObjects = {};

			}, false);

		} catch ( error ) {

			THREE.error( 'THREE.WebGLRenderer: ' + error );

		}

		var state = new THREE.WebGLState( _gl, paramThreeToGL );

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return {
					'rangeMin': 1,
					'rangeMax': 1,
					'precision': 1
				};

			}

		}

		var extensions = new THREE.WebGLExtensions( _gl );

		extensions.get( 'OES_texture_float' );
		extensions.get( 'OES_texture_float_linear' );
		extensions.get( 'OES_texture_half_float' );
		extensions.get( 'OES_texture_half_float_linear' );
		extensions.get( 'OES_standard_derivatives' );

		if ( _logarithmicDepthBuffer ) {

			extensions.get( 'EXT_frag_depth' );

		}

		//

		var glClearColor = function ( r, g, b, a ) {

			if ( _premultipliedAlpha === true ) {

				r *= a; g *= a; b *= a;

			}

			_gl.clearColor( r, g, b, a );

		};

		var setDefaultGLState = function () {

			_gl.clearColor( 0, 0, 0, 1 );
			_gl.clearDepth( 1 );
			_gl.clearStencil( 0 );

			_gl.enable( _gl.DEPTH_TEST );
			_gl.depthFunc( _gl.LEQUAL );

			_gl.frontFace( _gl.CCW );
			_gl.cullFace( _gl.BACK );
			_gl.enable( _gl.CULL_FACE );

			_gl.enable( _gl.BLEND );
			_gl.blendEquation( _gl.FUNC_ADD );
			_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		};

		var resetGLState = function () {

			_currentProgram = null;
			_currentCamera = null;

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;

			_lightsNeedUpdate = true;

			state.reset();

		};

		setDefaultGLState();

		this.context = _gl;
		this.state = state;

		// GPU capabilities

		var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
		var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
		var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		var _supportsVertexTextures = _maxVertexTextures > 0;
		var _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );

		//

		var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
		var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );

		var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
		var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );

		var getCompressedTextureFormats = ( function () {

			var array;

			return function () {

				if ( array !== undefined ) {

					return array;

				}

				array = [];

				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

					var formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );

					for ( var i = 0; i < formats.length; i ++ ) {

						array.push( formats[ i ] );

					}

				}

				return array;

			};

		} )();

		// clamp precision to maximum available

		var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
		var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

		if ( _precision === 'highp' && ! highpAvailable ) {

			if ( mediumpAvailable ) {

				_precision = 'mediump';
				THREE.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );

			} else {

				_precision = 'lowp';
				THREE.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );

			}

		}

		if ( _precision === 'mediump' && ! mediumpAvailable ) {

			_precision = 'lowp';
			THREE.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );

		}

		// Plugins

		var shadowMapPlugin = new THREE.ShadowMapPlugin( this, lights, _webglObjects, _webglObjectsImmediate );

		var spritePlugin = new THREE.SpritePlugin( this, sprites );
		var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

		// API

		this.getContext = function () {

			return _gl;

		};

		this.forceContextLoss = function () {

			extensions.get( 'WEBGL_lose_context' ).loseContext();

		};

		this.supportsVertexTextures = function () {

			return _supportsVertexTextures;

		};

		this.supportsFloatTextures = function () {

			return extensions.get( 'OES_texture_float' );

		};

		this.supportsHalfFloatTextures = function () {

			return extensions.get( 'OES_texture_half_float' );

		};

		this.supportsStandardDerivatives = function () {

			return extensions.get( 'OES_standard_derivatives' );

		};

		this.supportsCompressedTextureS3TC = function () {

			return extensions.get( 'WEBGL_compressed_texture_s3tc' );

		};

		this.supportsCompressedTexturePVRTC = function () {

			return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		};

		this.supportsBlendMinMax = function () {

			return extensions.get( 'EXT_blend_minmax' );

		};

		this.getMaxAnisotropy = ( function () {

			var value;

			return function () {

				if ( value !== undefined ) {

					return value;

				}

				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				value = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

				return value;

			}

		} )();

		this.getPrecision = function () {

			return _precision;

		};

		this.getPixelRatio = function () {

			return pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			pixelRatio = value;

		};

		this.setSize = function ( width, height, updateStyle ) {

			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.setViewport = function ( x, y, width, height ) {

			_viewportX = x * pixelRatio;
			_viewportY = y * pixelRatio;

			_viewportWidth = width * pixelRatio;
			_viewportHeight = height * pixelRatio;

			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		};

		this.setScissor = function ( x, y, width, height ) {

			_gl.scissor(
				x * pixelRatio,
				y * pixelRatio,
				width * pixelRatio,
				height * pixelRatio
			);

		};

		this.enableScissorTest = function ( enable ) {

			enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

		};

		// Clearing

		this.getClearColor = function () {

			return _clearColor;

		};

		this.setClearColor = function ( color, alpha ) {

			_clearColor.set( color );

			_clearAlpha = alpha !== undefined ? alpha : 1;

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		};

		this.getClearAlpha = function () {

			return _clearAlpha;

		};

		this.setClearAlpha = function ( alpha ) {

			_clearAlpha = alpha;

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		};

		this.clear = function ( color, depth, stencil ) {

			var bits = 0;

			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			_gl.clear( _gl.COLOR_BUFFER_BIT );

		};

		this.clearDepth = function () {

			_gl.clear( _gl.DEPTH_BUFFER_BIT );

		};

		this.clearStencil = function () {

			_gl.clear( _gl.STENCIL_BUFFER_BIT );

		};

		this.clearTarget = function ( renderTarget, color, depth, stencil ) {

			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );

		};

		// Reset

		this.resetGLState = resetGLState;

		// Buffer allocation

		function createParticleBuffers ( geometry ) {

			geometry.__webglVertexBuffer = _gl.createBuffer();
			geometry.__webglColorBuffer = _gl.createBuffer();

			_this.info.memory.geometries ++;

		};

		function createLineBuffers ( geometry ) {

			geometry.__webglVertexBuffer = _gl.createBuffer();
			geometry.__webglColorBuffer = _gl.createBuffer();
			geometry.__webglLineDistanceBuffer = _gl.createBuffer();

			_this.info.memory.geometries ++;

		};

		function createMeshBuffers ( geometryGroup ) {

			geometryGroup.__webglVertexBuffer = _gl.createBuffer();
			geometryGroup.__webglNormalBuffer = _gl.createBuffer();
			geometryGroup.__webglTangentBuffer = _gl.createBuffer();
			geometryGroup.__webglColorBuffer = _gl.createBuffer();
			geometryGroup.__webglUVBuffer = _gl.createBuffer();
			geometryGroup.__webglUV2Buffer = _gl.createBuffer();

			geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
			geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

			geometryGroup.__webglFaceBuffer = _gl.createBuffer();
			geometryGroup.__webglLineBuffer = _gl.createBuffer();

			var numMorphTargets = geometryGroup.numMorphTargets;

			if ( numMorphTargets ) {

				geometryGroup.__webglMorphTargetsBuffers = [];

				for ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {

					geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );

				}

			}

			var numMorphNormals = geometryGroup.numMorphNormals;

			if ( numMorphNormals ) {

				geometryGroup.__webglMorphNormalsBuffers = [];

				for ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {

					geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );

				}

			}

			_this.info.memory.geometries ++;

		};

		// Events

		var onObjectRemoved = function ( event ) {

			var object = event.target;

			object.traverse( function ( child ) {

				child.removeEventListener( 'remove', onObjectRemoved );

				removeObject( child );

			} );

		};

		var onGeometryDispose = function ( event ) {

			var geometry = event.target;

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			deallocateGeometry( geometry );

		};

		var onTextureDispose = function ( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			_this.info.memory.textures --;


		};

		var onRenderTargetDispose = function ( event ) {

			var renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			_this.info.memory.textures --;

		};

		var onMaterialDispose = function ( event ) {

			var material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		};

		// Buffer deallocation

		var deleteBuffers = function ( geometry ) {

			var buffers = [
				'__webglVertexBuffer',
				'__webglNormalBuffer',
				'__webglTangentBuffer',
				'__webglColorBuffer',
				'__webglUVBuffer',
				'__webglUV2Buffer',

				'__webglSkinIndicesBuffer',
				'__webglSkinWeightsBuffer',

				'__webglFaceBuffer',
				'__webglLineBuffer',

				'__webglLineDistanceBuffer'
			];

			for ( var i = 0, l = buffers.length; i < l; i ++ ) {

				var name = buffers[ i ];

				if ( geometry[ name ] !== undefined ) {

					_gl.deleteBuffer( geometry[ name ] );

					delete geometry[ name ];

				}

			}

			// custom attributes

			if ( geometry.__webglCustomAttributesList !== undefined ) {

				for ( var name in geometry.__webglCustomAttributesList ) {

					_gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );

				}

				delete geometry.__webglCustomAttributesList;

			}

			_this.info.memory.geometries --;

		};

		var deallocateGeometry = function ( geometry ) {

			delete geometry.__webglInit;

			if ( geometry instanceof THREE.BufferGeometry ) {

				for ( var name in geometry.attributes ) {

					var attribute = geometry.attributes[ name ];

					if ( attribute.buffer !== undefined ) {

						_gl.deleteBuffer( attribute.buffer );

						delete attribute.buffer;

					}

				}

				_this.info.memory.geometries --;

			} else {

				var geometryGroupsList = geometryGroups[ geometry.id ];

				if ( geometryGroupsList !== undefined ) {

					for ( var i = 0, l = geometryGroupsList.length; i < l; i ++ ) {

						var geometryGroup = geometryGroupsList[ i ];

						if ( geometryGroup.numMorphTargets !== undefined ) {

							for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

								_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

							}

							delete geometryGroup.__webglMorphTargetsBuffers;

						}

						if ( geometryGroup.numMorphNormals !== undefined ) {

							for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

								_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

							}

							delete geometryGroup.__webglMorphNormalsBuffers;

						}

						deleteBuffers( geometryGroup );

					}

					delete geometryGroups[ geometry.id ];

				} else {

					deleteBuffers( geometry );

				}

			}

			// TOFIX: Workaround for deleted geometry being currently bound

			_currentGeometryProgram = '';

		};

		var deallocateTexture = function ( texture ) {

			if ( texture.image && texture.image.__webglTextureCube ) {

				// cube texture

				_gl.deleteTexture( texture.image.__webglTextureCube );

				delete texture.image.__webglTextureCube;

			} else {

				// 2D texture

				if ( texture.__webglInit === undefined ) return;

				_gl.deleteTexture( texture.__webglTexture );

				delete texture.__webglTexture;
				delete texture.__webglInit;

			}

		};

		var deallocateRenderTarget = function ( renderTarget ) {

			if ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;

			_gl.deleteTexture( renderTarget.__webglTexture );

			delete renderTarget.__webglTexture;

			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

				for ( var i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
					_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

			}

			delete renderTarget.__webglFramebuffer;
			delete renderTarget.__webglRenderbuffer;

		};

		var deallocateMaterial = function ( material ) {

			var program = material.program.program;

			if ( program === undefined ) return;

			material.program = undefined;

			// only deallocate GL program if this was the last use of shared program
			// assumed there is only single copy of any program in the _programs list
			// (that's how it's constructed)

			var i, il, programInfo;
			var deleteProgram = false;

			for ( i = 0, il = _programs.length; i < il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.program === program ) {

					programInfo.usedTimes --;

					if ( programInfo.usedTimes === 0 ) {

						deleteProgram = true;

					}

					break;

				}

			}

			if ( deleteProgram === true ) {

				// avoid using array.splice, this is costlier than creating new array from scratch

				var newPrograms = [];

				for ( i = 0, il = _programs.length; i < il; i ++ ) {

					programInfo = _programs[ i ];

					if ( programInfo.program !== program ) {

						newPrograms.push( programInfo );

					}

				}

				_programs = newPrograms;

				_gl.deleteProgram( program );

				_this.info.memory.programs --;

			}

		};

		// Buffer initialization

		function initCustomAttributes ( object ) {

			var geometry = object.geometry;
			var material = object.material;

			var nvertices = geometry.vertices.length;

			if ( material.attributes ) {

				if ( geometry.__webglCustomAttributesList === undefined ) {

					geometry.__webglCustomAttributesList = [];

				}

				for ( var name in material.attributes ) {

					var attribute = material.attributes[ name ];

					if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

						attribute.__webglInitialized = true;

						var size = 1;   // "f" and "i"

						if ( attribute.type === 'v2' ) size = 2;
						else if ( attribute.type === 'v3' ) size = 3;
						else if ( attribute.type === 'v4' ) size = 4;
						else if ( attribute.type === 'c'  ) size = 3;

						attribute.size = size;

						attribute.array = new Float32Array( nvertices * size );

						attribute.buffer = _gl.createBuffer();
						attribute.buffer.belongsToAttribute = name;

						attribute.needsUpdate = true;

					}

					geometry.__webglCustomAttributesList.push( attribute );

				}

			}

		};

		function initParticleBuffers ( geometry, object ) {

			var nvertices = geometry.vertices.length;

			geometry.__vertexArray = new Float32Array( nvertices * 3 );
			geometry.__colorArray = new Float32Array( nvertices * 3 );

			geometry.__webglParticleCount = nvertices;

			initCustomAttributes( object );

		};

		function initLineBuffers ( geometry, object ) {

			var nvertices = geometry.vertices.length;

			geometry.__vertexArray = new Float32Array( nvertices * 3 );
			geometry.__colorArray = new Float32Array( nvertices * 3 );
			geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

			geometry.__webglLineCount = nvertices;

			initCustomAttributes( object );

		};

		function initMeshBuffers ( geometryGroup, object ) {

			var geometry = object.geometry,
				faces3 = geometryGroup.faces3,

				nvertices = faces3.length * 3,
				ntris     = faces3.length * 1,
				nlines    = faces3.length * 3,

				material = getBufferMaterial( object, geometryGroup );

			geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );
			geometryGroup.__normalArray = new Float32Array( nvertices * 3 );
			geometryGroup.__colorArray = new Float32Array( nvertices * 3 );
			geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

			if ( geometry.faceVertexUvs.length > 1 ) {

				geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

			}

			if ( geometry.hasTangents ) {

				geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

			}

			if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

				geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
				geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

			}

			var UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3

			geometryGroup.__typeArray = UintArray;
			geometryGroup.__faceArray = new UintArray( ntris * 3 );
			geometryGroup.__lineArray = new UintArray( nlines * 2 );

			var numMorphTargets = geometryGroup.numMorphTargets;

			if ( numMorphTargets ) {

				geometryGroup.__morphTargetsArrays = [];

				for ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {

					geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );

				}

			}

			var numMorphNormals = geometryGroup.numMorphNormals;

			if ( numMorphNormals ) {

				geometryGroup.__morphNormalsArrays = [];

				for ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {

					geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );

				}

			}

			geometryGroup.__webglFaceCount = ntris * 3;
			geometryGroup.__webglLineCount = nlines * 2;


			// custom attributes

			if ( material.attributes ) {

				if ( geometryGroup.__webglCustomAttributesList === undefined ) {

					geometryGroup.__webglCustomAttributesList = [];

				}

				for ( var name in material.attributes ) {

					// Do a shallow copy of the attribute object so different geometryGroup chunks use different
					// attribute buffers which are correctly indexed in the setMeshBuffers function

					var originalAttribute = material.attributes[ name ];

					var attribute = {};

					for ( var property in originalAttribute ) {

						attribute[ property ] = originalAttribute[ property ];

					}

					if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

						attribute.__webglInitialized = true;

						var size = 1;   // "f" and "i"

						if ( attribute.type === 'v2' ) size = 2;
						else if ( attribute.type === 'v3' ) size = 3;
						else if ( attribute.type === 'v4' ) size = 4;
						else if ( attribute.type === 'c'  ) size = 3;

						attribute.size = size;

						attribute.array = new Float32Array( nvertices * size );

						attribute.buffer = _gl.createBuffer();
						attribute.buffer.belongsToAttribute = name;

						originalAttribute.needsUpdate = true;
						attribute.__original = originalAttribute;

					}

					geometryGroup.__webglCustomAttributesList.push( attribute );

				}

			}

			geometryGroup.__inittedArrays = true;

		};

		function getBufferMaterial( object, geometryGroup ) {

			return object.material instanceof THREE.MeshFaceMaterial
				 ? object.material.materials[ geometryGroup.materialIndex ]
				 : object.material;

		}

		function materialNeedsFaceNormals ( material ) {

			return material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading;

		}

		// Buffer setting

		function setParticleBuffers ( geometry, hint, object ) {

			var v, c, vertex, offset, color,

			vertices = geometry.vertices,
			vl = vertices.length,

			colors = geometry.colors,
			cl = colors.length,

			vertexArray = geometry.__vertexArray,
			colorArray = geometry.__colorArray,

			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,

			customAttributes = geometry.__webglCustomAttributesList,
			i, il,
			ca, cal, value,
			customAttribute;

			if ( dirtyVertices ) {

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

			}

			if ( dirtyColors ) {

				for ( c = 0; c < cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined ||  customAttribute.boundTo === 'vertices' ) ) {

						cal = customAttribute.value.length;

						offset = 0;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === 'c' ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

					customAttribute.needsUpdate = false;

				}

			}

		}

		function setLineBuffers ( geometry, hint ) {

			var v, c, d, vertex, offset, color,

			vertices = geometry.vertices,
			colors = geometry.colors,
			lineDistances = geometry.lineDistances,

			vl = vertices.length,
			cl = colors.length,
			dl = lineDistances.length,

			vertexArray = geometry.__vertexArray,
			colorArray = geometry.__colorArray,
			lineDistanceArray = geometry.__lineDistanceArray,

			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
			dirtyLineDistances = geometry.lineDistancesNeedUpdate,

			customAttributes = geometry.__webglCustomAttributesList,

			i, il,
			ca, cal, value,
			customAttribute;

			if ( dirtyVertices ) {

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

			}

			if ( dirtyColors ) {

				for ( c = 0; c < cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

			if ( dirtyLineDistances ) {

				for ( d = 0; d < dl; d ++ ) {

					lineDistanceArray[ d ] = lineDistances[ d ];

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) ) {

						offset = 0;

						cal = customAttribute.value.length;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === 'c' ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]    = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
						_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

						customAttribute.needsUpdate = false;

					}

				}

			}

		}

		function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

			if ( ! geometryGroup.__inittedArrays ) {

				return;

			}

			var needsFaceNormals = materialNeedsFaceNormals( material );

			var f, fl, fi, face,
			vertexNormals, faceNormal,
			vertexColors, faceColor,
			vertexTangents,
			uv, uv2, v1, v2, v3, t1, t2, t3, n1, n2, n3,
			c1, c2, c3,
			sw1, sw2, sw3,
			si1, si2, si3,
			i, il,
			vn, uvi, uv2i,
			vk, vkl, vka,
			nka, chf, faceVertexNormals,

			vertexIndex = 0,

			offset = 0,
			offset_uv = 0,
			offset_uv2 = 0,
			offset_face = 0,
			offset_normal = 0,
			offset_tangent = 0,
			offset_line = 0,
			offset_color = 0,
			offset_skin = 0,
			offset_morphTarget = 0,
			offset_custom = 0,

			value,

			vertexArray = geometryGroup.__vertexArray,
			uvArray = geometryGroup.__uvArray,
			uv2Array = geometryGroup.__uv2Array,
			normalArray = geometryGroup.__normalArray,
			tangentArray = geometryGroup.__tangentArray,
			colorArray = geometryGroup.__colorArray,

			skinIndexArray = geometryGroup.__skinIndexArray,
			skinWeightArray = geometryGroup.__skinWeightArray,

			morphTargetsArrays = geometryGroup.__morphTargetsArrays,
			morphNormalsArrays = geometryGroup.__morphNormalsArrays,

			customAttributes = geometryGroup.__webglCustomAttributesList,
			customAttribute,

			faceArray = geometryGroup.__faceArray,
			lineArray = geometryGroup.__lineArray,

			geometry = object.geometry, // this is shared for all chunks

			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyElements = geometry.elementsNeedUpdate,
			dirtyUvs = geometry.uvsNeedUpdate,
			dirtyNormals = geometry.normalsNeedUpdate,
			dirtyTangents = geometry.tangentsNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
			dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

			vertices = geometry.vertices,
			chunk_faces3 = geometryGroup.faces3,
			obj_faces = geometry.faces,

			obj_uvs  = geometry.faceVertexUvs[ 0 ],
			obj_uvs2 = geometry.faceVertexUvs[ 1 ],

			obj_skinIndices = geometry.skinIndices,
			obj_skinWeights = geometry.skinWeights,

			morphTargets = geometry.morphTargets,
			morphNormals = geometry.morphNormals;

			if ( dirtyVertices ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					v1 = vertices[ face.a ];
					v2 = vertices[ face.b ];
					v3 = vertices[ face.c ];

					vertexArray[ offset ]     = v1.x;
					vertexArray[ offset + 1 ] = v1.y;
					vertexArray[ offset + 2 ] = v1.z;

					vertexArray[ offset + 3 ] = v2.x;
					vertexArray[ offset + 4 ] = v2.y;
					vertexArray[ offset + 5 ] = v2.z;

					vertexArray[ offset + 6 ] = v3.x;
					vertexArray[ offset + 7 ] = v3.y;
					vertexArray[ offset + 8 ] = v3.z;

					offset += 9;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

			}

			if ( dirtyMorphTargets ) {

				for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {

					offset_morphTarget = 0;

					for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

						chf = chunk_faces3[ f ];
						face = obj_faces[ chf ];

						// morph positions

						v1 = morphTargets[ vk ].vertices[ face.a ];
						v2 = morphTargets[ vk ].vertices[ face.b ];
						v3 = morphTargets[ vk ].vertices[ face.c ];

						vka = morphTargetsArrays[ vk ];

						vka[ offset_morphTarget ]     = v1.x;
						vka[ offset_morphTarget + 1 ] = v1.y;
						vka[ offset_morphTarget + 2 ] = v1.z;

						vka[ offset_morphTarget + 3 ] = v2.x;
						vka[ offset_morphTarget + 4 ] = v2.y;
						vka[ offset_morphTarget + 5 ] = v2.z;

						vka[ offset_morphTarget + 6 ] = v3.x;
						vka[ offset_morphTarget + 7 ] = v3.y;
						vka[ offset_morphTarget + 8 ] = v3.z;

						// morph normals

						if ( material.morphNormals ) {

							if ( needsFaceNormals ) {

								n1 = morphNormals[ vk ].faceNormals[ chf ];
								n2 = n1;
								n3 = n1;

							} else {

								faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

								n1 = faceVertexNormals.a;
								n2 = faceVertexNormals.b;
								n3 = faceVertexNormals.c;

							}

							nka = morphNormalsArrays[ vk ];

							nka[ offset_morphTarget ]     = n1.x;
							nka[ offset_morphTarget + 1 ] = n1.y;
							nka[ offset_morphTarget + 2 ] = n1.z;

							nka[ offset_morphTarget + 3 ] = n2.x;
							nka[ offset_morphTarget + 4 ] = n2.y;
							nka[ offset_morphTarget + 5 ] = n2.z;

							nka[ offset_morphTarget + 6 ] = n3.x;
							nka[ offset_morphTarget + 7 ] = n3.y;
							nka[ offset_morphTarget + 8 ] = n3.z;

						}

						//

						offset_morphTarget += 9;

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

					if ( material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
						_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

					}

				}

			}

			if ( obj_skinWeights.length ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					// weights

					sw1 = obj_skinWeights[ face.a ];
					sw2 = obj_skinWeights[ face.b ];
					sw3 = obj_skinWeights[ face.c ];

					skinWeightArray[ offset_skin ]     = sw1.x;
					skinWeightArray[ offset_skin + 1 ] = sw1.y;
					skinWeightArray[ offset_skin + 2 ] = sw1.z;
					skinWeightArray[ offset_skin + 3 ] = sw1.w;

					skinWeightArray[ offset_skin + 4 ] = sw2.x;
					skinWeightArray[ offset_skin + 5 ] = sw2.y;
					skinWeightArray[ offset_skin + 6 ] = sw2.z;
					skinWeightArray[ offset_skin + 7 ] = sw2.w;

					skinWeightArray[ offset_skin + 8 ]  = sw3.x;
					skinWeightArray[ offset_skin + 9 ]  = sw3.y;
					skinWeightArray[ offset_skin + 10 ] = sw3.z;
					skinWeightArray[ offset_skin + 11 ] = sw3.w;

					// indices

					si1 = obj_skinIndices[ face.a ];
					si2 = obj_skinIndices[ face.b ];
					si3 = obj_skinIndices[ face.c ];

					skinIndexArray[ offset_skin ]     = si1.x;
					skinIndexArray[ offset_skin + 1 ] = si1.y;
					skinIndexArray[ offset_skin + 2 ] = si1.z;
					skinIndexArray[ offset_skin + 3 ] = si1.w;

					skinIndexArray[ offset_skin + 4 ] = si2.x;
					skinIndexArray[ offset_skin + 5 ] = si2.y;
					skinIndexArray[ offset_skin + 6 ] = si2.z;
					skinIndexArray[ offset_skin + 7 ] = si2.w;

					skinIndexArray[ offset_skin + 8 ]  = si3.x;
					skinIndexArray[ offset_skin + 9 ]  = si3.y;
					skinIndexArray[ offset_skin + 10 ] = si3.z;
					skinIndexArray[ offset_skin + 11 ] = si3.w;

					offset_skin += 12;

				}

				if ( offset_skin > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );

				}

			}

			if ( dirtyColors ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					vertexColors = face.vertexColors;
					faceColor = face.color;

					if ( vertexColors.length === 3 && material.vertexColors === THREE.VertexColors ) {

						c1 = vertexColors[ 0 ];
						c2 = vertexColors[ 1 ];
						c3 = vertexColors[ 2 ];

					} else {

						c1 = faceColor;
						c2 = faceColor;
						c3 = faceColor;

					}

					colorArray[ offset_color ]     = c1.r;
					colorArray[ offset_color + 1 ] = c1.g;
					colorArray[ offset_color + 2 ] = c1.b;

					colorArray[ offset_color + 3 ] = c2.r;
					colorArray[ offset_color + 4 ] = c2.g;
					colorArray[ offset_color + 5 ] = c2.b;

					colorArray[ offset_color + 6 ] = c3.r;
					colorArray[ offset_color + 7 ] = c3.g;
					colorArray[ offset_color + 8 ] = c3.b;

					offset_color += 9;

				}

				if ( offset_color > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

				}

			}

			if ( dirtyTangents && geometry.hasTangents ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					vertexTangents = face.vertexTangents;

					t1 = vertexTangents[ 0 ];
					t2 = vertexTangents[ 1 ];
					t3 = vertexTangents[ 2 ];

					tangentArray[ offset_tangent ]     = t1.x;
					tangentArray[ offset_tangent + 1 ] = t1.y;
					tangentArray[ offset_tangent + 2 ] = t1.z;
					tangentArray[ offset_tangent + 3 ] = t1.w;

					tangentArray[ offset_tangent + 4 ] = t2.x;
					tangentArray[ offset_tangent + 5 ] = t2.y;
					tangentArray[ offset_tangent + 6 ] = t2.z;
					tangentArray[ offset_tangent + 7 ] = t2.w;

					tangentArray[ offset_tangent + 8 ]  = t3.x;
					tangentArray[ offset_tangent + 9 ]  = t3.y;
					tangentArray[ offset_tangent + 10 ] = t3.z;
					tangentArray[ offset_tangent + 11 ] = t3.w;

					offset_tangent += 12;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

			}

			if ( dirtyNormals ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					vertexNormals = face.vertexNormals;
					faceNormal = face.normal;

					if ( vertexNormals.length === 3 && needsFaceNormals === false ) {

						for ( i = 0; i < 3; i ++ ) {

							vn = vertexNormals[ i ];

							normalArray[ offset_normal ]     = vn.x;
							normalArray[ offset_normal + 1 ] = vn.y;
							normalArray[ offset_normal + 2 ] = vn.z;

							offset_normal += 3;

						}

					} else {

						for ( i = 0; i < 3; i ++ ) {

							normalArray[ offset_normal ]     = faceNormal.x;
							normalArray[ offset_normal + 1 ] = faceNormal.y;
							normalArray[ offset_normal + 2 ] = faceNormal.z;

							offset_normal += 3;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

			}

			if ( dirtyUvs && obj_uvs ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					fi = chunk_faces3[ f ];

					uv = obj_uvs[ fi ];

					if ( uv === undefined ) continue;

					for ( i = 0; i < 3; i ++ ) {

						uvi = uv[ i ];

						uvArray[ offset_uv ]     = uvi.x;
						uvArray[ offset_uv + 1 ] = uvi.y;

						offset_uv += 2;

					}

				}

				if ( offset_uv > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

				}

			}

			if ( dirtyUvs && obj_uvs2 ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					fi = chunk_faces3[ f ];

					uv2 = obj_uvs2[ fi ];

					if ( uv2 === undefined ) continue;

					for ( i = 0; i < 3; i ++ ) {

						uv2i = uv2[ i ];

						uv2Array[ offset_uv2 ]     = uv2i.x;
						uv2Array[ offset_uv2 + 1 ] = uv2i.y;

						offset_uv2 += 2;

					}

				}

				if ( offset_uv2 > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

				}

			}

			if ( dirtyElements ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					faceArray[ offset_face ]   = vertexIndex;
					faceArray[ offset_face + 1 ] = vertexIndex + 1;
					faceArray[ offset_face + 2 ] = vertexIndex + 2;

					offset_face += 3;

					lineArray[ offset_line ]     = vertexIndex;
					lineArray[ offset_line + 1 ] = vertexIndex + 1;

					lineArray[ offset_line + 2 ] = vertexIndex;
					lineArray[ offset_line + 3 ] = vertexIndex + 2;

					lineArray[ offset_line + 4 ] = vertexIndex + 1;
					lineArray[ offset_line + 5 ] = vertexIndex + 2;

					offset_line += 6;

					vertexIndex += 3;

				}

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! customAttribute.__original.needsUpdate ) continue;

					offset_custom = 0;

					if ( customAttribute.size === 1 ) {

						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								face = obj_faces[ chunk_faces3[ f ] ];

								customAttribute.array[ offset_custom ]     = customAttribute.value[ face.a ];
								customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
								customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

								offset_custom += 3;

							}

						} else if ( customAttribute.boundTo === 'faces' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								customAttribute.array[ offset_custom ]     = value;
								customAttribute.array[ offset_custom + 1 ] = value;
								customAttribute.array[ offset_custom + 2 ] = value;

								offset_custom += 3;

							}

						}

					} else if ( customAttribute.size === 2 ) {

						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								face = obj_faces[ chunk_faces3[ f ] ];

								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];

								customAttribute.array[ offset_custom ]     = v1.x;
								customAttribute.array[ offset_custom + 1 ] = v1.y;

								customAttribute.array[ offset_custom + 2 ] = v2.x;
								customAttribute.array[ offset_custom + 3 ] = v2.y;

								customAttribute.array[ offset_custom + 4 ] = v3.x;
								customAttribute.array[ offset_custom + 5 ] = v3.y;

								offset_custom += 6;

							}

						} else if ( customAttribute.boundTo === 'faces' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value;
								v2 = value;
								v3 = value;

								customAttribute.array[ offset_custom ]     = v1.x;
								customAttribute.array[ offset_custom + 1 ] = v1.y;

								customAttribute.array[ offset_custom + 2 ] = v2.x;
								customAttribute.array[ offset_custom + 3 ] = v2.y;

								customAttribute.array[ offset_custom + 4 ] = v3.x;
								customAttribute.array[ offset_custom + 5 ] = v3.y;

								offset_custom += 6;

							}

						}

					} else if ( customAttribute.size === 3 ) {

						var pp;

						if ( customAttribute.type === 'c' ) {

							pp = [ 'r', 'g', 'b' ];

						} else {

							pp = [ 'x', 'y', 'z' ];

						}

						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								face = obj_faces[ chunk_faces3[ f ] ];

								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];

								customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

								offset_custom += 9;

							}

						} else if ( customAttribute.boundTo === 'faces' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value;
								v2 = value;
								v3 = value;

								customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

								offset_custom += 9;

							}

						} else if ( customAttribute.boundTo === 'faceVertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value[ 0 ];
								v2 = value[ 1 ];
								v3 = value[ 2 ];

								customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

								offset_custom += 9;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								face = obj_faces[ chunk_faces3[ f ] ];

								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];

								customAttribute.array[ offset_custom  ]   = v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;

								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;

								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;

								offset_custom += 12;

							}

						} else if ( customAttribute.boundTo === 'faces' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value;
								v2 = value;
								v3 = value;

								customAttribute.array[ offset_custom  ]   = v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;

								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;

								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;

								offset_custom += 12;

							}

						} else if ( customAttribute.boundTo === 'faceVertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value[ 0 ];
								v2 = value[ 1 ];
								v3 = value[ 2 ];

								customAttribute.array[ offset_custom  ]   = v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;

								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;

								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;

								offset_custom += 12;

							}

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

			if ( dispose ) {

				delete geometryGroup.__inittedArrays;
				delete geometryGroup.__colorArray;
				delete geometryGroup.__normalArray;
				delete geometryGroup.__tangentArray;
				delete geometryGroup.__uvArray;
				delete geometryGroup.__uv2Array;
				delete geometryGroup.__faceArray;
				delete geometryGroup.__vertexArray;
				delete geometryGroup.__lineArray;
				delete geometryGroup.__skinIndexArray;
				delete geometryGroup.__skinWeightArray;

			}

		};

		// Buffer rendering

		this.renderBufferImmediate = function ( object, program, material ) {

			state.initAttributes();

			if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
			if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
			if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
			if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

			if ( object.hasPositions ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( program.attributes.position );

				_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

				if ( material instanceof THREE.MeshPhongMaterial === false &&
					   material.shading === THREE.FlatShading ) {

					var nx, ny, nz,
						nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
						normalArray,
						i, il = object.count * 3;

					for ( i = 0; i < il; i += 9 ) {

						normalArray = object.normalArray;

						nax  = normalArray[ i ];
						nay  = normalArray[ i + 1 ];
						naz  = normalArray[ i + 2 ];

						nbx  = normalArray[ i + 3 ];
						nby  = normalArray[ i + 4 ];
						nbz  = normalArray[ i + 5 ];

						ncx  = normalArray[ i + 6 ];
						ncy  = normalArray[ i + 7 ];
						ncz  = normalArray[ i + 8 ];

						nx = ( nax + nbx + ncx ) / 3;
						ny = ( nay + nby + ncy ) / 3;
						nz = ( naz + nbz + ncz ) / 3;

						normalArray[ i ]   = nx;
						normalArray[ i + 1 ] = ny;
						normalArray[ i + 2 ] = nz;

						normalArray[ i + 3 ] = nx;
						normalArray[ i + 4 ] = ny;
						normalArray[ i + 5 ] = nz;

						normalArray[ i + 6 ] = nx;
						normalArray[ i + 7 ] = ny;
						normalArray[ i + 8 ] = nz;

					}

				}

				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( program.attributes.normal );

				_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasUvs && material.map ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( program.attributes.uv );

				_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( program.attributes.color );

				_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );

			}

			state.disableUnusedAttributes();

			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

			object.count = 0;

		};

		function setupVertexAttributes( material, program, geometry, startIndex ) {

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.attributes;
			var programAttributesKeys = program.attributesKeys;

			for ( var i = 0, l = programAttributesKeys.length; i < l; i ++ ) {

				var key = programAttributesKeys[ i ];
				var programAttribute = programAttributes[ key ];

				if ( programAttribute >= 0 ) {

					var geometryAttribute = geometryAttributes[ key ];

					if ( geometryAttribute !== undefined ) {

						var size = geometryAttribute.itemSize;

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );

						state.enableAttribute( programAttribute );

						_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

					} else if ( material.defaultAttributeValues !== undefined ) {

						if ( material.defaultAttributeValues[ key ].length === 2 ) {

							_gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );

						} else if ( material.defaultAttributeValues[ key ].length === 3 ) {

							_gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );

						}

					}

				}

			}

			state.disableUnusedAttributes();

		}

		this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {

			if ( material.visible === false ) return;

			updateObject( object );

			var program = setProgram( camera, lights, fog, material, object );

			var updateBuffers = false,
				wireframeBit = material.wireframe ? 1 : 0,
				geometryProgram = 'direct_' + geometry.id + '_' + program.id + '_' + wireframeBit;

			if ( geometryProgram !== _currentGeometryProgram ) {

				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;

			}

			if ( updateBuffers ) {

				state.initAttributes();

			}

			// render mesh

			if ( object instanceof THREE.Mesh ) {

				var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;

				var index = geometry.attributes.index;

				if ( index ) {

					// indexed triangles

					var type, size;

					if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

						type = _gl.UNSIGNED_INT;
						size = 4;

					} else {

						type = _gl.UNSIGNED_SHORT;
						size = 2;

					}

					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, 0 );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						_gl.drawElements( mode, index.array.length, type, 0 );

						_this.info.render.calls ++;
						_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared
						_this.info.render.faces += index.array.length / 3;

					} else {

						// if there is more than 1 chunk
						// must set attribute pointers to use new offsets for each chunk
						// even if geometry and materials didn't change

						updateBuffers = true;

						for ( var i = 0, il = offsets.length; i < il; i ++ ) {

							var startIndex = offsets[ i ].index;

							if ( updateBuffers ) {

								setupVertexAttributes( material, program, geometry, startIndex );
								_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

							}

							// render indexed triangles

							_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );

							_this.info.render.calls ++;
							_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
							_this.info.render.faces += offsets[ i ].count / 3;

						}

					}

				} else {

					// non-indexed triangles

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );

					}

					var position = geometry.attributes[ 'position' ];

					// render non-indexed triangles

					_gl.drawArrays( mode, 0, position.array.length / position.itemSize );

					_this.info.render.calls ++;
					_this.info.render.vertices += position.array.length / position.itemSize;
					_this.info.render.faces += position.array.length / ( 3 * position.itemSize );

				}

			} else if ( object instanceof THREE.PointCloud ) {

				// render particles

				var mode = _gl.POINTS;

				var index = geometry.attributes.index;

				if ( index ) {

					// indexed points

					var type, size;

					if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

						type = _gl.UNSIGNED_INT;
						size = 4;

					} else {

						type = _gl.UNSIGNED_SHORT;
						size = 2;

					}

					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, 0 );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						_gl.drawElements( mode, index.array.length, type, 0);

						_this.info.render.calls ++;
						_this.info.render.points += index.array.length;

					} else {

						// if there is more than 1 chunk
						// must set attribute pointers to use new offsets for each chunk
						// even if geometry and materials didn't change

						if ( offsets.length > 1 ) updateBuffers = true;

						for ( var i = 0, il = offsets.length; i < il; i ++ ) {

							var startIndex = offsets[ i ].index;

							if ( updateBuffers ) {

								setupVertexAttributes( material, program, geometry, startIndex );
								_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

							}

							// render indexed points

							_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );

							_this.info.render.calls ++;
							_this.info.render.points += offsets[ i ].count;

						}

					}

				} else {

					// non-indexed points

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );

					}

					var position = geometry.attributes.position;
					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						_gl.drawArrays( mode, 0, position.array.length / 3 );

						_this.info.render.calls ++;
						_this.info.render.points += position.array.length / 3;

					} else {

						for ( var i = 0, il = offsets.length; i < il; i ++ ) {

							_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );

							_this.info.render.calls ++;
							_this.info.render.points += offsets[ i ].count;

						}

					}

				}

			} else if ( object instanceof THREE.Line ) {

				var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

				state.setLineWidth( material.linewidth * pixelRatio );

				var index = geometry.attributes.index;

				if ( index ) {

					// indexed lines

					var type, size;

					if ( index.array instanceof Uint32Array ) {

						type = _gl.UNSIGNED_INT;
						size = 4;

					} else {

						type = _gl.UNSIGNED_SHORT;
						size = 2;

					}

					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, 0 );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						_gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array

						_this.info.render.calls ++;
						_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared

					} else {

						// if there is more than 1 chunk
						// must set attribute pointers to use new offsets for each chunk
						// even if geometry and materials didn't change

						if ( offsets.length > 1 ) updateBuffers = true;

						for ( var i = 0, il = offsets.length; i < il; i ++ ) {

							var startIndex = offsets[ i ].index;

							if ( updateBuffers ) {

								setupVertexAttributes( material, program, geometry, startIndex );
								_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

							}

							// render indexed lines

							_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array

							_this.info.render.calls ++;
							_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared

						}

					}

				} else {

					// non-indexed lines

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );

					}

					var position = geometry.attributes.position;
					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						_gl.drawArrays( mode, 0, position.array.length / 3 );

						_this.info.render.calls ++;
						_this.info.render.vertices += position.array.length / 3;

					} else {

						for ( var i = 0, il = offsets.length; i < il; i ++ ) {

							_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );

							_this.info.render.calls ++;
							_this.info.render.vertices += offsets[ i ].count;

						}

					}

				}

			}

		};

		this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

			if ( material.visible === false ) return;

			updateObject( object );

			var program = setProgram( camera, lights, fog, material, object );

			var attributes = program.attributes;

			var updateBuffers = false,
				wireframeBit = material.wireframe ? 1 : 0,
				geometryProgram = geometryGroup.id + '_' + program.id + '_' + wireframeBit;

			if ( geometryProgram !== _currentGeometryProgram ) {

				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;

			}

			if ( updateBuffers ) {

				state.initAttributes();

			}

			// vertices

			if ( ! material.morphTargets && attributes.position >= 0 ) {

				if ( updateBuffers ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );

					state.enableAttribute( attributes.position );

					_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

				}

			} else {

				if ( object.morphTargetBase ) {

					setupMorphTargets( material, geometryGroup, object );

				}

			}


			if ( updateBuffers ) {

				// custom attributes

				// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

				if ( geometryGroup.__webglCustomAttributesList ) {

					for ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

						var attribute = geometryGroup.__webglCustomAttributesList[ i ];

						if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

							_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );

							state.enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );

							_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

						}

					}

				}


				// colors

				if ( attributes.color >= 0 ) {

					if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );

						state.enableAttribute( attributes.color );

						_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

					} else if ( material.defaultAttributeValues !== undefined ) {


						_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );

					}

				}

				// normals

				if ( attributes.normal >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );

					state.enableAttribute( attributes.normal );

					_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

				}

				// tangents

				if ( attributes.tangent >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );

					state.enableAttribute( attributes.tangent );

					_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

				}

				// uvs

				if ( attributes.uv >= 0 ) {

					if ( object.geometry.faceVertexUvs[ 0 ] ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );

						state.enableAttribute( attributes.uv );

						_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

					} else if ( material.defaultAttributeValues !== undefined ) {


						_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );

					}

				}

				if ( attributes.uv2 >= 0 ) {

					if ( object.geometry.faceVertexUvs[ 1 ] ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );

						state.enableAttribute( attributes.uv2 );

						_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

					} else if ( material.defaultAttributeValues !== undefined ) {


						_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );

					}

				}

				if ( material.skinning &&
					 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );

					state.enableAttribute( attributes.skinIndex );

					_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );

					state.enableAttribute( attributes.skinWeight );

					_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );

				}

				// line distances

				if ( attributes.lineDistance >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );

					state.enableAttribute( attributes.lineDistance );

					_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

				}

			}

			state.disableUnusedAttributes();

			// render mesh

			if ( object instanceof THREE.Mesh ) {

				var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;

				// wireframe

				if ( material.wireframe ) {

					state.setLineWidth( material.wireframeLinewidth * pixelRatio );

					if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
					_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );

				// triangles

				} else {

					if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
					_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );

				}

				_this.info.render.calls ++;
				_this.info.render.vertices += geometryGroup.__webglFaceCount;
				_this.info.render.faces += geometryGroup.__webglFaceCount / 3;

			// render lines

			} else if ( object instanceof THREE.Line ) {

				var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

				state.setLineWidth( material.linewidth * pixelRatio );

				_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );

				_this.info.render.calls ++;

			// render particles

			} else if ( object instanceof THREE.PointCloud ) {

				_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );

				_this.info.render.calls ++;
				_this.info.render.points += geometryGroup.__webglParticleCount;

			}

		};

		function setupMorphTargets ( material, geometryGroup, object ) {

			// set base

			var attributes = material.program.attributes;

			if ( object.morphTargetBase !== - 1 && attributes.position >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );

				state.enableAttribute( attributes.position );

				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			} else if ( attributes.position >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );

				state.enableAttribute( attributes.position );

				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.morphTargetForcedOrder.length ) {

				// set forced order

				var m = 0;
				var order = object.morphTargetForcedOrder;
				var influences = object.morphTargetInfluences;

				var attribute;

				while ( m < material.numSupportedMorphTargets && m < order.length ) {

					attribute = attributes[ 'morphTarget' + m ];

					if ( attribute >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );

						state.enableAttribute( attribute );

						_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );

					}

					attribute = attributes[ 'morphNormal' + m ];

					if ( attribute >= 0 && material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );

						state.enableAttribute( attribute );

						_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );

					}

					object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

					m ++;

				}

			} else {

				// find the most influencing

				var activeInfluenceIndices = [];
				var influences = object.morphTargetInfluences;
				var morphTargets = object.geometry.morphTargets;

				if ( influences.length > morphTargets.length ) {

					console.warn( 'THREE.WebGLRenderer: Influences array is bigger than morphTargets array.' );
					influences.length = morphTargets.length;

				}

				for ( var i = 0, il = influences.length; i < il; i ++ ) {

					var influence = influences[ i ];

					activeInfluenceIndices.push( [ influence, i ] );

				}

				if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {

					activeInfluenceIndices.sort( numericalSort );
					activeInfluenceIndices.length = material.numSupportedMorphTargets;

				} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {

					activeInfluenceIndices.sort( numericalSort );

				} else if ( activeInfluenceIndices.length === 0 ) {

					activeInfluenceIndices.push( [ 0, 0 ] );

				}

				var attribute;

				for ( var m = 0, ml = material.numSupportedMorphTargets; m < ml; m ++ ) {

					if ( activeInfluenceIndices[ m ] ) {

						var influenceIndex = activeInfluenceIndices[ m ][ 1 ];

						attribute = attributes[ 'morphTarget' + m ];

						if ( attribute >= 0 ) {

							_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );

							state.enableAttribute( attribute );

							_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );

						}

						attribute = attributes[ 'morphNormal' + m ];

						if ( attribute >= 0 && material.morphNormals ) {

							_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );

							state.enableAttribute( attribute );

							_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );

						}

						object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];

					} else {

						/*
						_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

						if ( material.morphNormals ) {

							_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

						}
						*/

						object.__webglMorphTargetInfluences[ m ] = 0;

					}

				}

			}

			// load updated influences uniform

			if ( material.program.uniforms.morphTargetInfluences !== null ) {

				_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );

			}

		}

		// Sorting

		function painterSortStable ( a, b ) {

			if ( a.object.renderOrder !== b.object.renderOrder ) {

				return a.object.renderOrder - b.object.renderOrder;

			} else if ( a.material.id !== b.material.id ) {

				return a.material.id - b.material.id;

			} else if ( a.z !== b.z ) {

				return a.z - b.z;

			} else {

				return a.id - b.id;

			}

		}

		function reversePainterSortStable ( a, b ) {

			if ( a.object.renderOrder !== b.object.renderOrder ) {

				return a.object.renderOrder - b.object.renderOrder;

			} if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return a.id - b.id;

			}

		}

		function numericalSort ( a, b ) {

			return b[ 0 ] - a[ 0 ];

		}

		// Rendering

		this.render = function ( scene, camera, renderTarget, forceClear ) {

			if ( camera instanceof THREE.Camera === false ) {

				THREE.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			var fog = scene.fog;

			// reset caching for this frame

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
			_currentCamera = null;
			_lightsNeedUpdate = true;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === undefined ) camera.updateMatrixWorld();

			// update Skeleton objects

			scene.traverse( function ( object ) {

				if ( object instanceof THREE.SkinnedMesh ) {

					object.skeleton.update();

				}

			} );

			camera.matrixWorldInverse.getInverse( camera.matrixWorld );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			lights.length = 0;
			opaqueObjects.length = 0;
			transparentObjects.length = 0;

			sprites.length = 0;
			lensFlares.length = 0;

			projectObject( scene );

			if ( _this.sortObjects === true ) {

				opaqueObjects.sort( painterSortStable );
				transparentObjects.sort( reversePainterSortStable );

			}

			// custom render plugins (pre pass)

			shadowMapPlugin.render( scene, camera );

			//

			_this.info.render.calls = 0;
			_this.info.render.vertices = 0;
			_this.info.render.faces = 0;
			_this.info.render.points = 0;

			this.setRenderTarget( renderTarget );

			if ( this.autoClear || forceClear ) {

				this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

			}

			// set matrices for immediate objects

			for ( var i = 0, il = _webglObjectsImmediate.length; i < il; i ++ ) {

				var webglObject = _webglObjectsImmediate[ i ];
				var object = webglObject.object;

				if ( object.visible ) {

					setupMatrices( object, camera );

					unrollImmediateBufferMaterial( webglObject );

				}

			}

			if ( scene.overrideMaterial ) {

				var overrideMaterial = scene.overrideMaterial;

				setMaterial( overrideMaterial );

				renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
				renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );
				renderObjectsImmediate( _webglObjectsImmediate, '', camera, lights, fog, overrideMaterial );

			} else {

				// opaque pass (front-to-back order)

				state.setBlending( THREE.NoBlending );

				renderObjects( opaqueObjects, camera, lights, fog, null );
				renderObjectsImmediate( _webglObjectsImmediate, 'opaque', camera, lights, fog, null );

				// transparent pass (back-to-front order)

				renderObjects( transparentObjects, camera, lights, fog, null );
				renderObjectsImmediate( _webglObjectsImmediate, 'transparent', camera, lights, fog, null );

			}

			// custom render plugins (post pass)

			spritePlugin.render( scene, camera );
			lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

			// Generate mipmap if we're using any kind of mipmap filtering

			if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

				updateRenderTargetMipmap( renderTarget );

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.setDepthTest( true );
			state.setDepthWrite( true );
			state.setColorWrite( true );

			// _gl.finish();

		};

		function projectObject( object ) {

			if ( object.visible === false ) return;

			if ( object instanceof THREE.Scene || object instanceof THREE.Group ) {

				// skip

			} else {

				initObject( object );

				if ( object instanceof THREE.Light ) {

					lights.push( object );

				} else if ( object instanceof THREE.Sprite ) {

					sprites.push( object );

				} else if ( object instanceof THREE.LensFlare ) {

					lensFlares.push( object );

				} else {

					var webglObjects = _webglObjects[ object.id ];

					if ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

						for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

							var webglObject = webglObjects[ i ];

							unrollBufferMaterial( webglObject );

							webglObject.render = true;

							if ( _this.sortObjects === true ) {

								_vector3.setFromMatrixPosition( object.matrixWorld );
								_vector3.applyProjection( _projScreenMatrix );

								webglObject.z = _vector3.z;

							}

						}

					}

				}

			}

			for ( var i = 0, l = object.children.length; i < l; i ++ ) {

				projectObject( object.children[ i ] );

			}

		}

		function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

			var material;

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var webglObject = renderList[ i ];

				var object = webglObject.object;
				var buffer = webglObject.buffer;

				setupMatrices( object, camera );

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject.material;

					if ( ! material ) continue;

					setMaterial( material );

				}

				_this.setMaterialFaces( material );

				if ( buffer instanceof THREE.BufferGeometry ) {

					_this.renderBufferDirect( camera, lights, fog, material, buffer, object );

				} else {

					_this.renderBuffer( camera, lights, fog, material, buffer, object );

				}

			}

		}

		function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, overrideMaterial ) {

			var material;

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var webglObject = renderList[ i ];
				var object = webglObject.object;

				if ( object.visible ) {

					if ( overrideMaterial ) {

						material = overrideMaterial;

					} else {

						material = webglObject[ materialType ];

						if ( ! material ) continue;

						setMaterial( material );

					}

					_this.renderImmediateObject( camera, lights, fog, material, object );

				}

			}

		}

		this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

			var program = setProgram( camera, lights, fog, material, object );

			_currentGeometryProgram = '';

			_this.setMaterialFaces( material );

			if ( object.immediateRenderCallback ) {

				object.immediateRenderCallback( program, _gl, _frustum );

			} else {

				object.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );

			}

		};

		function unrollImmediateBufferMaterial ( globject ) {

			var object = globject.object,
				material = object.material;

			if ( material.transparent ) {

				globject.transparent = material;
				globject.opaque = null;

			} else {

				globject.opaque = material;
				globject.transparent = null;

			}

		}

		function unrollBufferMaterial ( globject ) {

			var object = globject.object;
			var buffer = globject.buffer;

			var geometry = object.geometry;
			var material = object.material;

			if ( material instanceof THREE.MeshFaceMaterial ) {

				var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;

				material = material.materials[ materialIndex ];

				globject.material = material;

				if ( material.transparent ) {

					transparentObjects.push( globject );

				} else {

					opaqueObjects.push( globject );

				}

			} else if ( material ) {

				globject.material = material;

				if ( material.transparent ) {

					transparentObjects.push( globject );

				} else {

					opaqueObjects.push( globject );

				}

			}

		}

		function initObject( object ) {

			if ( object.__webglInit === undefined ) {

				object.__webglInit = true;
				object._modelViewMatrix = new THREE.Matrix4();
				object._normalMatrix = new THREE.Matrix3();

				object.addEventListener( 'removed', onObjectRemoved );

			}

			var geometry = object.geometry;

			if ( geometry === undefined ) {

				// ImmediateRenderObject

			} else if ( geometry.__webglInit === undefined ) {

				geometry.__webglInit = true;
				geometry.addEventListener( 'dispose', onGeometryDispose );

				if ( geometry instanceof THREE.BufferGeometry ) {

					_this.info.memory.geometries ++;

				} else if ( object instanceof THREE.Mesh ) {

					initGeometryGroups( object, geometry );

				} else if ( object instanceof THREE.Line ) {

					if ( geometry.__webglVertexBuffer === undefined ) {

						createLineBuffers( geometry );
						initLineBuffers( geometry, object );

						geometry.verticesNeedUpdate = true;
						geometry.colorsNeedUpdate = true;
						geometry.lineDistancesNeedUpdate = true;

					}

				} else if ( object instanceof THREE.PointCloud ) {

					if ( geometry.__webglVertexBuffer === undefined ) {

						createParticleBuffers( geometry );
						initParticleBuffers( geometry, object );

						geometry.verticesNeedUpdate = true;
						geometry.colorsNeedUpdate = true;

					}

				}

			}

			if ( object.__webglActive === undefined) {

				object.__webglActive = true;

				if ( object instanceof THREE.Mesh ) {

					if ( geometry instanceof THREE.BufferGeometry ) {

						addBuffer( _webglObjects, geometry, object );

					} else if ( geometry instanceof THREE.Geometry ) {

						var geometryGroupsList = geometryGroups[ geometry.id ];

						for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {

							addBuffer( _webglObjects, geometryGroupsList[ i ], object );

						}

					}

				} else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {

					addBuffer( _webglObjects, geometry, object );

				} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

					addBufferImmediate( _webglObjectsImmediate, object );

				}

			}

		}

		// Geometry splitting

		var geometryGroups = {};
		var geometryGroupCounter = 0;

		function makeGroups( geometry, usesFaceMaterial ) {

			var maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;

			var groupHash, hash_map = {};

			var numMorphTargets = geometry.morphTargets.length;
			var numMorphNormals = geometry.morphNormals.length;

			var group;
			var groups = {};
			var groupsList = [];

			for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

				var face = geometry.faces[ f ];
				var materialIndex = usesFaceMaterial ? face.materialIndex : 0;

				if ( ! ( materialIndex in hash_map ) ) {

					hash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };

				}

				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

				if ( ! ( groupHash in groups ) ) {

					group = {
						id: geometryGroupCounter ++,
						faces3: [],
						materialIndex: materialIndex,
						vertices: 0,
						numMorphTargets: numMorphTargets,
						numMorphNormals: numMorphNormals
					};

					groups[ groupHash ] = group;
					groupsList.push( group );

				}

				if ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {

					hash_map[ materialIndex ].counter += 1;
					groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

					if ( ! ( groupHash in groups ) ) {

						group = {
							id: geometryGroupCounter ++,
							faces3: [],
							materialIndex: materialIndex,
							vertices: 0,
							numMorphTargets: numMorphTargets,
							numMorphNormals: numMorphNormals
						};

						groups[ groupHash ] = group;
						groupsList.push( group );

					}

				}

				groups[ groupHash ].faces3.push( f );
				groups[ groupHash ].vertices += 3;

			}

			return groupsList;

		}

		function initGeometryGroups( object, geometry ) {

			var material = object.material, addBuffers = false;

			if ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {

				delete _webglObjects[ object.id ];

				geometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial );

				geometry.groupsNeedUpdate = false;

			}

			var geometryGroupsList = geometryGroups[ geometry.id ];

			// create separate VBOs per geometry chunk

			for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

				var geometryGroup = geometryGroupsList[ i ];

				// initialise VBO on the first access

				if ( geometryGroup.__webglVertexBuffer === undefined ) {

					createMeshBuffers( geometryGroup );
					initMeshBuffers( geometryGroup, object );

					geometry.verticesNeedUpdate = true;
					geometry.morphTargetsNeedUpdate = true;
					geometry.elementsNeedUpdate = true;
					geometry.uvsNeedUpdate = true;
					geometry.normalsNeedUpdate = true;
					geometry.tangentsNeedUpdate = true;
					geometry.colorsNeedUpdate = true;

					addBuffers = true;

				} else {

					addBuffers = false;

				}

				if ( addBuffers || object.__webglActive === undefined ) {

					addBuffer( _webglObjects, geometryGroup, object );

				}

			}

			object.__webglActive = true;

		}

		function addBuffer( objlist, buffer, object ) {

			var id = object.id;
			objlist[id] = objlist[id] || [];
			objlist[id].push(
				{
					id: id,
					buffer: buffer,
					object: object,
					material: null,
					z: 0
				}
			);

		};

		function addBufferImmediate( objlist, object ) {

			objlist.push(
				{
					id: null,
					object: object,
					opaque: null,
					transparent: null,
					z: 0
				}
			);

		};

		// Objects updates

		function updateObject( object ) {

			var geometry = object.geometry;

			if ( geometry instanceof THREE.BufferGeometry ) {

				var attributes = geometry.attributes;
				var attributesKeys = geometry.attributesKeys;

				for ( var i = 0, l = attributesKeys.length; i < l; i ++ ) {

					var key = attributesKeys[ i ];
					var attribute = attributes[ key ];
					var bufferType = ( key === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;

					if ( attribute.buffer === undefined ) {

						attribute.buffer = _gl.createBuffer();
						_gl.bindBuffer( bufferType, attribute.buffer );
						_gl.bufferData( bufferType, attribute.array, ( attribute instanceof THREE.DynamicBufferAttribute ) ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW );

						attribute.needsUpdate = false;

					} else if ( attribute.needsUpdate === true ) {

						_gl.bindBuffer( bufferType, attribute.buffer );

						if ( attribute.updateRange === undefined || attribute.updateRange.count === -1 ) { // Not using update ranges

							_gl.bufferSubData( bufferType, 0, attribute.array );

						} else if ( attribute.updateRange.count === 0 ) {

							console.error( 'THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.' );

						} else {

							_gl.bufferSubData( bufferType, attribute.updateRange.offset * attribute.array.BYTES_PER_ELEMENT,
											   attribute.array.subarray( attribute.updateRange.offset, attribute.updateRange.offset + attribute.updateRange.count ) );

							attribute.updateRange.count = 0; // reset range

						}

						attribute.needsUpdate = false;

					}

				}

			} else if ( object instanceof THREE.Mesh ) {

				// check all geometry groups

				if ( geometry.groupsNeedUpdate === true ) {

					initGeometryGroups( object, geometry );

				}

				var geometryGroupsList = geometryGroups[ geometry.id ];

				for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

					var geometryGroup = geometryGroupsList[ i ];
					var material = getBufferMaterial( object, geometryGroup );

					var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

					if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
						 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
						 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

						setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );

					}

				}

				geometry.verticesNeedUpdate = false;
				geometry.morphTargetsNeedUpdate = false;
				geometry.elementsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.tangentsNeedUpdate = false;

				material.attributes && clearCustomAttributes( material );

			} else if ( object instanceof THREE.Line ) {

				var material = getBufferMaterial( object, geometry );
				var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

					setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

				}

				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.lineDistancesNeedUpdate = false;

				material.attributes && clearCustomAttributes( material );

			} else if ( object instanceof THREE.PointCloud ) {

				var material = getBufferMaterial( object, geometry );
				var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || customAttributesDirty ) {

					setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );

				}

				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;

				material.attributes && clearCustomAttributes( material );

			}

		}

		// Objects updates - custom attributes check

		function areCustomAttributesDirty( material ) {

			for ( var name in material.attributes ) {

				if ( material.attributes[ name ].needsUpdate ) return true;

			}

			return false;

		}

		function clearCustomAttributes( material ) {

			for ( var name in material.attributes ) {

				material.attributes[ name ].needsUpdate = false;

			}

		}

		// Objects removal

		function removeObject( object ) {

			if ( object instanceof THREE.Mesh  ||
				 object instanceof THREE.PointCloud ||
				 object instanceof THREE.Line ) {

				delete _webglObjects[ object.id ];

			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

				removeInstances( _webglObjectsImmediate, object );

			}

			delete object.__webglInit;
			delete object._modelViewMatrix;
			delete object._normalMatrix;

			delete object.__webglActive;

		}

		function removeInstances( objlist, object ) {

			for ( var o = objlist.length - 1; o >= 0; o -- ) {

				if ( objlist[ o ].object === object ) {

					objlist.splice( o, 1 );

				}

			}

		}

		// Materials

		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointCloudMaterial: 'particle_basic'
		};

		function initMaterial( material, lights, fog, object ) {

			material.addEventListener( 'dispose', onMaterialDispose );

			var shaderID = shaderIDs[ material.type ];

			if ( shaderID ) {

				var shader = THREE.ShaderLib[ shaderID ];

				material.__webglShader = {
					uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				}

			} else {

				material.__webglShader = {
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				}

			}

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxLightCount = allocateLights( lights );
			var maxShadows = allocateShadows( lights );
			var maxBones = allocateBones( object );

			var parameters = {

				precision: _precision,
				supportsVertexTextures: _supportsVertexTextures,

				map: !! material.map,
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				lightMap: !! material.lightMap,
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				combine: material.combine,

				vertexColors: material.vertexColors,

				fog: fog,
				useFog: material.fog,
				fogExp: fog instanceof THREE.FogExp2,

				flatShading: material.shading === THREE.FlatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: _logarithmicDepthBuffer,

				skinning: material.skinning,
				maxBones: maxBones,
				useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: _this.maxMorphTargets,
				maxMorphNormals: _this.maxMorphNormals,

				maxDirLights: maxLightCount.directional,
				maxPointLights: maxLightCount.point,
				maxSpotLights: maxLightCount.spot,
				maxHemiLights: maxLightCount.hemi,

				maxShadows: maxShadows,
				shadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,
				shadowMapType: _this.shadowMapType,
				shadowMapDebug: _this.shadowMapDebug,
				shadowMapCascade: _this.shadowMapCascade,

				alphaTest: material.alphaTest,
				metal: material.metal,
				wrapAround: material.wrapAround,
				doubleSided: material.side === THREE.DoubleSide,
				flipSided: material.side === THREE.BackSide

			};

			// Generate code

			var chunks = [];

			if ( shaderID ) {

				chunks.push( shaderID );

			} else {

				chunks.push( material.fragmentShader );
				chunks.push( material.vertexShader );

			}

			if ( material.defines !== undefined ) {

				for ( var name in material.defines ) {

					chunks.push( name );
					chunks.push( material.defines[ name ] );

				}

			}

			for ( var name in parameters ) {

				chunks.push( name );
				chunks.push( parameters[ name ] );

			}

			var code = chunks.join();

			var program;

			// Check if code has been already compiled

			for ( var p = 0, pl = _programs.length; p < pl; p ++ ) {

				var programInfo = _programs[ p ];

				if ( programInfo.code === code ) {

					program = programInfo;
					program.usedTimes ++;

					break;

				}

			}

			if ( program === undefined ) {

				program = new THREE.WebGLProgram( _this, code, material, parameters );
				_programs.push( program );

				_this.info.memory.programs = _programs.length;

			}

			material.program = program;

			var attributes = program.attributes;

			if ( material.morphTargets ) {

				material.numSupportedMorphTargets = 0;

				var id, base = 'morphTarget';

				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

					id = base + i;

					if ( attributes[ id ] >= 0 ) {

						material.numSupportedMorphTargets ++;

					}

				}

			}

			if ( material.morphNormals ) {

				material.numSupportedMorphNormals = 0;

				var id, base = 'morphNormal';

				for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

					id = base + i;

					if ( attributes[ id ] >= 0 ) {

						material.numSupportedMorphNormals ++;

					}

				}

			}

			material.uniformsList = [];

			for ( var u in material.__webglShader.uniforms ) {

				var location = material.program.uniforms[ u ];

				if ( location ) {
					material.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );
				}

			}

		}

		function setMaterial( material ) {

			if ( material.transparent === true ) {

				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

			} else {

				state.setBlending( THREE.NoBlending );

			}

			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );
			state.setColorWrite( material.colorWrite );
			state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		}

		function setProgram( camera, lights, fog, material, object ) {

			_usedTextureUnits = 0;

			if ( material.needsUpdate ) {

				if ( material.program ) deallocateMaterial( material );

				initMaterial( material, lights, fog, object );
				material.needsUpdate = false;

			}

			if ( material.morphTargets ) {

				if ( ! object.__webglMorphTargetInfluences ) {

					object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );

				}

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var program = material.program,
				p_uniforms = program.uniforms,
				m_uniforms = material.__webglShader.uniforms;

			if ( program.id !== _currentProgram ) {

				_gl.useProgram( program.program );
				_currentProgram = program.id;

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				if ( _currentMaterialId === -1 ) refreshLights = true;
				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || camera !== _currentCamera ) {

				_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

				if ( _logarithmicDepthBuffer ) {

					_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}


				if ( camera !== _currentCamera ) _currentCamera = camera;

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material instanceof THREE.ShaderMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material.envMap ) {

					if ( p_uniforms.cameraPosition !== null ) {

						_vector3.setFromMatrixPosition( camera.matrixWorld );
						_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

					}

				}

				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.ShaderMaterial ||
					 material.skinning ) {

					if ( p_uniforms.viewMatrix !== null ) {

						_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

					}

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen

			if ( material.skinning ) {

				if ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

				}

				if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

				}

				if ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {

					if ( p_uniforms.boneTexture !== null ) {

						var textureUnit = getTextureUnit();

						_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
						_this.setTexture( object.skeleton.boneTexture, textureUnit );

					}

					if ( p_uniforms.boneTextureWidth !== null ) {

						_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

					}

					if ( p_uniforms.boneTextureHeight !== null ) {

						_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

					}

				} else if ( object.skeleton && object.skeleton.boneMatrices ) {

					if ( p_uniforms.boneGlobalMatrices !== null ) {

						_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

					}

				}

			}

			if ( refreshMaterial ) {

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					refreshUniformsFog( m_uniforms, fog );

				}

				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material.lights ) {

					if ( _lightsNeedUpdate ) {

						refreshLights = true;
						setupLights( lights );
						_lightsNeedUpdate = false;
					}

					if ( refreshLights ) {
						refreshUniformsLights( m_uniforms, _lights );
						markUniformsLightsNeedsUpdate( m_uniforms, true );
					} else {
						markUniformsLightsNeedsUpdate( m_uniforms, false );
					}

				}

				if ( material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshPhongMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

				}

				// refresh single material specific uniforms

				if ( material instanceof THREE.LineBasicMaterial ) {

					refreshUniformsLine( m_uniforms, material );

				} else if ( material instanceof THREE.LineDashedMaterial ) {

					refreshUniformsLine( m_uniforms, material );
					refreshUniformsDash( m_uniforms, material );

				} else if ( material instanceof THREE.PointCloudMaterial ) {

					refreshUniformsParticle( m_uniforms, material );

				} else if ( material instanceof THREE.MeshPhongMaterial ) {

					refreshUniformsPhong( m_uniforms, material );

				} else if ( material instanceof THREE.MeshLambertMaterial ) {

					refreshUniformsLambert( m_uniforms, material );

				} else if ( material instanceof THREE.MeshDepthMaterial ) {

					m_uniforms.mNear.value = camera.near;
					m_uniforms.mFar.value = camera.far;
					m_uniforms.opacity.value = material.opacity;

				} else if ( material instanceof THREE.MeshNormalMaterial ) {

					m_uniforms.opacity.value = material.opacity;

				}

				if ( object.receiveShadow && ! material._shadowPass ) {

					refreshUniformsShadow( m_uniforms, lights );

				}

				// load common uniforms

				loadUniformsGeneric( material.uniformsList );

			}

			loadUniformsMatrices( p_uniforms, object );

			if ( p_uniforms.modelMatrix !== null ) {

				_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

			}

			return program;

		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon ( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			uniforms.diffuse.value = material.color;

			uniforms.map.value = material.map;
			uniforms.lightMap.value = material.lightMap;
			uniforms.specularMap.value = material.specularMap;
			uniforms.alphaMap.value = material.alphaMap;

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );

			}

			// uv repeat and offset setting priorities
			//  1. color map
			//  2. specular map
			//  3. normal map
			//  4. bump map
			//  5. alpha map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;

				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

			}

			uniforms.envMap.value = material.envMap;
			uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;

		}

		function refreshUniformsLine ( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash ( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsParticle ( uniforms, material ) {

			uniforms.psColor.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size;
			uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

			uniforms.map.value = material.map;

			if ( material.map !== null ) {

				var offset = material.map.offset;
				var repeat = material.map.repeat;

				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

			}

		}

		function refreshUniformsFog ( uniforms, fog ) {

			uniforms.fogColor.value = fog.color;

			if ( fog instanceof THREE.Fog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog instanceof THREE.FogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshUniformsPhong ( uniforms, material ) {

			uniforms.shininess.value = material.shininess;

			uniforms.emissive.value = material.emissive;
			uniforms.specular.value = material.specular;

			if ( material.wrapAround ) {

				uniforms.wrapRGB.value.copy( material.wrapRGB );

			}

		}

		function refreshUniformsLambert ( uniforms, material ) {

			uniforms.emissive.value = material.emissive;

			if ( material.wrapAround ) {

				uniforms.wrapRGB.value.copy( material.wrapRGB );

			}

		}

		function refreshUniformsLights ( uniforms, lights ) {

			uniforms.ambientLightColor.value = lights.ambient;

			uniforms.directionalLightColor.value = lights.directional.colors;
			uniforms.directionalLightDirection.value = lights.directional.positions;

			uniforms.pointLightColor.value = lights.point.colors;
			uniforms.pointLightPosition.value = lights.point.positions;
			uniforms.pointLightDistance.value = lights.point.distances;
			uniforms.pointLightDecay.value = lights.point.decays;

			uniforms.spotLightColor.value = lights.spot.colors;
			uniforms.spotLightPosition.value = lights.spot.positions;
			uniforms.spotLightDistance.value = lights.spot.distances;
			uniforms.spotLightDirection.value = lights.spot.directions;
			uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
			uniforms.spotLightExponent.value = lights.spot.exponents;
			uniforms.spotLightDecay.value = lights.spot.decays;

			uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
			uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
			uniforms.hemisphereLightDirection.value = lights.hemi.positions;

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate ( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;

			uniforms.directionalLightColor.needsUpdate = value;
			uniforms.directionalLightDirection.needsUpdate = value;

			uniforms.pointLightColor.needsUpdate = value;
			uniforms.pointLightPosition.needsUpdate = value;
			uniforms.pointLightDistance.needsUpdate = value;
			uniforms.pointLightDecay.needsUpdate = value;

			uniforms.spotLightColor.needsUpdate = value;
			uniforms.spotLightPosition.needsUpdate = value;
			uniforms.spotLightDistance.needsUpdate = value;
			uniforms.spotLightDirection.needsUpdate = value;
			uniforms.spotLightAngleCos.needsUpdate = value;
			uniforms.spotLightExponent.needsUpdate = value;
			uniforms.spotLightDecay.needsUpdate = value;

			uniforms.hemisphereLightSkyColor.needsUpdate = value;
			uniforms.hemisphereLightGroundColor.needsUpdate = value;
			uniforms.hemisphereLightDirection.needsUpdate = value;

		}

		function refreshUniformsShadow ( uniforms, lights ) {

			if ( uniforms.shadowMatrix ) {

				var j = 0;

				for ( var i = 0, il = lights.length; i < il; i ++ ) {

					var light = lights[ i ];

					if ( ! light.castShadow ) continue;

					if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

						uniforms.shadowMap.value[ j ] = light.shadowMap;
						uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

						uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

						uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
						uniforms.shadowBias.value[ j ] = light.shadowBias;

						j ++;

					}

				}

			}

		}

		// Uniforms (load to GPU)

		function loadUniformsMatrices ( uniforms, object ) {

			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

			if ( uniforms.normalMatrix ) {

				_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

			}

		}

		function getTextureUnit() {

			var textureUnit = _usedTextureUnits;

			if ( textureUnit >= _maxTextures ) {

				THREE.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );

			}

			_usedTextureUnits += 1;

			return textureUnit;

		}

		function loadUniformsGeneric ( uniforms ) {

			var texture, textureUnit, offset;

			for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

				var uniform = uniforms[ j ][ 0 ];

				// needsUpdate property is not added to all uniforms.
				if ( uniform.needsUpdate === false ) continue;

				var type = uniform.type;
				var value = uniform.value;
				var location = uniforms[ j ][ 1 ];

				switch ( type ) {

					case '1i':
						_gl.uniform1i( location, value );
						break;

					case '1f':
						_gl.uniform1f( location, value );
						break;

					case '2f':
						_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
						break;

					case '3f':
						_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
						break;

					case '4f':
						_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
						break;

					case '1iv':
						_gl.uniform1iv( location, value );
						break;

					case '3iv':
						_gl.uniform3iv( location, value );
						break;

					case '1fv':
						_gl.uniform1fv( location, value );
						break;

					case '2fv':
						_gl.uniform2fv( location, value );
						break;

					case '3fv':
						_gl.uniform3fv( location, value );
						break;

					case '4fv':
						_gl.uniform4fv( location, value );
						break;

					case 'Matrix3fv':
						_gl.uniformMatrix3fv( location, false, value );
						break;

					case 'Matrix4fv':
						_gl.uniformMatrix4fv( location, false, value );
						break;

					//

					case 'i':

						// single integer
						_gl.uniform1i( location, value );

						break;

					case 'f':

						// single float
						_gl.uniform1f( location, value );

						break;

					case 'v2':

						// single THREE.Vector2
						_gl.uniform2f( location, value.x, value.y );

						break;

					case 'v3':

						// single THREE.Vector3
						_gl.uniform3f( location, value.x, value.y, value.z );

						break;

					case 'v4':

						// single THREE.Vector4
						_gl.uniform4f( location, value.x, value.y, value.z, value.w );

						break;

					case 'c':

						// single THREE.Color
						_gl.uniform3f( location, value.r, value.g, value.b );

						break;

					case 'iv1':

						// flat array of integers (JS or typed array)
						_gl.uniform1iv( location, value );

						break;

					case 'iv':

						// flat array of integers with 3 x N size (JS or typed array)
						_gl.uniform3iv( location, value );

						break;

					case 'fv1':

						// flat array of floats (JS or typed array)
						_gl.uniform1fv( location, value );

						break;

					case 'fv':

						// flat array of floats with 3 x N size (JS or typed array)
						_gl.uniform3fv( location, value );

						break;

					case 'v2v':

						// array of THREE.Vector2

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 2 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							offset = i * 2;

							uniform._array[ offset ]   = value[ i ].x;
							uniform._array[ offset + 1 ] = value[ i ].y;

						}

						_gl.uniform2fv( location, uniform._array );

						break;

					case 'v3v':

						// array of THREE.Vector3

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 3 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							offset = i * 3;

							uniform._array[ offset ]   = value[ i ].x;
							uniform._array[ offset + 1 ] = value[ i ].y;
							uniform._array[ offset + 2 ] = value[ i ].z;

						}

						_gl.uniform3fv( location, uniform._array );

						break;

					case 'v4v':

						// array of THREE.Vector4

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 4 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							offset = i * 4;

							uniform._array[ offset ]   = value[ i ].x;
							uniform._array[ offset + 1 ] = value[ i ].y;
							uniform._array[ offset + 2 ] = value[ i ].z;
							uniform._array[ offset + 3 ] = value[ i ].w;

						}

						_gl.uniform4fv( location, uniform._array );

						break;

					case 'm3':

						// single THREE.Matrix3
						_gl.uniformMatrix3fv( location, false, value.elements );

						break;

					case 'm3v':

						// array of THREE.Matrix3

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 9 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

						}

						_gl.uniformMatrix3fv( location, false, uniform._array );

						break;

					case 'm4':

						// single THREE.Matrix4
						_gl.uniformMatrix4fv( location, false, value.elements );

						break;

					case 'm4v':

						// array of THREE.Matrix4

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 16 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

						}

						_gl.uniformMatrix4fv( location, false, uniform._array );

						break;

					case 't':

						// single THREE.Texture (2d or cube)

						texture = value;
						textureUnit = getTextureUnit();

						_gl.uniform1i( location, textureUnit );

						if ( ! texture ) continue;

						if ( texture instanceof THREE.CubeTexture ||
						   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/

							setCubeTexture( texture, textureUnit );

						} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

							setCubeTextureDynamic( texture, textureUnit );

						} else {

							_this.setTexture( texture, textureUnit );

						}

						break;

					case 'tv':

						// array of THREE.Texture (2d)

						if ( uniform._array === undefined ) {

							uniform._array = [];

						}

						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

							uniform._array[ i ] = getTextureUnit();

						}

						_gl.uniform1iv( location, uniform._array );

						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

							texture = uniform.value[ i ];
							textureUnit = uniform._array[ i ];

							if ( ! texture ) continue;

							_this.setTexture( texture, textureUnit );

						}

						break;

					default:

						THREE.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

				}

			}

		}

		function setupMatrices ( object, camera ) {

			object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

		}

		function setColorLinear( array, offset, color, intensity ) {

			array[ offset ]     = color.r * intensity;
			array[ offset + 1 ] = color.g * intensity;
			array[ offset + 2 ] = color.b * intensity;

		}

		function setupLights ( lights ) {

			var l, ll, light,
			r = 0, g = 0, b = 0,
			color, skyColor, groundColor,
			intensity,
			distance,

			zlights = _lights,

			dirColors = zlights.directional.colors,
			dirPositions = zlights.directional.positions,

			pointColors = zlights.point.colors,
			pointPositions = zlights.point.positions,
			pointDistances = zlights.point.distances,
			pointDecays = zlights.point.decays,

			spotColors = zlights.spot.colors,
			spotPositions = zlights.spot.positions,
			spotDistances = zlights.spot.distances,
			spotDirections = zlights.spot.directions,
			spotAnglesCos = zlights.spot.anglesCos,
			spotExponents = zlights.spot.exponents,
			spotDecays = zlights.spot.decays,

			hemiSkyColors = zlights.hemi.skyColors,
			hemiGroundColors = zlights.hemi.groundColors,
			hemiPositions = zlights.hemi.positions,

			dirLength = 0,
			pointLength = 0,
			spotLength = 0,
			hemiLength = 0,

			dirCount = 0,
			pointCount = 0,
			spotCount = 0,
			hemiCount = 0,

			dirOffset = 0,
			pointOffset = 0,
			spotOffset = 0,
			hemiOffset = 0;

			for ( l = 0, ll = lights.length; l < ll; l ++ ) {

				light = lights[ l ];

				if ( light.onlyShadow ) continue;

				color = light.color;
				intensity = light.intensity;
				distance = light.distance;

				if ( light instanceof THREE.AmbientLight ) {

					if ( ! light.visible ) continue;

					r += color.r;
					g += color.g;
					b += color.b;

				} else if ( light instanceof THREE.DirectionalLight ) {

					dirCount += 1;

					if ( ! light.visible ) continue;

					_direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.normalize();

					dirOffset = dirLength * 3;

					dirPositions[ dirOffset ]     = _direction.x;
					dirPositions[ dirOffset + 1 ] = _direction.y;
					dirPositions[ dirOffset + 2 ] = _direction.z;

					setColorLinear( dirColors, dirOffset, color, intensity );

					dirLength += 1;

				} else if ( light instanceof THREE.PointLight ) {

					pointCount += 1;

					if ( ! light.visible ) continue;

					pointOffset = pointLength * 3;

					setColorLinear( pointColors, pointOffset, color, intensity );

					_vector3.setFromMatrixPosition( light.matrixWorld );

					pointPositions[ pointOffset ]     = _vector3.x;
					pointPositions[ pointOffset + 1 ] = _vector3.y;
					pointPositions[ pointOffset + 2 ] = _vector3.z;

					// distance is 0 if decay is 0, because there is no attenuation at all.
					pointDistances[ pointLength ] = distance;
					pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

					pointLength += 1;

				} else if ( light instanceof THREE.SpotLight ) {

					spotCount += 1;

					if ( ! light.visible ) continue;

					spotOffset = spotLength * 3;

					setColorLinear( spotColors, spotOffset, color, intensity );

					_direction.setFromMatrixPosition( light.matrixWorld );

					spotPositions[ spotOffset ]     = _direction.x;
					spotPositions[ spotOffset + 1 ] = _direction.y;
					spotPositions[ spotOffset + 2 ] = _direction.z;

					spotDistances[ spotLength ] = distance;

					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.normalize();

					spotDirections[ spotOffset ]     = _direction.x;
					spotDirections[ spotOffset + 1 ] = _direction.y;
					spotDirections[ spotOffset + 2 ] = _direction.z;

					spotAnglesCos[ spotLength ] = Math.cos( light.angle );
					spotExponents[ spotLength ] = light.exponent;
					spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

					spotLength += 1;

				} else if ( light instanceof THREE.HemisphereLight ) {

					hemiCount += 1;

					if ( ! light.visible ) continue;

					_direction.setFromMatrixPosition( light.matrixWorld );
					_direction.normalize();

					hemiOffset = hemiLength * 3;

					hemiPositions[ hemiOffset ]     = _direction.x;
					hemiPositions[ hemiOffset + 1 ] = _direction.y;
					hemiPositions[ hemiOffset + 2 ] = _direction.z;

					skyColor = light.color;
					groundColor = light.groundColor;

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

					hemiLength += 1;

				}

			}

			// null eventual remains from removed lights
			// (this is to avoid if in shader)

			for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
			for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
			for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

			zlights.directional.length = dirLength;
			zlights.point.length = pointLength;
			zlights.spot.length = spotLength;
			zlights.hemi.length = hemiLength;

			zlights.ambient[ 0 ] = r;
			zlights.ambient[ 1 ] = g;
			zlights.ambient[ 2 ] = b;

		}

		// GL state setting

		this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

			if ( cullFace === THREE.CullFaceNone ) {

				_gl.disable( _gl.CULL_FACE );

			} else {

				if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

					_gl.frontFace( _gl.CW );

				} else {

					_gl.frontFace( _gl.CCW );

				}

				if ( cullFace === THREE.CullFaceBack ) {

					_gl.cullFace( _gl.BACK );

				} else if ( cullFace === THREE.CullFaceFront ) {

					_gl.cullFace( _gl.FRONT );

				} else {

					_gl.cullFace( _gl.FRONT_AND_BACK );

				}

				_gl.enable( _gl.CULL_FACE );

			}

		};

		this.setMaterialFaces = function ( material ) {

			state.setDoubleSided( material.side === THREE.DoubleSide );
			state.setFlipSided( material.side === THREE.BackSide );

		};

		// Textures

		function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

			var extension;

			if ( isImagePowerOfTwo ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

			} else {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

				if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

					THREE.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

					THREE.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );

				}

			}

			extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension && texture.type !== THREE.FloatType && texture.type !== THREE.HalfFloatType ) {

				if ( texture.anisotropy > 1 || texture.__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
					texture.__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		this.uploadTexture = function ( texture ) {

			if ( texture.__webglInit === undefined ) {

				texture.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				texture.__webglTexture = _gl.createTexture();

				_this.info.memory.textures ++;

			}

			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			texture.image = clampToMaxSize( texture.image, _maxTextureSize );

			var image = texture.image,
			isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture instanceof THREE.DataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture instanceof THREE.CompressedTexture ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

						if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

							_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							THREE.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

						}

					} else {

						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

			} else { // regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				}

			}

			if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			texture.needsUpdate = false;

			if ( texture.onUpdate ) texture.onUpdate();

		};

		this.setTexture = function ( texture, slot ) {

			_gl.activeTexture( _gl.TEXTURE0 + slot );

			if ( texture.needsUpdate ) {

				_this.uploadTexture( texture );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

			}

		};

		function clampToMaxSize ( image, maxSize ) {

			if ( image.width > maxSize || image.height > maxSize ) {

				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.

				var scale = maxSize / Math.max( image.width, image.height );

				var canvas = document.createElement( 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

				THREE.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

				return canvas;

			}

			return image;

		}

		function setCubeTexture ( texture, slot ) {

			if ( texture.image.length === 6 ) {

				if ( texture.needsUpdate ) {

					if ( ! texture.image.__webglTextureCube ) {

						texture.addEventListener( 'dispose', onTextureDispose );

						texture.image.__webglTextureCube = _gl.createTexture();

						_this.info.memory.textures ++;

					}

					_gl.activeTexture( _gl.TEXTURE0 + slot );
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

					var isCompressed = texture instanceof THREE.CompressedTexture;
					var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

					var cubeImage = [];

					for ( var i = 0; i < 6; i ++ ) {

						if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

						} else {

							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

						}

					}

					var image = cubeImage[ 0 ],
					isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
					glFormat = paramThreeToGL( texture.format ),
					glType = paramThreeToGL( texture.type );

					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed ) {

							if ( isDataTexture ) {

								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							} else {

								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							var mipmap, mipmaps = cubeImage[ i ].mipmaps;

							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

								mipmap = mipmaps[ j ];

								if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

									if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

										_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									} else {

										THREE.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

									}

								} else {

									_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

					if ( texture.generateMipmaps && isImagePowerOfTwo ) {

						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

					}

					texture.needsUpdate = false;

					if ( texture.onUpdate ) texture.onUpdate();

				} else {

					_gl.activeTexture( _gl.TEXTURE0 + slot );
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				}

			}

		}

		function setCubeTextureDynamic ( texture, slot ) {

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

		}

		// Render targets

		function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

		}

		function setupRenderBuffer ( renderbuffer, renderTarget  ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			/* For some reason this is not working. Defaulting to RGBA4.
			} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
			*/
			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

			}

		}

		this.setRenderTarget = function ( renderTarget ) {

			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

			if ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {

				if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
				if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

				renderTarget.__webglTexture = _gl.createTexture();

				_this.info.memory.textures ++;

				// Setup texture, create render and frame buffers

				var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
					glFormat = paramThreeToGL( renderTarget.format ),
					glType = paramThreeToGL( renderTarget.type );

				if ( isCube ) {

					renderTarget.__webglFramebuffer = [];
					renderTarget.__webglRenderbuffer = [];

					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
						renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

						_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

						setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
						setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

					}

					if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				} else {

					renderTarget.__webglFramebuffer = _gl.createFramebuffer();

					if ( renderTarget.shareDepthFrom ) {

						renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

					} else {

						renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

					}

					_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

					if ( renderTarget.shareDepthFrom ) {

						if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

						} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

						}

					} else {

						setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

					}

					if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

				}

				// Release everything

				if ( isCube ) {

					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

				} else {

					_gl.bindTexture( _gl.TEXTURE_2D, null );

				}

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

			var framebuffer, width, height, vx, vy;

			if ( renderTarget ) {

				if ( isCube ) {

					framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

				} else {

					framebuffer = renderTarget.__webglFramebuffer;

				}

				width = renderTarget.width;
				height = renderTarget.height;

				vx = 0;
				vy = 0;

			} else {

				framebuffer = null;

				width = _viewportWidth;
				height = _viewportHeight;

				vx = _viewportX;
				vy = _viewportY;

			}

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.viewport( vx, vy, width, height );

				_currentFramebuffer = framebuffer;

			}

			_currentWidth = width;
			_currentHeight = height;

		};

		this.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {

			if ( ! ( renderTarget instanceof THREE.WebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			if ( renderTarget.__webglFramebuffer ) {

				if ( renderTarget.format !== THREE.RGBAFormat ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );
					return;

				}

				var restore = false;

				if ( renderTarget.__webglFramebuffer !== _currentFramebuffer ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTarget.__webglFramebuffer );

					restore = true;

				}

				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

					_gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

				if ( restore ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

				}

			}

		};

		function updateRenderTargetMipmap ( renderTarget ) {

			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_2D );
				_gl.bindTexture( _gl.TEXTURE_2D, null );

			}

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback ( f ) {

			if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		// Map three.js constants to WebGL constants

		function paramThreeToGL ( p ) {

			var extension;

			if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
			if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
			if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

			if ( p === THREE.NearestFilter ) return _gl.NEAREST;
			if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
			if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

			if ( p === THREE.LinearFilter ) return _gl.LINEAR;
			if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
			if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

			if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
			if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

			if ( p === THREE.ByteType ) return _gl.BYTE;
			if ( p === THREE.ShortType ) return _gl.SHORT;
			if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
			if ( p === THREE.IntType ) return _gl.INT;
			if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
			if ( p === THREE.FloatType ) return _gl.FLOAT;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

			}

			if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
			if ( p === THREE.RGBFormat ) return _gl.RGB;
			if ( p === THREE.RGBAFormat ) return _gl.RGBA;
			if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
			if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

			if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
			if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
			if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

			if ( p === THREE.ZeroFactor ) return _gl.ZERO;
			if ( p === THREE.OneFactor ) return _gl.ONE;
			if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
			if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
			if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
			if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
			if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
			if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

			if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
			if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
			if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			}

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			}

			extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				if ( p === THREE.MinEquation ) return extension.MIN_EXT;
				if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

			}

			return 0;

		}

		// Allocations

		function allocateBones ( object ) {

			if ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader
				//   to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				var maxBones = nVertexMatrices;

				if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

					maxBones = Math.min( object.skeleton.bones.length, maxBones );

					if ( maxBones < object.skeleton.bones.length ) {

						THREE.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

					}

				}

				return maxBones;

			}

		}

		function allocateLights( lights ) {

			var dirLights = 0;
			var pointLights = 0;
			var spotLights = 0;
			var hemiLights = 0;

			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

				var light = lights[ l ];

				if ( light.onlyShadow || light.visible === false ) continue;

				if ( light instanceof THREE.DirectionalLight ) dirLights ++;
				if ( light instanceof THREE.PointLight ) pointLights ++;
				if ( light instanceof THREE.SpotLight ) spotLights ++;
				if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

			}

			return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

		}

		function allocateShadows( lights ) {

			var maxShadows = 0;

			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

				var light = lights[ l ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight ) maxShadows ++;
				if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

			}

			return maxShadows;

		}

		// DEPRECATED

		this.initMaterial = function () {

			THREE.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

		};

		this.addPrePlugin = function () {

			THREE.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

		};

		this.addPostPlugin = function () {

			THREE.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

		};

		this.updateShadowMap = function () {

			THREE.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

		};

	};

	// File:src/renderers/WebGLRenderTarget.js

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.WebGLRenderTarget = function ( width, height, options ) {

		this.width = width;
		this.height = height;

		options = options || {};

		this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

		this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
		this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

		this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );

		this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
		this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

		this.generateMipmaps = true;

		this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

	};

	THREE.WebGLRenderTarget.prototype = {

		constructor: THREE.WebGLRenderTarget,

		setSize: function ( width, height ) {

			this.width = width;
			this.height = height;

		},

		clone: function () {

			var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

			tmp.wrapS = this.wrapS;
			tmp.wrapT = this.wrapT;

			tmp.magFilter = this.magFilter;
			tmp.minFilter = this.minFilter;

			tmp.anisotropy = this.anisotropy;

			tmp.offset.copy( this.offset );
			tmp.repeat.copy( this.repeat );

			tmp.format = this.format;
			tmp.type = this.type;

			tmp.depthBuffer = this.depthBuffer;
			tmp.stencilBuffer = this.stencilBuffer;

			tmp.generateMipmaps = this.generateMipmaps;

			tmp.shareDepthFrom = this.shareDepthFrom;

			return tmp;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

	// File:src/renderers/WebGLRenderTargetCube.js

	/**
	 * @author alteredq / http://alteredqualia.com
	 */

	THREE.WebGLRenderTargetCube = function ( width, height, options ) {

		THREE.WebGLRenderTarget.call( this, width, height, options );

		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

	};

	THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
	THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

	// File:src/renderers/webgl/WebGLExtensions.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLExtensions = function ( gl ) {

		var extensions = {};

		this.get = function ( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			var extension;

			switch ( name ) {

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			if ( extension === null ) {

				THREE.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			extensions[ name ] = extension;

			return extension;

		};

	};

	// File:src/renderers/webgl/WebGLProgram.js

	THREE.WebGLProgram = ( function () {

		var programIdCount = 0;

		var generateDefines = function ( defines ) {

			var value, chunk, chunks = [];

			for ( var d in defines ) {

				value = defines[ d ];
				if ( value === false ) continue;

				chunk = '#define ' + d + ' ' + value;
				chunks.push( chunk );

			}

			return chunks.join( '\n' );

		};

		var cacheUniformLocations = function ( gl, program, identifiers ) {

			var uniforms = {};

			for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

				var id = identifiers[ i ];
				uniforms[ id ] = gl.getUniformLocation( program, id );

			}

			return uniforms;

		};

		var cacheAttributeLocations = function ( gl, program, identifiers ) {

			var attributes = {};

			for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

				var id = identifiers[ i ];
				attributes[ id ] = gl.getAttribLocation( program, id );

			}

			return attributes;

		};

		return function ( renderer, code, material, parameters ) {

			var _this = renderer;
			var _gl = _this.context;

			var defines = material.defines;
			var uniforms = material.__webglShader.uniforms;
			var attributes = material.attributes;

			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;

			var index0AttributeName = material.index0AttributeName;

			if ( index0AttributeName === undefined && parameters.morphTargets === true ) {

				// programs with morphTargets displace position out of attribute 0

				index0AttributeName = 'position';

			}

			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

			if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

			} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

			}

			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

			if ( parameters.envMap ) {

				switch ( material.envMap.mapping ) {

					case THREE.CubeReflectionMapping:
					case THREE.CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;

					case THREE.EquirectangularReflectionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;

					case THREE.SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;

				}

				switch ( material.envMap.mapping ) {

					case THREE.CubeRefractionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;

				}

				switch ( material.combine ) {

					case THREE.MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;

					case THREE.MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;

					case THREE.AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;

				}

			}

			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

			// console.log( 'building new program ' );

			//

			var customDefines = generateDefines( defines );

			//

			var program = _gl.createProgram();

			var prefix_vertex, prefix_fragment;

			if ( material instanceof THREE.RawShaderMaterial ) {

				prefix_vertex = '';
				prefix_fragment = '';

			} else {

				prefix_vertex = [

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					customDefines,

					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

					_this.gammaInput ? '#define GAMMA_INPUT' : '',
					_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
					'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
					'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
					'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

					'#define MAX_SHADOWS ' + parameters.maxShadows,

					'#define MAX_BONES ' + parameters.maxBones,

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED': '',

					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals ? '#define USE_MORPHNORMALS' : '',
					parameters.wrapAround ? '#define WRAP_AROUND' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
					parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',

					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',


					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',

					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',
					'attribute vec2 uv2;',

					'#ifdef USE_COLOR',

					'	attribute vec3 color;',

					'#endif',

					'#ifdef USE_MORPHTARGETS',

					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',

					'	#ifdef USE_MORPHNORMALS',

					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',

					'	#else',

					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',

					'	#endif',

					'#endif',

					'#ifdef USE_SKINNING',

					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',

					'#endif',

					''

				].join( '\n' );

				prefix_fragment = [

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					( parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',

					customDefines,

					'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
					'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
					'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
					'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

					'#define MAX_SHADOWS ' + parameters.maxShadows,

					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

					_this.gammaInput ? '#define GAMMA_INPUT' : '',
					_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED': '',

					parameters.metal ? '#define METAL' : '',
					parameters.wrapAround ? '#define WRAP_AROUND' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
					parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',

					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',
					''

				].join( '\n' );

			}

			var glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );
			var glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );

			_gl.attachShader( program, glVertexShader );
			_gl.attachShader( program, glFragmentShader );

			if ( index0AttributeName !== undefined ) {

				// Force a particular attribute to index 0.
				// because potentially expensive emulation is done by browser if attribute 0 is disabled.
				// And, color, for example is often automatically bound to index 0 so disabling it

				_gl.bindAttribLocation( program, 0, index0AttributeName );

			}

			_gl.linkProgram( program );

			var programLogInfo = _gl.getProgramInfoLog( program );

			if ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {

				THREE.error( 'THREE.WebGLProgram: shader error: ' + _gl.getError(), 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ), 'gl.getPRogramInfoLog', programLogInfo );

			}

			if ( programLogInfo !== '' ) {

				THREE.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()' + programLogInfo );
				// THREE.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
				// THREE.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

			}

			// clean up

			_gl.deleteShader( glVertexShader );
			_gl.deleteShader( glFragmentShader );

			// cache uniform locations

			var identifiers = [

				'viewMatrix',
				'modelViewMatrix',
				'projectionMatrix',
				'normalMatrix',
				'modelMatrix',
				'cameraPosition',
				'morphTargetInfluences',
				'bindMatrix',
				'bindMatrixInverse'

			];

			if ( parameters.useVertexTexture ) {

				identifiers.push( 'boneTexture' );
				identifiers.push( 'boneTextureWidth' );
				identifiers.push( 'boneTextureHeight' );

			} else {

				identifiers.push( 'boneGlobalMatrices' );

			}

			if ( parameters.logarithmicDepthBuffer ) {

				identifiers.push('logDepthBufFC');

			}


			for ( var u in uniforms ) {

				identifiers.push( u );

			}

			this.uniforms = cacheUniformLocations( _gl, program, identifiers );

			// cache attributes locations

			identifiers = [

				'position',
				'normal',
				'uv',
				'uv2',
				'tangent',
				'color',
				'skinIndex',
				'skinWeight',
				'lineDistance'

			];

			for ( var i = 0; i < parameters.maxMorphTargets; i ++ ) {

				identifiers.push( 'morphTarget' + i );

			}

			for ( var i = 0; i < parameters.maxMorphNormals; i ++ ) {

				identifiers.push( 'morphNormal' + i );

			}

			for ( var a in attributes ) {

				identifiers.push( a );

			}

			this.attributes = cacheAttributeLocations( _gl, program, identifiers );
			this.attributesKeys = Object.keys( this.attributes );

			//

			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;

			return this;

		};

	} )();

	// File:src/renderers/webgl/WebGLShader.js

	THREE.WebGLShader = ( function () {

		var addLineNumbers = function ( string ) {

			var lines = string.split( '\n' );

			for ( var i = 0; i < lines.length; i ++ ) {

				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

			}

			return lines.join( '\n' );

		};

		return function ( gl, type, string ) {

			var shader = gl.createShader( type ); 

			gl.shaderSource( shader, string );
			gl.compileShader( shader );

			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

				THREE.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

			}

			if ( gl.getShaderInfoLog( shader ) !== '' ) {

				THREE.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

			}

			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			return shader;

		};

	} )();

	// File:src/renderers/webgl/WebGLState.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLState = function ( gl, paramThreeToGL ) {

		var newAttributes = new Uint8Array( 16 );
		var enabledAttributes = new Uint8Array( 16 );

		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;

		var currentDepthTest = null;
		var currentDepthWrite = null;

		var currentColorWrite = null;

		var currentDoubleSided = null;
		var currentFlipSided = null;

		var currentLineWidth = null;

		var currentPolygonOffset = null;
		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		this.initAttributes = function () {

			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

				newAttributes[ i ] = 0;

			}

		};

		this.enableAttribute = function ( attribute ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

		};

		this.disableUnusedAttributes = function () {

			for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		};

		this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

			if ( blending !== currentBlending ) {

				if ( blending === THREE.NoBlending ) {

					gl.disable( gl.BLEND );

				} else if ( blending === THREE.AdditiveBlending ) {

					gl.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

				} else if ( blending === THREE.SubtractiveBlending ) {

					// TODO: Find blendFuncSeparate() combination
					gl.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

				} else if ( blending === THREE.MultiplyBlending ) {

					// TODO: Find blendFuncSeparate() combination
					gl.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

				} else if ( blending === THREE.CustomBlending ) {

					gl.enable( gl.BLEND );

				} else {

					gl.enable( gl.BLEND );
					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				}

				currentBlending = blending;

			}

			if ( blending === THREE.CustomBlending ) {

				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;

				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

					gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;

				}

				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

					gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;

				}

			} else {

				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

			}

		};

		this.setDepthTest = function ( depthTest ) {

			if ( currentDepthTest !== depthTest ) {

				if ( depthTest ) {

					gl.enable( gl.DEPTH_TEST );

				} else {

					gl.disable( gl.DEPTH_TEST );

				}

				currentDepthTest = depthTest;

			}

		};

		this.setDepthWrite = function ( depthWrite ) {

			if ( currentDepthWrite !== depthWrite ) {

				gl.depthMask( depthWrite );
				currentDepthWrite = depthWrite;

			}

		};

		this.setColorWrite = function ( colorWrite ) {

			if ( currentColorWrite !== colorWrite ) {

				gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
				currentColorWrite = colorWrite;

			}

		};

		this.setDoubleSided = function ( doubleSided ) {

			if ( currentDoubleSided !== doubleSided ) {

				if ( doubleSided ) {

					gl.disable( gl.CULL_FACE );

				} else {

					gl.enable( gl.CULL_FACE );

				}

				currentDoubleSided = doubleSided;

			}

		};

		this.setFlipSided = function ( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( gl.CW );

				} else {

					gl.frontFace( gl.CCW );

				}

				currentFlipSided = flipSided;

			}

		};

		this.setLineWidth = function ( width ) {

			if ( width !== currentLineWidth ) {

				gl.lineWidth( width );

				currentLineWidth = width;

			}

		};

		this.setPolygonOffset = function ( polygonoffset, factor, units ) {

			if ( currentPolygonOffset !== polygonoffset ) {

				if ( polygonoffset ) {

					gl.enable( gl.POLYGON_OFFSET_FILL );

				} else {

					gl.disable( gl.POLYGON_OFFSET_FILL );

				}

				currentPolygonOffset = polygonoffset;

			}

			if ( polygonoffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		};

		this.reset = function () {

			for ( var i = 0; i < enabledAttributes.length; i ++ ) {

				enabledAttributes[ i ] = 0;

			}

			currentBlending = null;
			currentDepthTest = null;
			currentDepthWrite = null;
			currentColorWrite = null;
			currentDoubleSided = null;
			currentFlipSided = null;

		};

	};

	// File:src/renderers/webgl/plugins/LensFlarePlugin.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.LensFlarePlugin = function ( renderer, flares ) {

		var gl = renderer.context;

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
		var hasVertexTexture;

		var tempTexture, occlusionTexture;

		var init = function () {

			var vertices = new Float32Array( [
				-1, -1,  0, 0,
				 1, -1,  1, 0,
				 1,  1,  1, 1,
				-1,  1,  0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			// buffers

			vertexBuffer     = gl.createBuffer();
			elementBuffer    = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			// textures

			tempTexture      = gl.createTexture();
			occlusionTexture = gl.createTexture();

			gl.bindTexture( gl.TEXTURE_2D, tempTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

			gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

			hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

			var shader;

			if ( hasVertexTexture ) {

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"uniform sampler2D occlusionMap;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if( renderType == 2 ) {",

								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							// pink square

							"if( renderType == 0 ) {",

								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

							// restore

							"} else if( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

			} else {

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if( renderType == 2 ) {",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"precision mediump float;",

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform sampler2D occlusionMap;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",

						"void main() {",

							// pink square

							"if( renderType == 0 ) {",

								"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

							// restore

							"} else if( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
								"visibility = ( 1.0 - visibility / 4.0 );",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * visibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

			}

			program = createProgram( shader );

			attributes = {
				vertex: gl.getAttribLocation ( program, "position" ),
				uv:     gl.getAttribLocation ( program, "uv" )
			}

			uniforms = {
				renderType:     gl.getUniformLocation( program, "renderType" ),
				map:            gl.getUniformLocation( program, "map" ),
				occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
				opacity:        gl.getUniformLocation( program, "opacity" ),
				color:          gl.getUniformLocation( program, "color" ),
				scale:          gl.getUniformLocation( program, "scale" ),
				rotation:       gl.getUniformLocation( program, "rotation" ),
				screenPosition: gl.getUniformLocation( program, "screenPosition" )
			};

		};

		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */

		this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

			if ( flares.length === 0 ) return;

			var tempPosition = new THREE.Vector3();

			var invAspect = viewportHeight / viewportWidth,
				halfViewportWidth = viewportWidth * 0.5,
				halfViewportHeight = viewportHeight * 0.5;

			var size = 16 / viewportHeight,
				scale = new THREE.Vector2( size * invAspect, size );

			var screenPosition = new THREE.Vector3( 1, 1, 0 ),
				screenPositionPixels = new THREE.Vector2( 1, 1 );

			if ( program === undefined ) {

				init();

			}

			gl.useProgram( program );

			gl.enableVertexAttribArray( attributes.vertex );
			gl.enableVertexAttribArray( attributes.uv );

			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/unforms

			gl.uniform1i( uniforms.occlusionMap, 0 );
			gl.uniform1i( uniforms.map, 1 );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			gl.disable( gl.CULL_FACE );
			gl.depthMask( false );

			for ( var i = 0, l = flares.length; i < l; i ++ ) {

				size = 16 / viewportHeight;
				scale.set( size * invAspect, size );

				// calc object screen position

				var flare = flares[ i ];

				tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

				tempPosition.applyMatrix4( camera.matrixWorldInverse );
				tempPosition.applyProjection( camera.projectionMatrix );

				// setup arrays for gl programs

				screenPosition.copy( tempPosition )

				screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
				screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

				// screen cull

				if ( hasVertexTexture || (
					screenPositionPixels.x > 0 &&
					screenPositionPixels.x < viewportWidth &&
					screenPositionPixels.y > 0 &&
					screenPositionPixels.y < viewportHeight ) ) {

					// save current RGB to temp texture

					gl.activeTexture( gl.TEXTURE1 );
					gl.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


					// render pink quad

					gl.uniform1i( uniforms.renderType, 0 );
					gl.uniform2f( uniforms.scale, scale.x, scale.y );
					gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

					gl.disable( gl.BLEND );
					gl.enable( gl.DEPTH_TEST );

					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


					// copy result to occlusionMap

					gl.activeTexture( gl.TEXTURE0 );
					gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


					// restore graphics

					gl.uniform1i( uniforms.renderType, 1 );
					gl.disable( gl.DEPTH_TEST );

					gl.activeTexture( gl.TEXTURE1 );
					gl.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


					// update object positions

					flare.positionScreen.copy( screenPosition )

					if ( flare.customUpdateCallback ) {

						flare.customUpdateCallback( flare );

					} else {

						flare.updateLensFlares();

					}

					// render flares

					gl.uniform1i( uniforms.renderType, 2 );
					gl.enable( gl.BLEND );

					for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

						var sprite = flare.lensFlares[ j ];

						if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;

							size = sprite.size * sprite.scale / viewportHeight;

							scale.x = size * invAspect;
							scale.y = size;

							gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
							gl.uniform2f( uniforms.scale, scale.x, scale.y );
							gl.uniform1f( uniforms.rotation, sprite.rotation );

							gl.uniform1f( uniforms.opacity, sprite.opacity );
							gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

							renderer.state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
							renderer.setTexture( sprite.texture, 1 );

							gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

						}

					}

				}

			}

			// restore gl

			gl.enable( gl.CULL_FACE );
			gl.enable( gl.DEPTH_TEST );
			gl.depthMask( true );

			renderer.resetGLState();

		};

		function createProgram ( shader ) {

			var program = gl.createProgram();

			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );

			var prefix = "precision " + renderer.getPrecision() + " float;\n";

			gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			gl.shaderSource( vertexShader, prefix + shader.vertexShader );

			gl.compileShader( fragmentShader );
			gl.compileShader( vertexShader );

			gl.attachShader( program, fragmentShader );
			gl.attachShader( program, vertexShader );

			gl.linkProgram( program );

			return program;

		}

	};

	// File:src/renderers/webgl/plugins/ShadowMapPlugin.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.ShadowMapPlugin = function ( _renderer, _lights, _webglObjects, _webglObjectsImmediate ) {

		var _gl = _renderer.context;

		var _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4(),

		_min = new THREE.Vector3(),
		_max = new THREE.Vector3(),

		_matrixPosition = new THREE.Vector3(),

		_renderList = [];

		// init

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		_depthMaterial = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader
		 } );

		_depthMaterialMorph = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: true
		} );

		_depthMaterialSkin = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			skinning: true
		} );

		_depthMaterialMorphSkin = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: true,
			skinning: true
		} );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

		this.render = function ( scene, camera ) {

			if ( _renderer.shadowMapEnabled === false ) return;

			var i, il, j, jl, n,

			shadowMap, shadowMatrix, shadowCamera,
			buffer, material,
			webglObject, object, light,

			lights = [],
			k = 0,

			fog = null;

			// set GL state for depth map

			_gl.clearColor( 1, 1, 1, 1 );
			_gl.disable( _gl.BLEND );

			_gl.enable( _gl.CULL_FACE );
			_gl.frontFace( _gl.CCW );

			if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.BACK );

			}

			_renderer.state.setDepthTest( true );

			// preprocess lights
			// 	- skip lights that are not casting shadows
			//	- create virtual lights for cascaded shadow maps

			for ( i = 0, il = _lights.length; i < il; i ++ ) {

				light = _lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

					for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

						var virtualLight;

						if ( ! light.shadowCascadeArray[ n ] ) {

							virtualLight = createVirtualLight( light, n );
							virtualLight.originalCamera = camera;

							var gyro = new THREE.Gyroscope();
							gyro.position.copy( light.shadowCascadeOffset );

							gyro.add( virtualLight );
							gyro.add( virtualLight.target );

							camera.add( gyro );

							light.shadowCascadeArray[ n ] = virtualLight;

							//console.log( "Created virtualLight", virtualLight );

						} else {

							virtualLight = light.shadowCascadeArray[ n ];

						}

						updateVirtualLight( light, n );

						lights[ k ] = virtualLight;
						k ++;

					}

				} else {

					lights[ k ] = light;
					k ++;

				}

			}

			// render depth map

			for ( i = 0, il = lights.length; i < il; i ++ ) {

				light = lights[ i ];

				if ( ! light.shadowMap ) {

					var shadowFilter = THREE.LinearFilter;

					if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {

						shadowFilter = THREE.NearestFilter;

					}

					var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

					light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
					light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

					light.shadowMatrix = new THREE.Matrix4();

				}

				if ( ! light.shadowCamera ) {

					if ( light instanceof THREE.SpotLight ) {

						light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

					} else if ( light instanceof THREE.DirectionalLight ) {

						light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

					} else {

						THREE.error( "THREE.ShadowMapPlugin: Unsupported light type for shadow", light );
						continue;

					}

					scene.add( light.shadowCamera );

					if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

				}

				if ( light.shadowCameraVisible && ! light.cameraHelper ) {

					light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
					scene.add( light.cameraHelper );

				}

				if ( light.isVirtual && virtualLight.originalCamera == camera ) {

					updateShadowCamera( camera, light );

				}

				shadowMap = light.shadowMap;
				shadowMatrix = light.shadowMatrix;
				shadowCamera = light.shadowCamera;

				//

				shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
				_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
				shadowCamera.lookAt( _matrixPosition );
				shadowCamera.updateMatrixWorld();

				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

				//

				if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
				if ( light.shadowCameraVisible ) light.cameraHelper.update();

				// compute shadow matrix

				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);

				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				// update camera matrices and frustum

				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				// render shadow map

				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();

				// set object matrices & frustum culling

				_renderList.length = 0;

				projectObject( scene, scene, shadowCamera );


				// render regular objects

				var objectMaterial, useMorphing, useSkinning;

				for ( j = 0, jl = _renderList.length; j < jl; j ++ ) {

					webglObject = _renderList[ j ];

					object = webglObject.object;
					buffer = webglObject.buffer;

					// culling is overriden globally for all objects
					// while rendering depth map

					// need to deal with MeshFaceMaterial somehow
					// in that case just use the first of material.materials for now
					// (proper solution would require to break objects by materials
					//  similarly to regular rendering and then set corresponding
					//  depth materials per each chunk instead of just once per object)

					objectMaterial = getObjectMaterial( object );

					useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
					useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

					if ( object.customDepthMaterial ) {

						material = object.customDepthMaterial;

					} else if ( useSkinning ) {

						material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

					} else if ( useMorphing ) {

						material = _depthMaterialMorph;

					} else {

						material = _depthMaterial;

					}

					_renderer.setMaterialFaces( objectMaterial );

					if ( buffer instanceof THREE.BufferGeometry ) {

						_renderer.renderBufferDirect( shadowCamera, _lights, fog, material, buffer, object );

					} else {

						_renderer.renderBuffer( shadowCamera, _lights, fog, material, buffer, object );

					}

				}

				// set matrices and render immediate objects

				for ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {

					webglObject = _webglObjectsImmediate[ j ];
					object = webglObject.object;

					if ( object.visible && object.castShadow ) {

						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

						_renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );

					}

				}

			}

			// restore GL state

			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();

			_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
			_gl.enable( _gl.BLEND );

			if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.BACK );

			}

			_renderer.resetGLState();

		};

		function projectObject( scene, object, shadowCamera ) {

			if ( object.visible ) {

				var webglObjects = _webglObjects[ object.id ];

				if ( webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject( object ) === true) ) {

					for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

						var webglObject = webglObjects[ i ];

						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
						_renderList.push( webglObject );

					}

				}

				for ( var i = 0, l = object.children.length; i < l; i ++ ) {

					projectObject( scene, object.children[ i ], shadowCamera );

				}

			}

		}

		function createVirtualLight( light, cascade ) {

			var virtualLight = new THREE.DirectionalLight();

			virtualLight.isVirtual = true;

			virtualLight.onlyShadow = true;
			virtualLight.castShadow = true;

			virtualLight.shadowCameraNear = light.shadowCameraNear;
			virtualLight.shadowCameraFar = light.shadowCameraFar;

			virtualLight.shadowCameraLeft = light.shadowCameraLeft;
			virtualLight.shadowCameraRight = light.shadowCameraRight;
			virtualLight.shadowCameraBottom = light.shadowCameraBottom;
			virtualLight.shadowCameraTop = light.shadowCameraTop;

			virtualLight.shadowCameraVisible = light.shadowCameraVisible;

			virtualLight.shadowDarkness = light.shadowDarkness;

			virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
			virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
			virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

			virtualLight.pointsWorld = [];
			virtualLight.pointsFrustum = [];

			var pointsWorld = virtualLight.pointsWorld,
				pointsFrustum = virtualLight.pointsFrustum;

			for ( var i = 0; i < 8; i ++ ) {

				pointsWorld[ i ] = new THREE.Vector3();
				pointsFrustum[ i ] = new THREE.Vector3();

			}

			var nearZ = light.shadowCascadeNearZ[ cascade ];
			var farZ = light.shadowCascadeFarZ[ cascade ];

			pointsFrustum[ 0 ].set( - 1, - 1, nearZ );
			pointsFrustum[ 1 ].set(  1, - 1, nearZ );
			pointsFrustum[ 2 ].set( - 1,  1, nearZ );
			pointsFrustum[ 3 ].set(  1,  1, nearZ );

			pointsFrustum[ 4 ].set( - 1, - 1, farZ );
			pointsFrustum[ 5 ].set(  1, - 1, farZ );
			pointsFrustum[ 6 ].set( - 1,  1, farZ );
			pointsFrustum[ 7 ].set(  1,  1, farZ );

			return virtualLight;

		}

		// Synchronize virtual light with the original light

		function updateVirtualLight( light, cascade ) {

			var virtualLight = light.shadowCascadeArray[ cascade ];

			virtualLight.position.copy( light.position );
			virtualLight.target.position.copy( light.target.position );
			virtualLight.lookAt( virtualLight.target );

			virtualLight.shadowCameraVisible = light.shadowCameraVisible;
			virtualLight.shadowDarkness = light.shadowDarkness;

			virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

			var nearZ = light.shadowCascadeNearZ[ cascade ];
			var farZ = light.shadowCascadeFarZ[ cascade ];

			var pointsFrustum = virtualLight.pointsFrustum;

			pointsFrustum[ 0 ].z = nearZ;
			pointsFrustum[ 1 ].z = nearZ;
			pointsFrustum[ 2 ].z = nearZ;
			pointsFrustum[ 3 ].z = nearZ;

			pointsFrustum[ 4 ].z = farZ;
			pointsFrustum[ 5 ].z = farZ;
			pointsFrustum[ 6 ].z = farZ;
			pointsFrustum[ 7 ].z = farZ;

		}

		// Fit shadow camera's ortho frustum to camera frustum

		function updateShadowCamera( camera, light ) {

			var shadowCamera = light.shadowCamera,
				pointsFrustum = light.pointsFrustum,
				pointsWorld = light.pointsWorld;

			_min.set( Infinity, Infinity, Infinity );
			_max.set( - Infinity, - Infinity, - Infinity );

			for ( var i = 0; i < 8; i ++ ) {

				var p = pointsWorld[ i ];

				p.copy( pointsFrustum[ i ] );
				p.unproject( camera );

				p.applyMatrix4( shadowCamera.matrixWorldInverse );

				if ( p.x < _min.x ) _min.x = p.x;
				if ( p.x > _max.x ) _max.x = p.x;

				if ( p.y < _min.y ) _min.y = p.y;
				if ( p.y > _max.y ) _max.y = p.y;

				if ( p.z < _min.z ) _min.z = p.z;
				if ( p.z > _max.z ) _max.z = p.z;

			}

			shadowCamera.left = _min.x;
			shadowCamera.right = _max.x;
			shadowCamera.top = _max.y;
			shadowCamera.bottom = _min.y;

			// can't really fit near/far
			//shadowCamera.near = _min.z;
			//shadowCamera.far = _max.z;

			shadowCamera.updateProjectionMatrix();

		}

		// For the moment just ignore objects that have multiple materials with different animation methods
		// Only the first material will be taken into account for deciding which depth material to use for shadow maps

		function getObjectMaterial( object ) {

			return object.material instanceof THREE.MeshFaceMaterial
				? object.material.materials[ 0 ]
				: object.material;

		};

	};

	// File:src/renderers/webgl/plugins/SpritePlugin.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SpritePlugin = function ( renderer, sprites ) {

		var gl = renderer.context;

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;

		var texture;

		// decompose matrixWorld

		var spritePosition = new THREE.Vector3();
		var spriteRotation = new THREE.Quaternion();
		var spriteScale = new THREE.Vector3();

		var init = function () {

			var vertices = new Float32Array( [
				- 0.5, - 0.5,  0, 0,
				  0.5, - 0.5,  1, 0,
				  0.5,   0.5,  1, 1,
				- 0.5,   0.5,  0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			vertexBuffer  = gl.createBuffer();
			elementBuffer = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			program = createProgram();

			attributes = {
				position:			gl.getAttribLocation ( program, 'position' ),
				uv:					gl.getAttribLocation ( program, 'uv' )
			};

			uniforms = {
				uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
				uvScale:			gl.getUniformLocation( program, 'uvScale' ),

				rotation:			gl.getUniformLocation( program, 'rotation' ),
				scale:				gl.getUniformLocation( program, 'scale' ),

				color:				gl.getUniformLocation( program, 'color' ),
				map:				gl.getUniformLocation( program, 'map' ),
				opacity:			gl.getUniformLocation( program, 'opacity' ),

				modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

				fogType:			gl.getUniformLocation( program, 'fogType' ),
				fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
				fogNear:			gl.getUniformLocation( program, 'fogNear' ),
				fogFar:				gl.getUniformLocation( program, 'fogFar' ),
				fogColor:			gl.getUniformLocation( program, 'fogColor' ),

				alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
			};

			var canvas = document.createElement( 'canvas' );
			canvas.width = 8;
			canvas.height = 8;

			var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 8, 8 );

			texture = new THREE.Texture( canvas );
			texture.needsUpdate = true;

		};

		this.render = function ( scene, camera ) {

			if ( sprites.length === 0 ) return;

			// setup gl

			if ( program === undefined ) {

				init();

			}

			gl.useProgram( program );

			gl.enableVertexAttribArray( attributes.position );
			gl.enableVertexAttribArray( attributes.uv );

			gl.disable( gl.CULL_FACE );
			gl.enable( gl.BLEND );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			gl.activeTexture( gl.TEXTURE0 );
			gl.uniform1i( uniforms.map, 0 );

			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;

			if ( fog ) {

				gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

				if ( fog instanceof THREE.Fog ) {

					gl.uniform1f( uniforms.fogNear, fog.near );
					gl.uniform1f( uniforms.fogFar, fog.far );

					gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;

				} else if ( fog instanceof THREE.FogExp2 ) {

					gl.uniform1f( uniforms.fogDensity, fog.density );

					gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;

				}

			} else {

				gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;

			}


			// update positions and sort

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];

				sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

			}

			sprites.sort( painterSortStable );

			// render all sprites

			var scale = [];

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];
				var material = sprite.material;

				gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

				sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

				scale[ 0 ] = spriteScale.x;
				scale[ 1 ] = spriteScale.y;

				var fogType = 0;

				if ( scene.fog && material.fog ) {

					fogType = sceneFogType;

				}

				if ( oldFogType !== fogType ) {

					gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;

				}

				if ( material.map !== null ) {

					gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

				} else {

					gl.uniform2f( uniforms.uvOffset, 0, 0 );
					gl.uniform2f( uniforms.uvScale, 1, 1 );

				}

				gl.uniform1f( uniforms.opacity, material.opacity );
				gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

				gl.uniform1f( uniforms.rotation, material.rotation );
				gl.uniform2fv( uniforms.scale, scale );

				renderer.state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				renderer.state.setDepthTest( material.depthTest );
				renderer.state.setDepthWrite( material.depthWrite );

				if ( material.map && material.map.image && material.map.image.width ) {

					renderer.setTexture( material.map, 0 );

				} else {

					renderer.setTexture( texture, 0 );

				}

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

			}

			// restore gl

			gl.enable( gl.CULL_FACE );

			renderer.resetGLState();

		};

		function createProgram () {

			var program = gl.createProgram();

			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

			gl.shaderSource( vertexShader, [

				'precision ' + renderer.getPrecision() + ' float;',

				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',

				'attribute vec2 position;',
				'attribute vec2 uv;',

				'varying vec2 vUV;',

				'void main() {',

					'vUV = uvOffset + uv * uvScale;',

					'vec2 alignedPosition = position * scale;',

					'vec2 rotatedPosition;',
					'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
					'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

					'vec4 finalPosition;',

					'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
					'finalPosition.xy += rotatedPosition;',
					'finalPosition = projectionMatrix * finalPosition;',

					'gl_Position = finalPosition;',

				'}'

			].join( '\n' ) );

			gl.shaderSource( fragmentShader, [

				'precision ' + renderer.getPrecision() + ' float;',

				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',

				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',

				'varying vec2 vUV;',

				'void main() {',

					'vec4 texture = texture2D( map, vUV );',

					'if ( texture.a < alphaTest ) discard;',

					'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

					'if ( fogType > 0 ) {',

						'float depth = gl_FragCoord.z / gl_FragCoord.w;',
						'float fogFactor = 0.0;',

						'if ( fogType == 1 ) {',

							'fogFactor = smoothstep( fogNear, fogFar, depth );',

						'} else {',

							'const float LOG2 = 1.442695;',
							'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
							'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

						'}',

						'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

					'}',

				'}'

			].join( '\n' ) );

			gl.compileShader( vertexShader );
			gl.compileShader( fragmentShader );

			gl.attachShader( program, vertexShader );
			gl.attachShader( program, fragmentShader );

			gl.linkProgram( program );

			return program;

		};

		function painterSortStable ( a, b ) {

			if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return b.id - a.id;

			}

		};

	};

	// File:src/extras/GeometryUtils.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.GeometryUtils = {

		merge: function ( geometry1, geometry2, materialIndexOffset ) {

			THREE.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

			var matrix;

			if ( geometry2 instanceof THREE.Mesh ) {

				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;

			}

			geometry1.merge( geometry2, matrix, materialIndexOffset );

		},

		center: function ( geometry ) {

			THREE.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();

		}

	};

	// File:src/extras/ImageUtils.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Daosheng Mu / https://github.com/DaoshengMu/
	 */

	THREE.ImageUtils = {

		crossOrigin: undefined,

		loadTexture: function ( url, mapping, onLoad, onError ) {

			var loader = new THREE.ImageLoader();
			loader.crossOrigin = this.crossOrigin;

			var texture = new THREE.Texture( undefined, mapping );

			loader.load( url, function ( image ) {

				texture.image = image;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, undefined, function ( event ) {

				if ( onError ) onError( event );

			} );

			texture.sourceFile = url;

			return texture;

		},

		loadTextureCube: function ( array, mapping, onLoad, onError ) {

			var images = [];

			var loader = new THREE.ImageLoader();
			loader.crossOrigin = this.crossOrigin;

			var texture = new THREE.CubeTexture( images, mapping );

			// no flipping needed for cube textures

			texture.flipY = false;

			var loaded = 0;

			var loadTexture = function ( i ) {

				loader.load( array[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded += 1;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, undefined, onError );

			}

			for ( var i = 0, il = array.length; i < il; ++ i ) {

				loadTexture( i );

			}

			return texture;

		},

		loadCompressedTexture: function () {

			THREE.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

		},

		loadCompressedTextureCube: function () {

			THREE.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

		},

		getNormalMap: function ( image, depth ) {

			// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

			var cross = function ( a, b ) {

				return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

			}

			var subtract = function ( a, b ) {

				return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

			}

			var normalize = function ( a ) {

				var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
				return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

			}

			depth = depth | 1;

			var width = image.width;
			var height = image.height;

			var canvas = document.createElement( 'canvas' );
			canvas.width = width;
			canvas.height = height;

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0 );

			var data = context.getImageData( 0, 0, width, height ).data;
			var imageData = context.createImageData( width, height );
			var output = imageData.data;

			for ( var x = 0; x < width; x ++ ) {

				for ( var y = 0; y < height; y ++ ) {

					var ly = y - 1 < 0 ? 0 : y - 1;
					var uy = y + 1 > height - 1 ? height - 1 : y + 1;
					var lx = x - 1 < 0 ? 0 : x - 1;
					var ux = x + 1 > width - 1 ? width - 1 : x + 1;

					var points = [];
					var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
					points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
					points.push( [ 1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

					var normals = [];
					var num_points = points.length;

					for ( var i = 0; i < num_points; i ++ ) {

						var v1 = points[ i ];
						var v2 = points[ ( i + 1 ) % num_points ];
						v1 = subtract( v1, origin );
						v2 = subtract( v2, origin );
						normals.push( normalize( cross( v1, v2 ) ) );

					}

					var normal = [ 0, 0, 0 ];

					for ( var i = 0; i < normals.length; i ++ ) {

						normal[ 0 ] += normals[ i ][ 0 ];
						normal[ 1 ] += normals[ i ][ 1 ];
						normal[ 2 ] += normals[ i ][ 2 ];

					}

					normal[ 0 ] /= normals.length;
					normal[ 1 ] /= normals.length;
					normal[ 2 ] /= normals.length;

					var idx = ( y * width + x ) * 4;

					output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
					output[ idx + 3 ] = 255;

				}

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		},

		generateDataTexture: function ( width, height, color ) {

			var size = width * height;
			var data = new Uint8Array( 3 * size );

			var r = Math.floor( color.r * 255 );
			var g = Math.floor( color.g * 255 );
			var b = Math.floor( color.b * 255 );

			for ( var i = 0; i < size; i ++ ) {

				data[ i * 3 ] 	   = r;
				data[ i * 3 + 1 ] = g;
				data[ i * 3 + 2 ] = b;

			}

			var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
			texture.needsUpdate = true;

			return texture;

		}

	};

	// File:src/extras/SceneUtils.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SceneUtils = {

		createMultiMaterialObject: function ( geometry, materials ) {

			var group = new THREE.Object3D();

			for ( var i = 0, l = materials.length; i < l; i ++ ) {

				group.add( new THREE.Mesh( geometry, materials[ i ] ) );

			}

			return group;

		},

		detach: function ( child, parent, scene ) {

			child.applyMatrix( parent.matrixWorld );
			parent.remove( child );
			scene.add( child );

		},

		attach: function ( child, scene, parent ) {

			var matrixWorldInverse = new THREE.Matrix4();
			matrixWorldInverse.getInverse( parent.matrixWorld );
			child.applyMatrix( matrixWorldInverse );

			scene.remove( child );
			parent.add( child );

		}

	};

	// File:src/extras/FontUtils.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For Text operations in three.js (See TextGeometry)
	 *
	 * It uses techniques used in:
	 *
	 * 	typeface.js and canvastext
	 * 		For converting fonts and rendering with javascript
	 *		http://typeface.neocracy.org
	 *
	 *	Triangulation ported from AS3
	 *		Simple Polygon Triangulation
	 *		http://actionsnippet.com/?p=1462
	 *
	 * 	A Method to triangulate shapes with holes
	 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
	 *
	 */

	THREE.FontUtils = {

		faces: {},

		// Just for now. face[weight][style]

		face: 'helvetiker',
		weight: 'normal',
		style: 'normal',
		size: 150,
		divisions: 10,

		getFace: function () {

			try {

				return this.faces[ this.face ][ this.weight ][ this.style ];

			} catch (e) {

				throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

			};

		},

		loadFace: function ( data ) {

			var family = data.familyName.toLowerCase();

			var ThreeFont = this;

			ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

			ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
			ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

			ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

			return data;

		},

		drawText: function ( text ) {

			// RenderText

			var i,
				face = this.getFace(),
				scale = this.size / face.resolution,
				offset = 0,
				chars = String( text ).split( '' ),
				length = chars.length;

			var fontPaths = [];

			for ( i = 0; i < length; i ++ ) {

				var path = new THREE.Path();

				var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
				offset += ret.offset;

				fontPaths.push( ret.path );

			}

			// get the width

			var width = offset / 2;
			//
			// for ( p = 0; p < allPts.length; p++ ) {
			//
			// 	allPts[ p ].x -= width;
			//
			// }

			//var extract = this.extractPoints( allPts, characterPts );
			//extract.contour = allPts;

			//extract.paths = fontPaths;
			//extract.offset = width;

			return { paths: fontPaths, offset: width };

		},




		extractGlyphPoints: function ( c, face, scale, offset, path ) {

			var pts = [];

			var i, i2, divisions,
				outline, action, length,
				scaleX, scaleY,
				x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
				laste,
				glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

			if ( ! glyph ) return;

			if ( glyph.o ) {

				outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
				length = outline.length;

				scaleX = scale;
				scaleY = scale;

				for ( i = 0; i < length; ) {

					action = outline[ i ++ ];

					//console.log( action );

					switch ( action ) {

					case 'm':

						// Move To

						x = outline[ i ++ ] * scaleX + offset;
						y = outline[ i ++ ] * scaleY;

						path.moveTo( x, y );
						break;

					case 'l':

						// Line To

						x = outline[ i ++ ] * scaleX + offset;
						y = outline[ i ++ ] * scaleY;
						path.lineTo( x, y );
						break;

					case 'q':

						// QuadraticCurveTo

						cpx  = outline[ i ++ ] * scaleX + offset;
						cpy  = outline[ i ++ ] * scaleY;
						cpx1 = outline[ i ++ ] * scaleX + offset;
						cpy1 = outline[ i ++ ] * scaleY;

						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

						laste = pts[ pts.length - 1 ];

						if ( laste ) {

							cpx0 = laste.x;
							cpy0 = laste.y;

							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

								var t = i2 / divisions;
								THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
								THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
							}

						}

						break;

					case 'b':

						// Cubic Bezier Curve

						cpx  = outline[ i ++ ] *  scaleX + offset;
						cpy  = outline[ i ++ ] *  scaleY;
						cpx1 = outline[ i ++ ] *  scaleX + offset;
						cpy1 = outline[ i ++ ] *  scaleY;
						cpx2 = outline[ i ++ ] *  scaleX + offset;
						cpy2 = outline[ i ++ ] *  scaleY;

						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

						laste = pts[ pts.length - 1 ];

						if ( laste ) {

							cpx0 = laste.x;
							cpy0 = laste.y;

							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

								var t = i2 / divisions;
								THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
								THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

							}

						}

						break;

					}

				}
			}



			return { offset: glyph.ha * scale, path:path };
		}

	};


	THREE.FontUtils.generateShapes = function ( text, parameters ) {

		// Parameters 

		parameters = parameters || {};

		var size = parameters.size !== undefined ? parameters.size : 100;
		var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

		var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
		var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
		var style = parameters.style !== undefined ? parameters.style : 'normal';

		THREE.FontUtils.size = size;
		THREE.FontUtils.divisions = curveSegments;

		THREE.FontUtils.face = font;
		THREE.FontUtils.weight = weight;
		THREE.FontUtils.style = style;

		// Get a Font data json object

		var data = THREE.FontUtils.drawText( text );

		var paths = data.paths;
		var shapes = [];

		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	};


	/**
	 * This code is a quick port of code written in C++ which was submitted to
	 * flipcode.com by John W. Ratcliff  // July 22, 2000
	 * See original code and more information here:
	 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
	 *
	 * ported to actionscript by Zevan Rosser
	 * www.actionsnippet.com
	 *
	 * ported to javascript by Joshua Koo
	 * http://www.lab4games.net/zz85/blog
	 *
	 */


	( function ( namespace ) {

		var EPSILON = 0.0000000001;

		// takes in an contour array and returns

		var process = function ( contour, indices ) {

			var n = contour.length;

			if ( n < 3 ) return null;

			var result = [],
				verts = [],
				vertIndices = [];

			/* we want a counter-clockwise polygon in verts */

			var u, v, w;

			if ( area( contour ) > 0.0 ) {

				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

			} else {

				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

			}

			var nv = n;

			/*  remove nv - 2 vertices, creating 1 triangle every time */

			var count = 2 * nv;   /* error detection */

			for ( v = nv - 1; nv > 2; ) {

				/* if we loop, it is probably a non-simple polygon */

				if ( ( count -- ) <= 0 ) {

					//** Triangulate: ERROR - probable bad polygon!

					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					THREE.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );

					if ( indices ) return vertIndices;
					return result;

				}

				/* three consecutive vertices in current polygon, <u,v,w> */

				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

				if ( snip( contour, u, v, w, nv, verts ) ) {

					var a, b, c, s, t;

					/* true names of the vertices */

					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];

					/* output Triangle */

					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );


					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

					/* remove v from the remaining polygon */

					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

						verts[ s ] = verts[ t ];

					}

					nv --;

					/* reset error detection counter */

					count = 2 * nv;

				}

			}

			if ( indices ) return vertIndices;
			return result;

		};

		// calculate area of the contour polygon

		var area = function ( contour ) {

			var n = contour.length;
			var a = 0.0;

			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		};

		var snip = function ( contour, u, v, w, n, verts ) {

			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;

			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;

			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;

			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;

			if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			for ( p = 0; p < n; p ++ ) {

				px = contour[ verts[ p ] ].x
				py = contour[ verts[ p ] ].y

				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;

				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;

			}

			return true;

		};


		namespace.Triangulate = process;
		namespace.Triangulate.area = area;

		return namespace;

	} )( THREE.FontUtils );

	// To use the typeface.js face files, hook up the API
	self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
	THREE.typeface_js = self._typeface_js;

	// File:src/extras/audio/Audio.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Audio = function ( listener ) {

		THREE.Object3D.call( this );

		this.type = 'Audio';

		this.context = listener.context;
		this.source = this.context.createBufferSource();
		this.source.onended = this.onEnded.bind(this);

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );

		this.autoplay = false;

		this.startTime = 0;
		this.isPlaying = false;

	};

	THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Audio.prototype.constructor = THREE.Audio;

	THREE.Audio.prototype.load = function ( file ) {

		var scope = this;

		var request = new XMLHttpRequest();
		request.open( 'GET', file, true );
		request.responseType = 'arraybuffer';
		request.onload = function ( e ) {

			scope.context.decodeAudioData( this.response, function ( buffer ) {

				scope.source.buffer = buffer;

				if( scope.autoplay ) scope.play();

			} );

		};
		request.send();

		return this;

	};

	THREE.Audio.prototype.play = function () {

		if ( this.isPlaying === true ) {

			THREE.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		var source = this.context.createBufferSource();

		source.buffer = this.source.buffer;
		source.loop = this.source.loop;
		source.onended = this.source.onended;
		source.connect( this.panner );
		source.start( 0, this.startTime );

		this.isPlaying = true;

		this.source = source;

	};

	THREE.Audio.prototype.pause = function () {

		this.source.stop();
		this.startTime = this.context.currentTime;

	};

	THREE.Audio.prototype.stop = function () {

		this.source.stop();
		this.startTime = 0;

	};

	THREE.Audio.prototype.onEnded = function() {

		this.isPlaying = false;

	};

	THREE.Audio.prototype.setLoop = function ( value ) {

		this.source.loop = value;

	};

	THREE.Audio.prototype.setRefDistance = function ( value ) {

		this.panner.refDistance = value;

	};

	THREE.Audio.prototype.setRolloffFactor = function ( value ) {

		this.panner.rolloffFactor = value;

	};

	THREE.Audio.prototype.setVolume = function ( value ) {

		this.gain.gain.value = value;

	};

	THREE.Audio.prototype.updateMatrixWorld = ( function () {

		var position = new THREE.Vector3();

		return function ( force ) {

			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

			position.setFromMatrixPosition( this.matrixWorld );

			this.panner.setPosition( position.x, position.y, position.z );

		};

	} )();

	// File:src/extras/audio/AudioListener.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AudioListener = function () {

		THREE.Object3D.call( this );

		this.type = 'AudioListener';

		this.context = new ( window.AudioContext || window.webkitAudioContext )();

	};

	THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
	THREE.AudioListener.prototype.constructor = THREE.AudioListener;

	THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3();

		var orientation = new THREE.Vector3();
		var velocity = new THREE.Vector3();

		var positionPrev = new THREE.Vector3();

		return function ( force ) {

			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

			var listener = this.context.listener;
			var up = this.up;

			this.matrixWorld.decompose( position, quaternion, scale );

			orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );
			velocity.subVectors( position, positionPrev );

			listener.setPosition( position.x, position.y, position.z );
			listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
			listener.setVelocity( velocity.x, velocity.y, velocity.z );

			positionPrev.copy( position );

		};

	} )();

	// File:src/extras/core/Curve.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTagentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 * THREE.ClosedSplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/

	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/

	THREE.Curve = function () {

	};

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	THREE.Curve.prototype.getPoint = function ( t ) {

		THREE.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
		return null;

	};

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	THREE.Curve.prototype.getPointAt = function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t );

	};

	// Get sequence of points using getPoint( t )

	THREE.Curve.prototype.getPoints = function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPoint( d / divisions ) );

		}

		return pts;

	};

	// Get sequence of points using getPointAt( u )

	THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPointAt( d / divisions ) );

		}

		return pts;

	};

	// Get total curve arc length

	THREE.Curve.prototype.getLength = function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	};

	// Get list of cumulative segment lengths

	THREE.Curve.prototype.getLengths = function ( divisions ) {

		if ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;

		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length == divisions + 1 )
			&& ! this.needsUpdate) {

			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

	};


	THREE.Curve.prototype.updateArcLengths = function() {
		this.needsUpdate = true;
		this.getLengths();
	};

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

	THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		//var time = Date.now();

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		//console.log('b' , i, low, high, Date.now()- time);

		if ( arcLengths[ i ] == targetArcLength ) {

			var t = i / ( il - 1 );
			return t;

		}

		// we could get finer grain at lengths, or use simple interpolatation between two points

		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];

		var segmentLength = lengthAfter - lengthBefore;

	    // determine where we are between the 'before' and 'after' points

		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

	    // add that fractional amount to t

		var t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	};

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	THREE.Curve.prototype.getTangent = function( t ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var vec = pt2.clone().sub(pt1);
		return vec.normalize();

	};


	THREE.Curve.prototype.getTangentAt = function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t );

	};





	/**************************************************************
	 *	Utils
	 **************************************************************/

	THREE.Curve.Utils = {

		tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

			return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

		},

		// Puay Bing, thanks for helping with this derivative!

		tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

			return - 3 * p0 * (1 - t) * (1 - t)  +
				3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +
				6 * t *  p2 * (1 - t) - 3 * t * t * p2 +
				3 * t * t * p3;

		},

		tangentSpline: function ( t, p0, p1, p2, p3 ) {

			// To check if my formulas are correct

			var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
			var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
			var h01 = - 6 * t * t + 6 * t; 	//  2t3 + 3t2
			var h11 = 3 * t * t - 2 * t;	// t3  t2

			return h00 + h10 + h01 + h11;

		},

		// Catmull-Rom

		interpolate: function( p0, p1, p2, p3, t ) {

			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	};


	// TODO: Transformation for Curves?

	/**************************************************************
	 *	3D Curves
	 **************************************************************/

	// A Factory method for creating new curve subclasses

	THREE.Curve.create = function ( constructor, getPointFunc ) {

		constructor.prototype = Object.create( THREE.Curve.prototype );
		constructor.prototype.constructor = constructor;
		constructor.prototype.getPoint = getPointFunc;

		return constructor;

	};

	// File:src/extras/core/CurvePath.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	THREE.CurvePath = function () {

		this.curves = [];
		this.bends = [];
		
		this.autoClose = false; // Automatically closes the path
	};

	THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
	THREE.CurvePath.prototype.constructor = THREE.CurvePath;

	THREE.CurvePath.prototype.add = function ( curve ) {

		this.curves.push( curve );

	};

	THREE.CurvePath.prototype.checkConnection = function() {
		// TODO
		// If the ending of curve is not connected to the starting
		// or the next curve, then, this is not a real path
	};

	THREE.CurvePath.prototype.closePath = function() {
		// TODO Test
		// and verify for vector3 (needs to implement equals)
		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[0].getPoint(0);
		var endPoint = this.curves[this.curves.length - 1].getPoint(1);
		
		if (! startPoint.equals(endPoint)) {
			this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
		}
		
	};

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	THREE.CurvePath.prototype.getPoint = function( t ) {

		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0, diff, curve;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				diff = curveLengths[ i ] - d;
				curve = this.curves[ i ];

				var u = 1 - diff / curve.getLength();

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	};

	/*
	THREE.CurvePath.prototype.getTangent = function( t ) {
	};*/


	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	THREE.CurvePath.prototype.getLength = function() {

		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	};

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	THREE.CurvePath.prototype.getCurveLengths = function() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {

			return this.cacheLengths;

		};

		// Get length of subsurve
		// Push sums into cached array

		var lengths = [], sums = 0;
		var i, il = this.curves.length;

		for ( i = 0; i < il; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	};



	// Returns min and max coordinates

	THREE.CurvePath.prototype.getBoundingBox = function () {

		var points = this.getPoints();

		var maxX, maxY, maxZ;
		var minX, minY, minZ;

		maxX = maxY = Number.NEGATIVE_INFINITY;
		minX = minY = Number.POSITIVE_INFINITY;

		var p, i, il, sum;

		var v3 = points[0] instanceof THREE.Vector3;

		sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

		for ( i = 0, il = points.length; i < il; i ++ ) {

			p = points[ i ];

			if ( p.x > maxX ) maxX = p.x;
			else if ( p.x < minX ) minX = p.x;

			if ( p.y > maxY ) maxY = p.y;
			else if ( p.y < minY ) minY = p.y;

			if ( v3 ) {

				if ( p.z > maxZ ) maxZ = p.z;
				else if ( p.z < minZ ) minZ = p.z;

			}

			sum.add( p );

		}

		var ret = {

			minX: minX,
			minY: minY,
			maxX: maxX,
			maxY: maxY

		};

		if ( v3 ) {

			ret.maxZ = maxZ;
			ret.minZ = minZ;

		}

		return ret;

	};

	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/

	/// Generate geometry from path points (for Line or Points objects)

	THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

		var pts = this.getPoints( divisions, true );
		return this.createGeometry( pts );

	};

	// Generate geometry from equidistance sampling along the path

	THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

		var pts = this.getSpacedPoints( divisions, true );
		return this.createGeometry( pts );

	};

	THREE.CurvePath.prototype.createGeometry = function( points ) {

		var geometry = new THREE.Geometry();

		for ( var i = 0; i < points.length; i ++ ) {

			geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

		}

		return geometry;

	};


	/**************************************************************
	 *	Bend / Wrap Helper Methods
	 **************************************************************/

	// Wrap path / Bend modifiers?

	THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

		this.bends.push( bendpath );

	};

	THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

		var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
		var i, il;

		if ( ! bends ) {

			bends = this.bends;

		}

		for ( i = 0, il = bends.length; i < il; i ++ ) {

			oldPts = this.getWrapPoints( oldPts, bends[ i ] );

		}

		return oldPts;

	};

	THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

		var oldPts = this.getSpacedPoints( segments );

		var i, il;

		if ( ! bends ) {

			bends = this.bends;

		}

		for ( i = 0, il = bends.length; i < il; i ++ ) {

			oldPts = this.getWrapPoints( oldPts, bends[ i ] );

		}

		return oldPts;

	};

	// This returns getPoints() bend/wrapped around the contour of a path.
	// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

	THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

		var bounds = this.getBoundingBox();

		var i, il, p, oldX, oldY, xNorm;

		for ( i = 0, il = oldPts.length; i < il; i ++ ) {

			p = oldPts[ i ];

			oldX = p.x;
			oldY = p.y;

			xNorm = oldX / bounds.maxX;

			// If using actual distance, for length > path, requires line extrusions
			//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

			xNorm = path.getUtoTmapping( xNorm, oldX );

			// check for out of bounds?

			var pathPt = path.getPoint( xNorm );
			var normal = path.getTangent( xNorm );
			normal.set( - normal.y, normal.x ).multiplyScalar( oldY );

			p.x = pathPt.x + normal.x;
			p.y = pathPt.y + normal.y;

		}

		return oldPts;

	};


	// File:src/extras/core/Gyroscope.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Gyroscope = function () {

		THREE.Object3D.call( this );

	};

	THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Gyroscope.prototype.constructor = THREE.Gyroscope;

	THREE.Gyroscope.prototype.updateMatrixWorld = ( function () {

		var translationObject = new THREE.Vector3();
		var quaternionObject = new THREE.Quaternion();
		var scaleObject = new THREE.Vector3();

		var translationWorld = new THREE.Vector3();
		var quaternionWorld = new THREE.Quaternion();
		var scaleWorld = new THREE.Vector3();

		return function ( force ) {

			this.matrixAutoUpdate && this.updateMatrix();

			// update matrixWorld

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent ) {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

					this.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );
					this.matrix.decompose( translationObject, quaternionObject, scaleObject );

					this.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );


				} else {

					this.matrixWorld.copy( this.matrix );

				}


				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].updateMatrixWorld( force );

			}

		};
		
	}() );

	// File:src/extras/core/Path.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/

	THREE.Path = function ( points ) {

		THREE.CurvePath.call(this);

		this.actions = [];

		if ( points ) {

			this.fromPoints( points );

		}

	};

	THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
	THREE.Path.prototype.constructor = THREE.Path;

	THREE.PathActions = {

		MOVE_TO: 'moveTo',
		LINE_TO: 'lineTo',
		QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
		BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
		CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
		ARC: 'arc',								// Circle
		ELLIPSE: 'ellipse'
	};

	// TODO Clean up PATH API

	// Create path using straight lines to connect all points
	// - vectors: array of Vector2

	THREE.Path.prototype.fromPoints = function ( vectors ) {

		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

		for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

			this.lineTo( vectors[ v ].x, vectors[ v ].y );

		};

	};

	// startPath() endPath()?

	THREE.Path.prototype.moveTo = function ( x, y ) {

		var args = Array.prototype.slice.call( arguments );
		this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

	};

	THREE.Path.prototype.lineTo = function ( x, y ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

	};

	THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
													new THREE.Vector2( aCPx, aCPy ),
													new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

	};

	THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
												   aCP2x, aCP2y,
												   aX, aY ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCP1x, aCP1y ),
												new THREE.Vector2( aCP2x, aCP2y ),
												new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

	};

	THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

		var args = Array.prototype.slice.call( arguments );
		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	//---
		var npts = [ new THREE.Vector2( x0, y0 ) ];
		Array.prototype.push.apply( npts, pts );

		var curve = new THREE.SplineCurve( npts );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

	};

	// FUTURE: Change the API or follow canvas API?

	THREE.Path.prototype.arc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {

		var lastargs = this.actions[ this.actions.length - 1].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		this.absarc(aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

	 };

	 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
		this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
	 };

	THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise ) {

		var lastargs = this.actions[ this.actions.length - 1].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
			aStartAngle, aEndAngle, aClockwise );

	 };


	THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise ) {

		var args = Array.prototype.slice.call( arguments );
		var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
										aStartAngle, aEndAngle, aClockwise );
		this.curves.push( curve );

		var lastPoint = curve.getPoint(1);
		args.push(lastPoint.x);
		args.push(lastPoint.y);

		this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

	 };

	THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

		if ( ! divisions ) divisions = 40;

		var points = [];

		for ( var i = 0; i < divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

			//if( !this.getPoint( i / divisions ) ) throw "DIE";

		}

		// if ( closedPath ) {
		//
		// 	points.push( points[ 0 ] );
		//
		// }

		return points;

	};

	/* Return an array of vectors based on contour of the path */

	THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

		if (this.useSpacedPoints) {
			console.log('tata');
			return this.getSpacedPoints( divisions, closedPath );
		}

		divisions = divisions || 12;

		var points = [];

		var i, il, item, action, args;
		var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
			laste, j,
			t, tx, ty;

		for ( i = 0, il = this.actions.length; i < il; i ++ ) {

			item = this.actions[ i ];

			action = item.action;
			args = item.args;

			switch ( action ) {

			case THREE.PathActions.MOVE_TO:

				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

				break;

			case THREE.PathActions.LINE_TO:

				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

				break;

			case THREE.PathActions.QUADRATIC_CURVE_TO:

				cpx  = args[ 2 ];
				cpy  = args[ 3 ];

				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];

				if ( points.length > 0 ) {

					laste = points[ points.length - 1 ];

					cpx0 = laste.x;
					cpy0 = laste.y;

				} else {

					laste = this.actions[ i - 1 ].args;

					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];

				}

				for ( j = 1; j <= divisions; j ++ ) {

					t = j / divisions;

					tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
					ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

					points.push( new THREE.Vector2( tx, ty ) );

				}

				break;

			case THREE.PathActions.BEZIER_CURVE_TO:

				cpx  = args[ 4 ];
				cpy  = args[ 5 ];

				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];

				cpx2 = args[ 2 ];
				cpy2 = args[ 3 ];

				if ( points.length > 0 ) {

					laste = points[ points.length - 1 ];

					cpx0 = laste.x;
					cpy0 = laste.y;

				} else {

					laste = this.actions[ i - 1 ].args;

					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];

				}


				for ( j = 1; j <= divisions; j ++ ) {

					t = j / divisions;

					tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
					ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

					points.push( new THREE.Vector2( tx, ty ) );

				}

				break;

			case THREE.PathActions.CSPLINE_THRU:

				laste = this.actions[ i - 1 ].args;

				var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
				var spts = [ last ];

				var n = divisions * args[ 0 ].length;

				spts = spts.concat( args[ 0 ] );

				var spline = new THREE.SplineCurve( spts );

				for ( j = 1; j <= n; j ++ ) {

					points.push( spline.getPointAt( j / n ) ) ;

				}

				break;

			case THREE.PathActions.ARC:

				var aX = args[ 0 ], aY = args[ 1 ],
					aRadius = args[ 2 ],
					aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
					aClockwise = !! args[ 5 ];

				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;

				for ( j = 1; j <= tdivisions; j ++ ) {

					t = j / tdivisions;

					if ( ! aClockwise ) {

						t = 1 - t;

					}

					angle = aStartAngle + t * deltaAngle;

					tx = aX + aRadius * Math.cos( angle );
					ty = aY + aRadius * Math.sin( angle );

					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

					points.push( new THREE.Vector2( tx, ty ) );

				}

				//console.log(points);

				break;
			  
			case THREE.PathActions.ELLIPSE:

				var aX = args[ 0 ], aY = args[ 1 ],
					xRadius = args[ 2 ],
					yRadius = args[ 3 ],
					aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
					aClockwise = !! args[ 6 ];


				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;

				for ( j = 1; j <= tdivisions; j ++ ) {

					t = j / tdivisions;

					if ( ! aClockwise ) {

						t = 1 - t;

					}

					angle = aStartAngle + t * deltaAngle;

					tx = aX + xRadius * Math.cos( angle );
					ty = aY + yRadius * Math.sin( angle );

					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

					points.push( new THREE.Vector2( tx, ty ) );

				}

				//console.log(points);

				break;

			} // end switch

		}



		// Normalize to remove the closing point by default.
		var lastPoint = points[ points.length - 1];
		var EPSILON = 0.0000000001;
		if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
				 Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
			points.splice( points.length - 1, 1);
		if ( closedPath ) {

			points.push( points[ 0 ] );

		}

		return points;

	};

	//
	// Breaks path into shapes
	//
	//	Assumptions (if parameter isCCW==true the opposite holds):
	//	- solid shapes are defined clockwise (CW)
	//	- holes are defined counterclockwise (CCW)
	//
	//	If parameter noHoles==true:
	//  - all subPaths are regarded as solid shapes
	//  - definition order CW/CCW has no relevance
	//

	THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

		function extractSubpaths( inActions ) {

			var i, il, item, action, args;

			var subPaths = [], lastPath = new THREE.Path();

			for ( i = 0, il = inActions.length; i < il; i ++ ) {

				item = inActions[ i ];

				args = item.args;
				action = item.action;

				if ( action == THREE.PathActions.MOVE_TO ) {

					if ( lastPath.actions.length != 0 ) {

						subPaths.push( lastPath );
						lastPath = new THREE.Path();

					}

				}

				lastPath[ action ].apply( lastPath, args );

			}

			if ( lastPath.actions.length != 0 ) {

				subPaths.push( lastPath );

			}

			// console.log(subPaths);

			return	subPaths;
		}

		function toShapesNoHoles( inSubpaths ) {

			var shapes = [];

			for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {

				var tmpPath = inSubpaths[ i ];

				var tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );
			}

			//console.log("shape", shapes);

			return shapes;
		};

		function isPointInsidePolygon( inPt, inPolygon ) {
			var EPSILON = 0.0000000001;

			var polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
				var edgeLowPt  = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];

				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs(edgeDy) > EPSILON ) {			// not parallel
					if ( edgeDy < 0 ) {
						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y == edgeLowPt.y ) {
						if ( inPt.x == edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!
					} else {
						var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
						if ( perpEdge == 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt
					}
				} else {		// parallel or colinear
					if ( inPt.y != edgeLowPt.y ) 		continue;			// parallel
					// egde lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;
				}
			}

			return	inside;
		}


		var subPaths = extractSubpaths( this.actions );
		if ( subPaths.length == 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		var solid, tmpPath, tmpShape, shapes = [];

		if ( subPaths.length == 1) {

			tmpPath = subPaths[0];
			tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);
		
		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;

		newShapes[mainIdx] = undefined;
		newShapeHoles[mainIdx] = [];

		var i, il;

		for ( i = 0, il = subPaths.length; i < il; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = THREE.Shape.Utils.isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( (! holesFirst ) && ( newShapes[mainIdx] ) )	mainIdx ++;

				newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
				newShapes[mainIdx].s.actions = tmpPath.actions;
				newShapes[mainIdx].s.curves = tmpPath.curves;
				
				if ( holesFirst )	mainIdx ++;
				newShapeHoles[mainIdx] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[0] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {
			var ambigious = false;
			var toChange = [];

			for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
				betterShapeHoles[sIdx] = [];
			}
			for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
				var sho = newShapeHoles[sIdx];
				for (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
					var ho = sho[hIdx];
					var hole_unassigned = true;
					for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
						if ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {
							if ( sIdx != s2Idx )		toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {
								hole_unassigned = false;
								betterShapeHoles[s2Idx].push( ho );
							} else {
								ambigious = true;
							}
						}
					}
					if ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }
				}
			}
			// console.log("ambigious: ", ambigious);
			if ( toChange.length > 0 ) {
				// console.log("to change: ", toChange);
				if (! ambigious)	newShapeHoles = betterShapeHoles;
			}
		}

		var tmpHoles, j, jl;
		for ( i = 0, il = newShapes.length; i < il; i ++ ) {
			tmpShape = newShapes[i].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[i];
			for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
				tmpShape.holes.push( tmpHoles[j].h );
			}
		}

		//console.log("shape", shapes);

		return shapes;

	};

	// File:src/extras/core/Shape.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	THREE.Shape = function () {

		THREE.Path.apply( this, arguments );
		this.holes = [];

	};

	THREE.Shape.prototype = Object.create( THREE.Path.prototype );
	THREE.Shape.prototype.constructor = THREE.Shape;

	// Convenience method to return ExtrudeGeometry

	THREE.Shape.prototype.extrude = function ( options ) {

		var extruded = new THREE.ExtrudeGeometry( this, options );
		return extruded;

	};

	// Convenience method to return ShapeGeometry

	THREE.Shape.prototype.makeGeometry = function ( options ) {

		var geometry = new THREE.ShapeGeometry( this, options );
		return geometry;

	};

	// Get points of holes

	THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

		var i, il = this.holes.length, holesPts = [];

		for ( i = 0; i < il; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

		}

		return holesPts;

	};

	// Get points of holes (spaced by regular distance)

	THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

		var i, il = this.holes.length, holesPts = [];

		for ( i = 0; i < il; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

		}

		return holesPts;

	};


	// Get points of shape and holes (keypoints based on segments parameter)

	THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

		return {

			shape: this.getTransformedPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	};

	THREE.Shape.prototype.extractPoints = function ( divisions ) {

		if (this.useSpacedPoints) {
			return this.extractAllSpacedPoints(divisions);
		}

		return this.extractAllPoints(divisions);

	};

	//
	// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
	//
	// 	return {
	//
	// 		shape: this.transform( bend, divisions ),
	// 		holes: this.getPointsHoles( divisions, bend )
	//
	// 	};
	//
	// };

	// Get points of shape and holes (spaced by regular distance)

	THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

		return {

			shape: this.getTransformedSpacedPoints( divisions ),
			holes: this.getSpacedPointsHoles( divisions )

		};

	};

	/**************************************************************
	 *	Utils
	 **************************************************************/

	THREE.Shape.Utils = {

		triangulateShape: function ( contour, holes ) {

			function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
				// inOtherPt needs to be colinear to the inSegment
				if ( inSegPt1.x != inSegPt2.x ) {
					if ( inSegPt1.x < inSegPt2.x ) {
						return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
					} else {
						return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
					}
				} else {
					if ( inSegPt1.y < inSegPt2.y ) {
						return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
					} else {
						return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
					}
				}
			}

			function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
				var EPSILON = 0.0000000001;

				var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
				var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

				var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
				var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

				var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
				var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

				if ( Math.abs(limit) > EPSILON ) {			// not parallel

					var perpSeg2;
					if ( limit > 0 ) {
						if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
					} else {
						if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
					}

					// i.e. to reduce rounding errors
					// intersection at endpoint of segment#1?
					if ( perpSeg2 == 0 ) {
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
						return [ inSeg1Pt1 ];
					}
					if ( perpSeg2 == limit ) {
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
						return [ inSeg1Pt2 ];
					}
					// intersection at endpoint of segment#2?
					if ( perpSeg1 == 0 )		return [ inSeg2Pt1 ];
					if ( perpSeg1 == limit )	return [ inSeg2Pt2 ];

					// return real intersection point
					var factorSeg1 = perpSeg2 / limit;
					return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
								y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

				} else {		// parallel or colinear
					if ( ( perpSeg1 != 0 ) ||
						 ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) 			return [];

					// they are collinear or degenerate
					var seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );	// segment1 ist just a point?
					var seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );	// segment2 ist just a point?
					// both segments are points
					if ( seg1Pt && seg2Pt ) {
						if ( (inSeg1Pt1.x != inSeg2Pt1.x) ||
							 (inSeg1Pt1.y != inSeg2Pt1.y) )		return [];   	// they are distinct  points
						return [ inSeg1Pt1 ];                 					// they are the same point
					}
					// segment#1  is a single point
					if ( seg1Pt ) {
						if (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
						return [ inSeg1Pt1 ];
					}
					// segment#2  is a single point
					if ( seg2Pt ) {
						if (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
						return [ inSeg2Pt1 ];
					}

					// they are collinear segments, which might overlap
					var seg1min, seg1max, seg1minVal, seg1maxVal;
					var seg2min, seg2max, seg2minVal, seg2maxVal;
					if (seg1dx != 0) {		// the segments are NOT on a vertical line
						if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
						} else {
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
						}
						if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
						} else {
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
						}
					} else {				// the segments are on a vertical line
						if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
						} else {
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
						}
						if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
						} else {
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
						}
					}
					if ( seg1minVal <= seg2minVal ) {
						if ( seg1maxVal <  seg2minVal )	return [];
						if ( seg1maxVal == seg2minVal )	{
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg2min ];
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
						return	[ seg2min, seg2max ];
					} else {
						if ( seg1minVal >  seg2maxVal )	return [];
						if ( seg1minVal == seg2maxVal )	{
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg1min ];
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
						return	[ seg1min, seg2max ];
					}
				}
			}

			function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
				// The order of legs is important

				var EPSILON = 0.0000000001;

				// translation of all points, so that Vertex is at (0,0)
				var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
				var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
				var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

				// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
				var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
				var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

				if ( Math.abs(from2toAngle) > EPSILON ) {			// angle != 180 deg.

					var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
					// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

					if ( from2toAngle > 0 ) {				// main angle < 180 deg.
						return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
					} else {								// main angle > 180 deg.
						return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
					}
				} else {										// angle == 180 deg.
					// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
					return	( from2otherAngle > 0 );
				}
			}


			function removeHoles( contour, holes ) {

				var shape = contour.concat(); // work on this shape
				var hole;

				function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
					// Check if hole point lies within angle around shape point
					var lastShapeIdx = shape.length - 1;

					var prevShapeIdx = inShapeIdx - 1;
					if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

					var nextShapeIdx = inShapeIdx + 1;
					if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

					var insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );
					if (! insideAngle ) {
						// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
						return	false;
					}

					// Check if shape point lies within angle around hole point
					var lastHoleIdx = hole.length - 1;

					var prevHoleIdx = inHoleIdx - 1;
					if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

					var nextHoleIdx = inHoleIdx + 1;
					if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

					insideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );
					if (! insideAngle ) {
						// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
						return	false;
					}

					return	true;
				}

				function intersectsShapeEdge( inShapePt, inHolePt ) {
					// checks for intersections with shape edges
					var sIdx, nextIdx, intersection;
					for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
						nextIdx = sIdx + 1; nextIdx %= shape.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );
						if ( intersection.length > 0 )		return	true;
					}

					return	false;
				}

				var indepHoles = [];

				function intersectsHoleEdge( inShapePt, inHolePt ) {
					// checks for intersections with hole edges
					var ihIdx, chkHole,
						hIdx, nextIdx, intersection;
					for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
						chkHole = holes[indepHoles[ihIdx]];
						for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
							nextIdx = hIdx + 1; nextIdx %= chkHole.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );
							if ( intersection.length > 0 )		return	true;
						}
					}
					return	false;
				}

				var holeIndex, shapeIndex,
					shapePt, holePt,
					holeIdx, cutKey, failedCuts = [],
					tmpShape1, tmpShape2,
					tmpHole1, tmpHole2;

				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

					indepHoles.push( h );

				}

				var minShapeIndex = 0;
				var counter = indepHoles.length * 2;
				while ( indepHoles.length > 0 ) {
					counter --;
					if ( counter < 0 ) {
						console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
						break;
					}

					// search for shape-vertex and hole-vertex,
					// which can be connected without intersections
					for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

						shapePt = shape[ shapeIndex ];
						holeIndex	= - 1;

						// search for hole which can be reached without intersections
						for ( var h = 0; h < indepHoles.length; h ++ ) {
							holeIdx = indepHoles[h];

							// prevent multiple checks
							cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
							if ( failedCuts[cutKey] !== undefined )			continue;

							hole = holes[holeIdx];
							for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
								holePt = hole[ h2 ];
								if (! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
								if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
								if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

								holeIndex = h2;
								indepHoles.splice(h, 1);

								tmpShape1 = shape.slice( 0, shapeIndex + 1 );
								tmpShape2 = shape.slice( shapeIndex );
								tmpHole1 = hole.slice( holeIndex );
								tmpHole2 = hole.slice( 0, holeIndex + 1 );

								shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

								minShapeIndex = shapeIndex;

								// Debug only, to show the selected cuts
								// glob_CutLines.push( [ shapePt, holePt ] );

								break;
							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found

							failedCuts[cutKey] = true;			// remember failure
						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found
					}
				}

				return shape; 			/* shape with no holes */
			}


			var i, il, f, face,
				key, index,
				allPointsMap = {};

			// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

			var allpoints = contour.concat();

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				Array.prototype.push.apply( allpoints, holes[h] );

			}

			//console.log( "allpoints",allpoints, allpoints.length );

			// prepare all points map

			for ( i = 0, il = allpoints.length; i < il; i ++ ) {

				key = allpoints[ i ].x + ":" + allpoints[ i ].y;

				if ( allPointsMap[ key ] !== undefined ) {

					THREE.warn( "THREE.Shape: Duplicate point", key );

				}

				allPointsMap[ key ] = i;

			}

			// remove holes by cutting paths to holes and adding them to the shape
			var shapeWithoutHoles = removeHoles( contour, holes );

			var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
			//console.log( "triangles",triangles, triangles.length );

			// check all face vertices against all points map

			for ( i = 0, il = triangles.length; i < il; i ++ ) {

				face = triangles[ i ];

				for ( f = 0; f < 3; f ++ ) {

					key = face[ f ].x + ":" + face[ f ].y;

					index = allPointsMap[ key ];

					if ( index !== undefined ) {

						face[ f ] = index;

					}

				}

			}

			return triangles.concat();

		},

		isClockWise: function ( pts ) {

			return THREE.FontUtils.Triangulate.area( pts ) < 0;

		},

		// Bezier Curves formulas obtained from
		// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

		// Quad Bezier Functions

		b2p0: function ( t, p ) {

			var k = 1 - t;
			return k * k * p;

		},

		b2p1: function ( t, p ) {

			return 2 * ( 1 - t ) * t * p;

		},

		b2p2: function ( t, p ) {

			return t * t * p;

		},

		b2: function ( t, p0, p1, p2 ) {

			return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

		},

		// Cubic Bezier Functions

		b3p0: function ( t, p ) {

			var k = 1 - t;
			return k * k * k * p;

		},

		b3p1: function ( t, p ) {

			var k = 1 - t;
			return 3 * k * k * t * p;

		},

		b3p2: function ( t, p ) {

			var k = 1 - t;
			return 3 * k * t * t * p;

		},

		b3p3: function ( t, p ) {

			return t * t * t * p;

		},

		b3: function ( t, p0, p1, p2, p3 ) {

			return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

		}

	};


	// File:src/extras/curves/LineCurve.js

	/**************************************************************
	 *	Line
	 **************************************************************/

	THREE.LineCurve = function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	};

	THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.LineCurve.prototype.constructor = THREE.LineCurve;

	THREE.LineCurve.prototype.getPoint = function ( t ) {

		var point = this.v2.clone().sub(this.v1);
		point.multiplyScalar( t ).add( this.v1 );

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	THREE.LineCurve.prototype.getPointAt = function ( u ) {

		return this.getPoint( u );

	};

	THREE.LineCurve.prototype.getTangent = function( t ) {

		var tangent = this.v2.clone().sub(this.v1);

		return tangent.normalize();

	};

	// File:src/extras/curves/QuadraticBezierCurve.js

	/**************************************************************
	 *	Quadratic Bezier curve
	 **************************************************************/


	THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	};

	THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


	THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

		var vector = new THREE.Vector2();

		vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

		return vector;

	};


	THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

		var vector = new THREE.Vector2();

		vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

		// returns unit vector

		return vector.normalize();

	};

	// File:src/extras/curves/CubicBezierCurve.js

	/**************************************************************
	 *	Cubic Bezier curve
	 **************************************************************/

	THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	};

	THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

	THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

		var tx, ty;

		tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

		return new THREE.Vector2( tx, ty );

	};

	THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

		var tx, ty;

		tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

		var tangent = new THREE.Vector2( tx, ty );
		tangent.normalize();

		return tangent;

	};

	// File:src/extras/curves/SplineCurve.js

	/**************************************************************
	 *	Spline curve
	 **************************************************************/

	THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

		this.points = ( points == undefined ) ? [] : points;

	};

	THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

	THREE.SplineCurve.prototype.getPoint = function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ]
		var point1 = points[ intPoint ]
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ]
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ]

		var vector = new THREE.Vector2();

		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

		return vector;

	};

	// File:src/extras/curves/EllipseCurve.js

	/**************************************************************
	 *	Ellipse curve
	 **************************************************************/

	THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;

	};

	THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

	THREE.EllipseCurve.prototype.getPoint = function ( t ) {

		var deltaAngle = this.aEndAngle - this.aStartAngle;

		if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
		if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

		var angle;

		if ( this.aClockwise === true ) {

			angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

		} else {

			angle = this.aStartAngle + t * deltaAngle;

		}
		
		var vector = new THREE.Vector2();

		vector.x = this.aX + this.xRadius * Math.cos( angle );
		vector.y = this.aY + this.yRadius * Math.sin( angle );

		return vector;

	};

	// File:src/extras/curves/ArcCurve.js

	/**************************************************************
	 *	Arc curve
	 **************************************************************/

	THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	};

	THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
	THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

	// File:src/extras/curves/LineCurve3.js

	/**************************************************************
	 *	Line3D
	 **************************************************************/

	THREE.LineCurve3 = THREE.Curve.create(

		function ( v1, v2 ) {

			this.v1 = v1;
			this.v2 = v2;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );

			return vector;

		}

	);

	// File:src/extras/curves/QuadraticBezierCurve3.js

	/**************************************************************
	 *	Quadratic Bezier 3D curve
	 **************************************************************/

	THREE.QuadraticBezierCurve3 = THREE.Curve.create(

		function ( v0, v1, v2 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
			vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
			vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

			return vector;

		}

	);

	// File:src/extras/curves/CubicBezierCurve3.js

	/**************************************************************
	 *	Cubic Bezier 3D curve
	 **************************************************************/

	THREE.CubicBezierCurve3 = THREE.Curve.create(

		function ( v0, v1, v2, v3 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
			vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
			vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

			return vector;

		}

	);

	// File:src/extras/curves/SplineCurve3.js

	/**************************************************************
	 *	Spline 3D curve
	 **************************************************************/


	THREE.SplineCurve3 = THREE.Curve.create(

		function ( points /* array of Vector3 */) {

			this.points = ( points == undefined ) ? [] : points;

		},

		function ( t ) {

			var points = this.points;
			var point = ( points.length - 1 ) * t;

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

			var vector = new THREE.Vector3();

			vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
			vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
			vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

			return vector;

		}

	);

	// File:src/extras/curves/ClosedSplineCurve3.js

	/**************************************************************
	 *	Closed Spline 3D curve
	 **************************************************************/


	THREE.ClosedSplineCurve3 = THREE.Curve.create(

		function ( points /* array of Vector3 */) {

			this.points = ( points == undefined ) ? [] : points;

		},

		function ( t ) {

			var points = this.points;
			var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

			var point0 = points[ ( intPoint - 1 ) % points.length ];
			var point1 = points[ ( intPoint     ) % points.length ];
			var point2 = points[ ( intPoint + 1 ) % points.length ];
			var point3 = points[ ( intPoint + 2 ) % points.length ];

			var vector = new THREE.Vector3();

			vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
			vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
			vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

			return vector;

		}

	);

	// File:src/extras/animation/AnimationHandler.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 */

	THREE.AnimationHandler = {

		LINEAR: 0,
		CATMULLROM: 1,
		CATMULLROM_FORWARD: 2,

		//

		add: function () { THREE.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },
		get: function () { THREE.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },
		remove: function () { THREE.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },

		//

		animations: [],

		init: function ( data ) {

			if ( data.initialized === true ) return data;

			// loop through all keys

			for ( var h = 0; h < data.hierarchy.length; h ++ ) {

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					// remove minus times

					if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

						 data.hierarchy[ h ].keys[ k ].time = 0;

					}

					// create quaternions

					if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
					  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

						var quat = data.hierarchy[ h ].keys[ k ].rot;
						data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

					}

				}

				// prepare morph target keys

				if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

					// get all used

					var usedMorphTargets = {};

					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
							usedMorphTargets[ morphTargetName ] = - 1;

						}

					}

					data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


					// set all used on all frames

					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

						var influences = {};

						for ( var morphTargetName in usedMorphTargets ) {

							for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

								if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

									influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
									break;

								}

							}

							if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

								influences[ morphTargetName ] = 0;

							}

						}

						data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

					}

				}


				// remove all keys that are on the same time

				for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

					if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

						data.hierarchy[ h ].keys.splice( k, 1 );
						k --;

					}

				}


				// set index

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					data.hierarchy[ h ].keys[ k ].index = k;

				}

			}

			data.initialized = true;

			return data;

		},

		parse: function ( root ) {

			var parseRecurseHierarchy = function ( root, hierarchy ) {

				hierarchy.push( root );

				for ( var c = 0; c < root.children.length; c ++ )
					parseRecurseHierarchy( root.children[ c ], hierarchy );

			};

			// setup hierarchy

			var hierarchy = [];

			if ( root instanceof THREE.SkinnedMesh ) {

				for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {

					hierarchy.push( root.skeleton.bones[ b ] );

				}

			} else {

				parseRecurseHierarchy( root, hierarchy );

			}

			return hierarchy;

		},

		play: function ( animation ) {

			if ( this.animations.indexOf( animation ) === - 1 ) {

				this.animations.push( animation );

			}

		},

		stop: function ( animation ) {

			var index = this.animations.indexOf( animation );

			if ( index !== - 1 ) {

				this.animations.splice( index, 1 );

			}

		},

		update: function ( deltaTimeMS ) {

			for ( var i = 0; i < this.animations.length; i ++ ) {

				this.animations[ i ].resetBlendWeights( );

			}

			for ( var i = 0; i < this.animations.length; i ++ ) {

				this.animations[ i ].update( deltaTimeMS );

			}

		}

	};

	// File:src/extras/animation/Animation.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Animation = function ( root, data ) {

		this.root = root;
		this.data = THREE.AnimationHandler.init( data );
		this.hierarchy = THREE.AnimationHandler.parse( root );

		this.currentTime = 0;
		this.timeScale = 1;

		this.isPlaying = false;
		this.loop = true;
		this.weight = 0;

		this.interpolationType = THREE.AnimationHandler.LINEAR;

	};

	THREE.Animation.prototype = {

		constructor: THREE.Animation,

		keyTypes:  [ "pos", "rot", "scl" ],

		play: function ( startTime, weight ) {

			this.currentTime = startTime !== undefined ? startTime : 0;
			this.weight = weight !== undefined ? weight : 1;

			this.isPlaying = true;

			this.reset();

			THREE.AnimationHandler.play( this );

		},

		stop: function() {

			this.isPlaying = false;

			THREE.AnimationHandler.stop( this );

		},

		reset: function () {

			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

				var object = this.hierarchy[ h ];

				if ( object.animationCache === undefined ) {

					object.animationCache = {
						animations: {},
						blending: {
							positionWeight: 0.0,
							quaternionWeight: 0.0,
							scaleWeight: 0.0
						}
					};
				}

				var name = this.data.name;
				var animations = object.animationCache.animations;
				var animationCache = animations[ name ];

				if ( animationCache === undefined ) {

					animationCache = {
						prevKey: { pos: 0, rot: 0, scl: 0 },
						nextKey: { pos: 0, rot: 0, scl: 0 },
						originalMatrix: object.matrix
					};

					animations[ name ] = animationCache;

				}

				// Get keys to match our current time

				for ( var t = 0; t < 3; t ++ ) {

					var type = this.keyTypes[ t ];

					var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
					var nextKey = this.getNextKeyWith( type, h, 1 );

					while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

						prevKey = nextKey;
						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

					}

					animationCache.prevKey[ type ] = prevKey;
					animationCache.nextKey[ type ] = nextKey;

				}

			}

		},

		resetBlendWeights: function () {

			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

				var object = this.hierarchy[ h ];
				var animationCache = object.animationCache;

				if ( animationCache !== undefined ) {

					var blending = animationCache.blending;

					blending.positionWeight = 0.0;
					blending.quaternionWeight = 0.0;
					blending.scaleWeight = 0.0;

				}

			}

		},

		update: ( function() {

			var points = [];
			var target = new THREE.Vector3();
			var newVector = new THREE.Vector3();
			var newQuat = new THREE.Quaternion();

			// Catmull-Rom spline

			var interpolateCatmullRom = function ( points, scale ) {

				var c = [], v3 = [],
				point, intPoint, weight, w2, w3,
				pa, pb, pc, pd;

				point = ( points.length - 1 ) * scale;
				intPoint = Math.floor( point );
				weight = point - intPoint;

				c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
				c[ 1 ] = intPoint;
				c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
				c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

				pa = points[ c[ 0 ] ];
				pb = points[ c[ 1 ] ];
				pc = points[ c[ 2 ] ];
				pd = points[ c[ 3 ] ];

				w2 = weight * weight;
				w3 = weight * w2;

				v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
				v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
				v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

				return v3;

			};

			var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

				var v0 = ( p2 - p0 ) * 0.5,
					v1 = ( p3 - p1 ) * 0.5;

				return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

			};

			return function ( delta ) {

				if ( this.isPlaying === false ) return;

				this.currentTime += delta * this.timeScale;

				if ( this.weight === 0 )
					return;

				//

				var duration = this.data.length;

				if ( this.currentTime > duration || this.currentTime < 0 ) {

					if ( this.loop ) {

						this.currentTime %= duration;

						if ( this.currentTime < 0 )
							this.currentTime += duration;

						this.reset();

					} else {

						this.stop();

					}

				}

				for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

					var object = this.hierarchy[ h ];
					var animationCache = object.animationCache.animations[this.data.name];
					var blending = object.animationCache.blending;

					// loop through pos/rot/scl

					for ( var t = 0; t < 3; t ++ ) {

						// get keys

						var type    = this.keyTypes[ t ];
						var prevKey = animationCache.prevKey[ type ];
						var nextKey = animationCache.nextKey[ type ];

						if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
							( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

							prevKey = this.data.hierarchy[ h ].keys[ 0 ];
							nextKey = this.getNextKeyWith( type, h, 1 );

							while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

								prevKey = nextKey;
								nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

							}

							animationCache.prevKey[ type ] = prevKey;
							animationCache.nextKey[ type ] = nextKey;

						}

						var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

						var prevXYZ = prevKey[ type ];
						var nextXYZ = nextKey[ type ];

						if ( scale < 0 ) scale = 0;
						if ( scale > 1 ) scale = 1;

						// interpolate

						if ( type === "pos" ) {

							if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

								newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
								newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
								newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

								// blend
								var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
								object.position.lerp( newVector, proportionalWeight );
								blending.positionWeight += this.weight;

							} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
										this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

								points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
								points[ 1 ] = prevXYZ;
								points[ 2 ] = nextXYZ;
								points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

								scale = scale * 0.33 + 0.33;

								var currentPoint = interpolateCatmullRom( points, scale );
								var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
								blending.positionWeight += this.weight;

								// blend

								var vector = object.position;

								vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
								vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
								vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

								if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

									var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

									target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
									target.sub( vector );
									target.y = 0;
									target.normalize();

									var angle = Math.atan2( target.x, target.z );
									object.rotation.set( 0, angle, 0 );

								}

							}

						} else if ( type === "rot" ) {

							THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

							// Avoid paying the cost of an additional slerp if we don't have to
							if ( blending.quaternionWeight === 0 ) {

								object.quaternion.copy(newQuat);
								blending.quaternionWeight = this.weight;

							} else {

								var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
								THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
								blending.quaternionWeight += this.weight;

							}

						} else if ( type === "scl" ) {

							newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
							newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
							newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

							var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
							object.scale.lerp( newVector, proportionalWeight );
							blending.scaleWeight += this.weight;

						}

					}

				}

				return true;

			};

		} )(),

		getNextKeyWith: function ( type, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;

			if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
				 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

				key = key < keys.length - 1 ? key : keys.length - 1;

			} else {

				key = key % keys.length;

			}

			for ( ; key < keys.length; key ++ ) {

				if ( keys[ key ][ type ] !== undefined ) {

					return keys[ key ];

				}

			}

			return this.data.hierarchy[ h ].keys[ 0 ];

		},

		getPrevKeyWith: function ( type, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;

			if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
				this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

				key = key > 0 ? key : 0;

			} else {

				key = key >= 0 ? key : key + keys.length;

			}


			for ( ; key >= 0; key -- ) {

				if ( keys[ key ][ type ] !== undefined ) {

					return keys[ key ];

				}

			}

			return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

		}

	};

	// File:src/extras/animation/KeyFrameAnimation.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author khang duong
	 * @author erik kitson
	 */

	THREE.KeyFrameAnimation = function ( data ) {

		this.root = data.node;
		this.data = THREE.AnimationHandler.init( data );
		this.hierarchy = THREE.AnimationHandler.parse( this.root );
		this.currentTime = 0;
		this.timeScale = 0.001;
		this.isPlaying = false;
		this.isPaused = true;
		this.loop = true;

		// initialize to first keyframes

		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

			var keys = this.data.hierarchy[h].keys,
				sids = this.data.hierarchy[h].sids,
				obj = this.hierarchy[h];

			if ( keys.length && sids ) {

				for ( var s = 0; s < sids.length; s ++ ) {

					var sid = sids[ s ],
						next = this.getNextKeyWith( sid, h, 0 );

					if ( next ) {

						next.apply( sid );

					}

				}

				obj.matrixAutoUpdate = false;
				this.data.hierarchy[h].node.updateMatrix();
				obj.matrixWorldNeedsUpdate = true;

			}

		}

	};

	THREE.KeyFrameAnimation.prototype = {

		constructor: THREE.KeyFrameAnimation,

		play: function ( startTime ) {

			this.currentTime = startTime !== undefined ? startTime : 0;

			if ( this.isPlaying === false ) {

				this.isPlaying = true;

				// reset key cache

				var h, hl = this.hierarchy.length,
					object,
					node;

				for ( h = 0; h < hl; h ++ ) {

					object = this.hierarchy[ h ];
					node = this.data.hierarchy[ h ];

					if ( node.animationCache === undefined ) {

						node.animationCache = {};
						node.animationCache.prevKey = null;
						node.animationCache.nextKey = null;
						node.animationCache.originalMatrix = object.matrix;

					}

					var keys = this.data.hierarchy[h].keys;

					if (keys.length) {

						node.animationCache.prevKey = keys[ 0 ];
						node.animationCache.nextKey = keys[ 1 ];

						this.startTime = Math.min( keys[0].time, this.startTime );
						this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

					}

				}

				this.update( 0 );

			}

			this.isPaused = false;

			THREE.AnimationHandler.play( this );

		},

		stop: function () {

			this.isPlaying = false;
			this.isPaused  = false;

			THREE.AnimationHandler.stop( this );

			// reset JIT matrix and remove cache

			for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {

				var obj = this.hierarchy[ h ];
				var node = this.data.hierarchy[ h ];

				if ( node.animationCache !== undefined ) {

					var original = node.animationCache.originalMatrix;

					original.copy( obj.matrix );
					obj.matrix = original;

					delete node.animationCache;

				}

			}

		},

		update: function ( delta ) {

			if ( this.isPlaying === false ) return;

			this.currentTime += delta * this.timeScale;

			//

			var duration = this.data.length;

			if ( this.loop === true && this.currentTime > duration ) {

				this.currentTime %= duration;

			}

			this.currentTime = Math.min( this.currentTime, duration );

			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

				var object = this.hierarchy[ h ];
				var node = this.data.hierarchy[ h ];

				var keys = node.keys,
					animationCache = node.animationCache;


				if ( keys.length ) {

					var prevKey = animationCache.prevKey;
					var nextKey = animationCache.nextKey;

					if ( nextKey.time <= this.currentTime ) {

						while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

							prevKey = nextKey;
							nextKey = keys[ prevKey.index + 1 ];

						}

						animationCache.prevKey = prevKey;
						animationCache.nextKey = nextKey;

					}

					if ( nextKey.time >= this.currentTime ) {

						prevKey.interpolate( nextKey, this.currentTime );

					} else {

						prevKey.interpolate( nextKey, nextKey.time );

					}

					this.data.hierarchy[ h ].node.updateMatrix();
					object.matrixWorldNeedsUpdate = true;

				}

			}

		},

		getNextKeyWith: function ( sid, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;
			key = key % keys.length;

			for ( ; key < keys.length; key ++ ) {

				if ( keys[ key ].hasTarget( sid ) ) {

					return keys[ key ];

				}

			}

			return keys[ 0 ];

		},

		getPrevKeyWith: function ( sid, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;
			key = key >= 0 ? key : key + keys.length;

			for ( ; key >= 0; key -- ) {

				if ( keys[ key ].hasTarget( sid ) ) {

					return keys[ key ];

				}

			}

			return keys[ keys.length - 1 ];

		}

	};

	// File:src/extras/animation/MorphAnimation.js

	/**
	 * @author mrdoob / http://mrdoob.com
	 * @author willy-vvu / http://willy-vvu.github.io
	 */

	THREE.MorphAnimation = function ( mesh ) {

		this.mesh = mesh;
		this.frames = mesh.morphTargetInfluences.length;
		this.currentTime = 0;
		this.duration = 1000;
		this.loop = true;
		this.lastFrame = 0;
		this.currentFrame = 0;

		this.isPlaying = false;

	};

	THREE.MorphAnimation.prototype = {

		constructor: THREE.MorphAnimation,

		play: function () {

			this.isPlaying = true;

		},

		pause: function () {

			this.isPlaying = false;

		},

		update: function ( delta ) {

			if ( this.isPlaying === false ) return;

			this.currentTime += delta;

			if ( this.loop === true && this.currentTime > this.duration ) {

				this.currentTime %= this.duration;

			}

			this.currentTime = Math.min( this.currentTime, this.duration );

			var interpolation = this.duration / this.frames;
			var frame = Math.floor( this.currentTime / interpolation );

			var influences = this.mesh.morphTargetInfluences;

			if ( frame != this.currentFrame ) {

				influences[ this.lastFrame ] = 0;
				influences[ this.currentFrame ] = 1;
				influences[ frame ] = 0;

				this.lastFrame = this.currentFrame;
				this.currentFrame = frame;

			}

			influences[ frame ] = ( this.currentTime % interpolation ) / interpolation;
			influences[ this.lastFrame ] = 1 - influences[ frame ];

		}

	};

	// File:src/extras/geometries/BoxGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */

	THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		THREE.Geometry.call( this );

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.widthSegments = widthSegments || 1;
		this.heightSegments = heightSegments || 1;
		this.depthSegments = depthSegments || 1;

		var scope = this;

		var width_half = width / 2;
		var height_half = height / 2;
		var depth_half = depth / 2;

		buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
		buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
		buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
		buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
		buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
		buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

		function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

			var w, ix, iy,
			gridX = scope.widthSegments,
			gridY = scope.heightSegments,
			width_half = width / 2,
			height_half = height / 2,
			offset = scope.vertices.length;

			if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

				w = 'z';

			} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

				w = 'y';
				gridY = scope.depthSegments;

			} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

				w = 'x';
				gridX = scope.depthSegments;

			}

			var gridX1 = gridX + 1,
			gridY1 = gridY + 1,
			segment_width = width / gridX,
			segment_height = height / gridY,
			normal = new THREE.Vector3();

			normal[ w ] = depth > 0 ? 1 : - 1;

			for ( iy = 0; iy < gridY1; iy ++ ) {

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var vector = new THREE.Vector3();
					vector[ u ] = ( ix * segment_width - width_half ) * udir;
					vector[ v ] = ( iy * segment_height - height_half ) * vdir;
					vector[ w ] = depth;

					scope.vertices.push( vector );

				}

			}

			for ( iy = 0; iy < gridY; iy ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;

					var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
					var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
					var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
					var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

					var face = new THREE.Face3( a + offset, b + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;

					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

					face = new THREE.Face3( b + offset, c + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;

					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

				}

			}

		}

		this.mergeVertices();

	};

	THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

	// File:src/extras/geometries/CircleGeometry.js

	/**
	 * @author hughes
	 */

	THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 50;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		var i, uvs = [],
		center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

		this.vertices.push(center);
		uvs.push( centerUV );

		for ( i = 0; i <= segments; i ++ ) {

			var vertex = new THREE.Vector3();
			var segment = thetaStart + i / segments * thetaLength;

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

		}

		var n = new THREE.Vector3( 0, 0, 1 );

		for ( i = 1; i <= segments; i ++ ) {

			this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

		}

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

	// File:src/extras/geometries/CubeGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		THREE.warn( 'THREE.CubeGeometry has been renamed to THREE.BoxGeometry.' );
		return new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments );

	 };

	// File:src/extras/geometries/CylinderGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radiusTop = radiusTop !== undefined ? radiusTop : 20;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
		height = height !== undefined ? height : 100;

		radialSegments = radialSegments || 8;
		heightSegments = heightSegments || 1;

		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

		var heightHalf = height / 2;

		var x, y, vertices = [], uvs = [];

		for ( y = 0; y <= heightSegments; y ++ ) {

			var verticesRow = [];
			var uvsRow = [];

			var v = y / heightSegments;
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;

				var vertex = new THREE.Vector3();
				vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
				vertex.y = - v * height + heightHalf;
				vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

				this.vertices.push( vertex );

				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );

			}

			vertices.push( verticesRow );
			uvs.push( uvsRow );

		}

		var tanTheta = ( radiusBottom - radiusTop ) / height;
		var na, nb;

		for ( x = 0; x < radialSegments; x ++ ) {

			if ( radiusTop !== 0 ) {

				na = this.vertices[ vertices[ 0 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

			} else {

				na = this.vertices[ vertices[ 1 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

			}

			na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
			nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

			for ( y = 0; y < heightSegments; y ++ ) {

				var v1 = vertices[ y ][ x ];
				var v2 = vertices[ y + 1 ][ x ];
				var v3 = vertices[ y + 1 ][ x + 1 ];
				var v4 = vertices[ y ][ x + 1 ];

				var n1 = na.clone();
				var n2 = na.clone();
				var n3 = nb.clone();
				var n4 = nb.clone();

				var uv1 = uvs[ y ][ x ].clone();
				var uv2 = uvs[ y + 1 ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
				var uv4 = uvs[ y ][ x + 1 ].clone();

				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

			}

		}

		// top cap

		if ( openEnded === false && radiusTop > 0 ) {

			this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

			for ( x = 0; x < radialSegments; x ++ ) {

				var v1 = vertices[ 0 ][ x ];
				var v2 = vertices[ 0 ][ x + 1 ];
				var v3 = this.vertices.length - 1;

				var n1 = new THREE.Vector3( 0, 1, 0 );
				var n2 = new THREE.Vector3( 0, 1, 0 );
				var n3 = new THREE.Vector3( 0, 1, 0 );

				var uv1 = uvs[ 0 ][ x ].clone();
				var uv2 = uvs[ 0 ][ x + 1 ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 0 );

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			}

		}

		// bottom cap

		if ( openEnded === false && radiusBottom > 0 ) {

			this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

			for ( x = 0; x < radialSegments; x ++ ) {

				var v1 = vertices[ heightSegments ][ x + 1 ];
				var v2 = vertices[ heightSegments ][ x ];
				var v3 = this.vertices.length - 1;

				var n1 = new THREE.Vector3( 0, - 1, 0 );
				var n2 = new THREE.Vector3( 0, - 1, 0 );
				var n3 = new THREE.Vector3( 0, - 1, 0 );

				var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
				var uv2 = uvs[ heightSegments ][ x ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 1 );

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			}

		}

		this.computeFaceNormals();

	};

	THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

	// File:src/extras/geometries/ExtrudeGeometry.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
	 *
	 *  material: <int> // material index for front and back faces
	 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/

	THREE.ExtrudeGeometry = function ( shapes, options ) {

		if ( typeof( shapes ) === "undefined" ) {
			shapes = [];
			return;
		}

		THREE.Geometry.call( this );

		this.type = 'ExtrudeGeometry';

		shapes = shapes instanceof Array ? shapes : [ shapes ];

		this.addShapeList( shapes, options );

		this.computeFaceNormals();

		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides

		//this.computeVertexNormals();

		//console.log( "took", ( Date.now() - startTime ) );

	};

	THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

	THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
		var sl = shapes.length;

		for ( var s = 0; s < sl; s ++ ) {
			var shape = shapes[ s ];
			this.addShape( shape, options );
		}
	};

	THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

		var amount = options.amount !== undefined ? options.amount : 100;

		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var steps = options.steps !== undefined ? options.steps : 1;

		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;

		var material = options.material;
		var extrudeMaterial = options.extrudeMaterial;

		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {

			extrudePts = extrudePath.getSpacedPoints( steps );

			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion

			// SETUP TNB variables

			// Reuse TNB from TubeGeomtry for now.
			// TODO1 - have a .isClosed in spline?

			splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

			binormal = new THREE.Vector3();
			normal = new THREE.Vector3();
			position2 = new THREE.Vector3();

		}

		// Safeguards if bevels are not enabled

		if ( ! bevelEnabled ) {

			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;

		}

		// Variables initalization

		var ahole, h, hl; // looping of holes
		var scope = this;

		var shapesOffset = this.vertices.length;

		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe ...

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

					holes[ h ] = ahole.reverse();

				}

			}

			reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

		}


		var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

		/* Vertices */

		var contour = vertices; // vertices has all points but contour has only points of circumference

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			vertices = vertices.concat( ahole );

		}


		function scalePt2 ( pt, vec, size ) {

			if ( ! vec ) THREE.error( "THREE.ExtrudeGeometry: vec does not exist" );

			return vec.clone().multiplyScalar( size ).add( pt );

		}

		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;


		// Find directions for point movement


		function getBevelVec( inPt, inPrev, inNext ) {

			var EPSILON = 0.0000000001;
			
			// computes for inPt the corresponding point inPt' on a new contour
			//   shiftet by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.
			
			var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html

			var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
			
			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
			
			// check for colinear edges
			var colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
			
			if ( Math.abs( colinear0 ) > EPSILON ) {		// not colinear
				
				// length of vectors for normalizing
		
				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
				
				// shift adjacent points by unit vectors to the left
		
				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
				
				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
		
				// scaling factor for v_prev to intersection point
		
				var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
						  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
		
				// vector from inPt to intersection point
		
				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
		
				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )
				if ( v_trans_lensq <= 2 ) {
					return	new THREE.Vector2( v_trans_x, v_trans_y );
				} else {
					shrink_by = Math.sqrt( v_trans_lensq / 2 );
				}
				
			} else {		// handle special case of colinear edges

				var direction_eq = false;		// assumes: opposite
				if ( v_prev_x > EPSILON ) {
					if ( v_next_x > EPSILON ) { direction_eq = true; }
				} else {
					if ( v_prev_x < - EPSILON ) {
						if ( v_next_x < - EPSILON ) { direction_eq = true; }
					} else {
						if ( Math.sign(v_prev_y) == Math.sign(v_next_y) ) { direction_eq = true; }
					}
				}

				if ( direction_eq ) {
					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y =  v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );
				} else {
					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );
				}

			}

			return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

		}


		var contourMovements = [];

		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)

			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

		}

		var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			oneHoleMovements = [];

			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

			}

			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );

		}


		// Loop bevelSegments, 1 for the front, 1 for the back

		for ( b = 0; b < bevelSegments; b ++ ) {
		//for ( b = bevelSegments; b > 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );

			//z = bevelThickness * t;
			bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ) ; // curved
			//bs = bevelSize * t ; // linear

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					v( vert.x, vert.y,  - z );

				}

			}

		}

		bs = bevelSize;

		// Back facing vertices

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, 0 );

			} else {

				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

				normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
				binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

				position2.copy( extrudePts[0] ).add(normal).add(binormal);

				v( position2.x, position2.y, position2.z );

			}

		}

		// Add stepped vertices...
		// Including front facing vertices

		var s;

		for ( s = 1; s <= steps; s ++ ) {

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, amount / steps * s );

				} else {

					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

					normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[s] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

		}


		// Add bevel segments planes

		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
			//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
			bs = bevelSize * Math.sin ( t * Math.PI / 2 ) ;

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y,  amount + z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y,  amount + z );

					} else {

						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

					}

				}

			}

		}

		/* Faces */

		// Top and bottom faces

		buildLidFaces();

		// Sides faces

		buildSideFaces();


		/////  Internal functions

		function buildLidFaces() {

			if ( bevelEnabled ) {

				var layer = 0 ; // steps + 1
				var offset = vlen * layer;

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

				}

				layer = steps + bevelSegments * 2;
				offset = vlen * layer;

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

				}

			} else {

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );

				}

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

				}
			}

		}

		// Create faces for the z-sides of the shape

		function buildSideFaces() {

			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );

				//, true
				layeroffset += ahole.length;

			}

		}

		function sidewalls( contour, layeroffset ) {

			var j, k;
			i = contour.length;

			while ( -- i >= 0 ) {

				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;

				//console.log('b', i,j, i-1, k,vertices.length);

				var s = 0, sl = steps  + bevelSegments * 2;

				for ( s = 0; s < sl; s ++ ) {

					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );

					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;

					f4( a, b, c, d, contour, s, sl, j, k );

				}
			}

		}


		function v( x, y, z ) {

			scope.vertices.push( new THREE.Vector3( x, y, z ) );

		}

		function f3( a, b, c ) {

			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;

			// normal, color, material
			scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );

			var uvs = uvgen.generateTopUV( scope, a, b, c );

			scope.faceVertexUvs[ 0 ].push( uvs );

		}

		function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
			d += shapesOffset;

			scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );
			scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );

			var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

			scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

		}

	};

	THREE.ExtrudeGeometry.WorldUVGenerator = {

		generateTopUV: function ( geometry, indexA, indexB, indexC ) {

			var vertices = geometry.vertices;

			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];

			return [
				new THREE.Vector2( a.x, a.y ),
				new THREE.Vector2( b.x, b.y ),
				new THREE.Vector2( c.x, c.y )
			];

		},

		generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

			var vertices = geometry.vertices;

			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
			var d = vertices[ indexD ];

			if ( Math.abs( a.y - b.y ) < 0.01 ) {
				return [
					new THREE.Vector2( a.x, 1 - a.z ),
					new THREE.Vector2( b.x, 1 - b.z ),
					new THREE.Vector2( c.x, 1 - c.z ),
					new THREE.Vector2( d.x, 1 - d.z )
				];
			} else {
				return [
					new THREE.Vector2( a.y, 1 - a.z ),
					new THREE.Vector2( b.y, 1 - b.z ),
					new THREE.Vector2( c.y, 1 - c.z ),
					new THREE.Vector2( d.y, 1 - d.z )
				];
			}
		}
	};

	// File:src/extras/geometries/ShapeGeometry.js

	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *	material: <int> // material index for front and back faces
	 *	uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/

	THREE.ShapeGeometry = function ( shapes, options ) {

		THREE.Geometry.call( this );

		this.type = 'ShapeGeometry';

		if ( shapes instanceof Array === false ) shapes = [ shapes ];

		this.addShapeList( shapes, options );

		this.computeFaceNormals();

	};

	THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

	/**
	 * Add an array of shapes to THREE.ShapeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

			this.addShape( shapes[ i ], options );

		}

		return this;

	};

	/**
	 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

		if ( options === undefined ) options = {};
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var material = options.material;
		var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

		//

		var i, l, hole;

		var shapesOffset = this.vertices.length;
		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe...

			for ( i = 0, l = holes.length; i < l; i ++ ) {

				hole = holes[ i ];

				if ( THREE.Shape.Utils.isClockWise( hole ) ) {

					holes[ i ] = hole.reverse();

				}

			}

			reverse = false;

		}

		var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

		// Vertices

		var contour = vertices;

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];
			vertices = vertices.concat( hole );

		}

		//

		var vert, vlen = vertices.length;
		var face, flen = faces.length;

		for ( i = 0; i < vlen; i ++ ) {

			vert = vertices[ i ];

			this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

		}

		for ( i = 0; i < flen; i ++ ) {

			face = faces[ i ];

			var a = face[ 0 ] + shapesOffset;
			var b = face[ 1 ] + shapesOffset;
			var c = face[ 2 ] + shapesOffset;

			this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
			this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

		}

	};

	// File:src/extras/geometries/LatheGeometry.js

	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 */

	// points - to create a closed torus, one must use a set of points 
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2*PI) range of the lathed section
	//    2*pi is a closed lathe, less than 2PI is a portion.

	THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

		THREE.Geometry.call( this );

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = segments || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || 2 * Math.PI;

		var inversePointLength = 1.0 / ( points.length - 1 );
		var inverseSegments = 1.0 / segments;

		for ( var i = 0, il = segments; i <= il; i ++ ) {

			var phi = phiStart + i * inverseSegments * phiLength;

			var c = Math.cos( phi ),
				s = Math.sin( phi );

			for ( var j = 0, jl = points.length; j < jl; j ++ ) {

				var pt = points[ j ];

				var vertex = new THREE.Vector3();

				vertex.x = c * pt.x - s * pt.y;
				vertex.y = s * pt.x + c * pt.y;
				vertex.z = pt.z;

				this.vertices.push( vertex );

			}

		}

		var np = points.length;

		for ( var i = 0, il = segments; i < il; i ++ ) {

			for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

				var base = j + np * i;
				var a = base;
				var b = base + np;
				var c = base + 1 + np;
				var d = base + 1;

				var u0 = i * inverseSegments;
				var v0 = j * inversePointLength;
				var u1 = u0 + inverseSegments;
				var v1 = v0 + inversePointLength;

				this.faces.push( new THREE.Face3( a, b, d ) );

				this.faceVertexUvs[ 0 ].push( [

					new THREE.Vector2( u0, v0 ),
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u0, v1 )

				] );

				this.faces.push( new THREE.Face3( b, c, d ) );

				this.faceVertexUvs[ 0 ].push( [

					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u1, v1 ),
					new THREE.Vector2( u0, v1 )

				] );


			}

		}

		this.mergeVertices();
		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

	// File:src/extras/geometries/PlaneGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

		console.info( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );

		THREE.Geometry.call( this );

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

	};

	THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

	// File:src/extras/geometries/PlaneBufferGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

		THREE.BufferGeometry.call( this );

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		var width_half = width / 2;
		var height_half = height / 2;

		var gridX = widthSegments || 1;
		var gridY = heightSegments || 1;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var segment_width = width / gridX;
		var segment_height = height / gridY;

		var vertices = new Float32Array( gridX1 * gridY1 * 3 );
		var normals = new Float32Array( gridX1 * gridY1 * 3 );
		var uvs = new Float32Array( gridX1 * gridY1 * 2 );

		var offset = 0;
		var offset2 = 0;

		for ( var iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segment_height - height_half;

			for ( var ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segment_width - width_half;

				vertices[ offset     ] = x;
				vertices[ offset + 1 ] = - y;

				normals[ offset + 2 ] = 1;

				uvs[ offset2     ] = ix / gridX;
				uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

				offset += 3;
				offset2 += 2;

			}

		}

		offset = 0;

		var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

		for ( var iy = 0; iy < gridY; iy ++ ) {

			for ( var ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				indices[ offset     ] = a;
				indices[ offset + 1 ] = b;
				indices[ offset + 2 ] = d;

				indices[ offset + 3 ] = b;
				indices[ offset + 4 ] = c;
				indices[ offset + 5 ] = d;

				offset += 6;

			}

		}

		this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	};

	THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

	// File:src/extras/geometries/RingGeometry.js

	/**
	 * @author Kaleb Murphy
	 */

	THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		innerRadius = innerRadius || 0;
		outerRadius = outerRadius || 50;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

		var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

		for ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring

			for ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle

				var vertex = new THREE.Vector3();
				var segment = thetaStart + o / thetaSegments * thetaLength;
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				this.vertices.push( vertex );
				uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
			}

			radius += radiusStep;

		}

		var n = new THREE.Vector3( 0, 0, 1 );

		for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring

			var thetaSegment = i * (thetaSegments + 1);

			for ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle

				var segment = o + thetaSegment;

				var v1 = segment;
				var v2 = segment + thetaSegments + 1;
				var v3 = segment + thetaSegments + 2;

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

				v1 = segment;
				v2 = segment + thetaSegments + 2;
				v3 = segment + 1;

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

			}
		}

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;


	// File:src/extras/geometries/SphereGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength 
		};

		radius = radius || 50;

		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		var x, y, vertices = [], uvs = [];

		for ( y = 0; y <= heightSegments; y ++ ) {

			var verticesRow = [];
			var uvsRow = [];

			for ( x = 0; x <= widthSegments; x ++ ) {

				var u = x / widthSegments;
				var v = y / heightSegments;

				var vertex = new THREE.Vector3();
				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				this.vertices.push( vertex );

				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );

			}

			vertices.push( verticesRow );
			uvs.push( uvsRow );

		}

		for ( y = 0; y < heightSegments; y ++ ) {

			for ( x = 0; x < widthSegments; x ++ ) {

				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = vertices[ y + 1 ][ x ];
				var v4 = vertices[ y + 1 ][ x + 1 ];

				var n1 = this.vertices[ v1 ].clone().normalize();
				var n2 = this.vertices[ v2 ].clone().normalize();
				var n3 = this.vertices[ v3 ].clone().normalize();
				var n4 = this.vertices[ v4 ].clone().normalize();

				var uv1 = uvs[ y ][ x + 1 ].clone();
				var uv2 = uvs[ y ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x ].clone();
				var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

				if ( Math.abs( this.vertices[ v1 ].y ) === radius ) {

					uv1.x = ( uv1.x + uv2.x ) / 2;
					this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

				} else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {

					uv3.x = ( uv3.x + uv4.x ) / 2;
					this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

				} else {

					this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

					this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

				}

			}

		}

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

	// File:src/extras/geometries/TextGeometry.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For creating 3D text geometry in three.js
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  size: 			<float>, 	// size of the text
	 *  height: 		<float>, 	// thickness to extrude text
	 *  curveSegments: 	<int>,		// number of points on the curves
	 *
	 *  font: 			<string>,		// font name
	 *  weight: 		<string>,		// font weight (normal, bold)
	 *  style: 			<string>,		// font style  (normal, italics)
	 *
	 *  bevelEnabled:	<bool>,			// turn on bevel
	 *  bevelThickness: <float>, 		// how deep into text bevel goes
	 *  bevelSize:		<float>, 		// how far from text outline is bevel
	 *  }
	 *
	 */

	/*	Usage Examples

		// TextGeometry wrapper

		var text3d = new TextGeometry( text, options );

		// Complete manner

		var textShapes = THREE.FontUtils.generateShapes( text, options );
		var text3d = new ExtrudeGeometry( textShapes, options );

	*/


	THREE.TextGeometry = function ( text, parameters ) {

		parameters = parameters || {};

		var textShapes = THREE.FontUtils.generateShapes( text, parameters );

		// translate parameters to ExtrudeGeometry API

		parameters.amount = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		THREE.ExtrudeGeometry.call( this, textShapes, parameters );

		this.type = 'TextGeometry';

	};

	THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
	THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;

	// File:src/extras/geometries/TorusGeometry.js

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */

	THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

		THREE.Geometry.call( this );

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 8;
		tubularSegments = tubularSegments || 6;
		arc = arc || Math.PI * 2;

		var center = new THREE.Vector3(), uvs = [], normals = [];

		for ( var j = 0; j <= radialSegments; j ++ ) {

			for ( var i = 0; i <= tubularSegments; i ++ ) {

				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );

				var vertex = new THREE.Vector3();
				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				this.vertices.push( vertex );

				uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
				normals.push( vertex.clone().sub( center ).normalize() );

			}

		}

		for ( var j = 1; j <= radialSegments; j ++ ) {

			for ( var i = 1; i <= tubularSegments; i ++ ) {

				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;

				var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

				face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

			}

		}

		this.computeFaceNormals();

	};

	THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

	// File:src/extras/geometries/TorusKnotGeometry.js

	/**
	 * @author oosmoxiecode
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
	 */

	THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

		THREE.Geometry.call( this );

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			p: p,
			q: q,
			heightScale: heightScale
		};

		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 64;
		tubularSegments = tubularSegments || 8;
		p = p || 2;
		q = q || 3;
		heightScale = heightScale || 1;
		
		var grid = new Array( radialSegments );
		var tang = new THREE.Vector3();
		var n = new THREE.Vector3();
		var bitan = new THREE.Vector3();

		for ( var i = 0; i < radialSegments; ++ i ) {

			grid[ i ] = new Array( tubularSegments );
			var u = i / radialSegments * 2 * p * Math.PI;
			var p1 = getPos( u, q, p, radius, heightScale );
			var p2 = getPos( u + 0.01, q, p, radius, heightScale );
			tang.subVectors( p2, p1 );
			n.addVectors( p2, p1 );

			bitan.crossVectors( tang, n );
			n.crossVectors( bitan, tang );
			bitan.normalize();
			n.normalize();

			for ( var j = 0; j < tubularSegments; ++ j ) {

				var v = j / tubularSegments * 2 * Math.PI;
				var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				var cy = tube * Math.sin( v );

				var pos = new THREE.Vector3();
				pos.x = p1.x + cx * n.x + cy * bitan.x;
				pos.y = p1.y + cx * n.y + cy * bitan.y;
				pos.z = p1.z + cx * n.z + cy * bitan.z;

				grid[ i ][ j ] = this.vertices.push( pos ) - 1;

			}

		}

		for ( var i = 0; i < radialSegments; ++ i ) {

			for ( var j = 0; j < tubularSegments; ++ j ) {

				var ip = ( i + 1 ) % radialSegments;
				var jp = ( j + 1 ) % tubularSegments;

				var a = grid[ i ][ j ];
				var b = grid[ ip ][ j ];
				var c = grid[ ip ][ jp ];
				var d = grid[ i ][ jp ];

				var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
				var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
				var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
				var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}
		}

		this.computeFaceNormals();
		this.computeVertexNormals();

		function getPos( u, in_q, in_p, radius, heightScale ) {

			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = in_q / in_p * u;
			var cs = Math.cos( quOverP );

			var tx = radius * ( 2 + cs ) * 0.5 * cu;
			var ty = radius * ( 2 + cs ) * su * 0.5;
			var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

			return new THREE.Vector3( tx, ty, tz );

		}

	};

	THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

	// File:src/extras/geometries/TubeGeometry.js

	/**
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 *
	 * Modified from the TorusKnotGeometry by @oosmoxiecode
	 *
	 * Creates a tube which extrudes along a 3d spline
	 *
	 * Uses parallel transport frames as described in
	 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	 */

	THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

		THREE.Geometry.call( this );

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			segments: segments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		segments = segments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;
		taper = taper || THREE.TubeGeometry.NoTaper;

		var grid = [];

		var scope = this,

			tangent,
			normal,
			binormal,

			numpoints = segments + 1,

			u, v, r,

			cx, cy,
			pos, pos2 = new THREE.Vector3(),
			i, j,
			ip, jp,
			a, b, c, d,
			uva, uvb, uvc, uvd;

		var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
			tangents = frames.tangents,
			normals = frames.normals,
			binormals = frames.binormals;

		// proxy internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;

		function vert( x, y, z ) {

			return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

		}

		// consruct the grid

		for ( i = 0; i < numpoints; i ++ ) {

			grid[ i ] = [];

			u = i / ( numpoints - 1 );

			pos = path.getPointAt( u );

			tangent = tangents[ i ];
			normal = normals[ i ];
			binormal = binormals[ i ];

			r = radius * taper( u );

			for ( j = 0; j < radialSegments; j ++ ) {

				v = j / radialSegments * 2 * Math.PI;

				cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				cy = r * Math.sin( v );

				pos2.copy( pos );
				pos2.x += cx * normal.x + cy * binormal.x;
				pos2.y += cx * normal.y + cy * binormal.y;
				pos2.z += cx * normal.z + cy * binormal.z;

				grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

			}
		}


		// construct the mesh

		for ( i = 0; i < segments; i ++ ) {

			for ( j = 0; j < radialSegments; j ++ ) {

				ip = ( closed ) ? (i + 1) % segments : i + 1;
				jp = (j + 1) % radialSegments;

				a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
				b = grid[ ip ][ j ];
				c = grid[ ip ][ jp ];
				d = grid[ i ][ jp ];

				uva = new THREE.Vector2( i / segments, j / radialSegments );
				uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
				uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
				uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}
		}

		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

	THREE.TubeGeometry.NoTaper = function ( u ) {

		return 1;

	};

	THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

		return Math.sin( Math.PI * u );

	};

	// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
	THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

		var	normal = new THREE.Vector3(),

			tangents = [],
			normals = [],
			binormals = [],

			vec = new THREE.Vector3(),
			mat = new THREE.Matrix4(),

			numpoints = segments + 1,
			theta,
			epsilon = 0.0001,
			smallest,

			tx, ty, tz,
			i, u;


		// expose internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;

		// compute the tangent vectors for each segment on the path

		for ( i = 0; i < numpoints; i ++ ) {

			u = i / ( numpoints - 1 );

			tangents[ i ] = path.getTangentAt( u );
			tangents[ i ].normalize();

		}

		initialNormal3();

		/*
		function initialNormal1(lastBinormal) {
			// fixed start binormal. Has dangers of 0 vectors
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
			normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
		}

		function initialNormal2() {

			// This uses the Frenet-Serret formula for deriving binormal
			var t2 = path.getTangentAt( epsilon );

			normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
			binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

			normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

		}
		*/

		function initialNormal3() {
			// select an initial normal vector perpenicular to the first tangent vector,
			// and in the direction of the smallest tangent xyz component

			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			smallest = Number.MAX_VALUE;
			tx = Math.abs( tangents[ 0 ].x );
			ty = Math.abs( tangents[ 0 ].y );
			tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= smallest ) {
				smallest = tx;
				normal.set( 1, 0, 0 );
			}

			if ( ty <= smallest ) {
				smallest = ty;
				normal.set( 0, 1, 0 );
			}

			if ( tz <= smallest ) {
				normal.set( 0, 0, 1 );
			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
		}


		// compute the slowly-varying normal and binormal vectors for each segment on the path

		for ( i = 1; i < numpoints; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > epsilon ) {

				vec.normalize();

				theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}


		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed ) {

			theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
			theta /= ( numpoints - 1 );

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( i = 1; i < numpoints; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}
	};

	// File:src/extras/geometries/PolyhedronGeometry.js

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

		THREE.Geometry.call( this );

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		radius = radius || 1;
		detail = detail || 0;

		var that = this;

		for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

			prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

		}

		var p = this.vertices;

		var faces = [];

		for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

			var v1 = p[ indices[ i     ] ];
			var v2 = p[ indices[ i + 1 ] ];
			var v3 = p[ indices[ i + 2 ] ];

			faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

		}

		var centroid = new THREE.Vector3();

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			subdivide( faces[ i ], detail );

		}


		// Handle case when face straddles the seam

		for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

			var uvs = this.faceVertexUvs[ 0 ][ i ];

			var x0 = uvs[ 0 ].x;
			var x1 = uvs[ 1 ].x;
			var x2 = uvs[ 2 ].x;

			var max = Math.max( x0, Math.max( x1, x2 ) );
			var min = Math.min( x0, Math.min( x1, x2 ) );

			if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

				if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
				if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
				if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

			}

		}


		// Apply radius

		for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

			this.vertices[ i ].multiplyScalar( radius );

		}


		// Merge vertices

		this.mergeVertices();

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


		// Project vector onto sphere's surface

		function prepare( vector ) {

			var vertex = vector.normalize().clone();
			vertex.index = that.vertices.push( vertex ) - 1;

			// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

			var u = azimuth( vector ) / 2 / Math.PI + 0.5;
			var v = inclination( vector ) / Math.PI + 0.5;
			vertex.uv = new THREE.Vector2( u, 1 - v );

			return vertex;

		}


		// Approximate a curved face with recursively sub-divided triangles.

		function make( v1, v2, v3 ) {

			var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
			that.faces.push( face );

			centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

			var azi = azimuth( centroid );

			that.faceVertexUvs[ 0 ].push( [
				correctUV( v1.uv, v1, azi ),
				correctUV( v2.uv, v2, azi ),
				correctUV( v3.uv, v3, azi )
			] );

		}


		// Analytically subdivide a face to the required detail level.

		function subdivide( face, detail ) {

			var cols = Math.pow(2, detail);
			var a = prepare( that.vertices[ face.a ] );
			var b = prepare( that.vertices[ face.b ] );
			var c = prepare( that.vertices[ face.c ] );
			var v = [];

			// Construct all of the vertices for this subdivision.

			for ( var i = 0 ; i <= cols; i ++ ) {

				v[ i ] = [];

				var aj = prepare( a.clone().lerp( c, i / cols ) );
				var bj = prepare( b.clone().lerp( c, i / cols ) );
				var rows = cols - i;

				for ( var j = 0; j <= rows; j ++) {

					if ( j == 0 && i == cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

					}

				}

			}

			// Construct all of the faces.

			for ( var i = 0; i < cols ; i ++ ) {

				for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

					var k = Math.floor( j / 2 );

					if ( j % 2 == 0 ) {

						make(
							v[ i ][ k + 1],
							v[ i + 1 ][ k ],
							v[ i ][ k ]
						);

					} else {

						make(
							v[ i ][ k + 1 ],
							v[ i + 1][ k + 1],
							v[ i + 1 ][ k ]
						);

					}

				}

			}

		}


		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}


		// Texture fixing helper. Spheres have some odd behaviours.

		function correctUV( uv, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
			return uv.clone();

		}


	};

	THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

	// File:src/extras/geometries/DodecahedronGeometry.js

	/**
	 * @author Abe Pazos / https://hamoid.com
	 */

	THREE.DodecahedronGeometry = function ( radius, detail ) {

		this.parameters = {
			radius: radius,
			detail: detail
		};

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;

		var vertices = [

			// (1, 1, 1)
			-1, -1, -1,    -1, -1,  1,
			-1,  1, -1,    -1,  1,  1,
			 1, -1, -1,     1, -1,  1,
			 1,  1, -1,     1,  1,  1,

			// (0, 1/, )
			 0, -r, -t,     0, -r,  t,
			 0,  r, -t,     0,  r,  t,

			// (1/, , 0)
			-r, -t,  0,    -r,  t,  0,
			 r, -t,  0,     r,  t,  0,

			// (, 0, 1/)
			-t,  0, -r,     t,  0, -r,
			-t,  0,  r,     t,  0,  r
		];

		var indices = [
			 3, 11,  7,      3,  7, 15,      3, 15, 13,
			 7, 19, 17,      7, 17,  6,      7,  6, 15,
			17,  4,  8,     17,  8, 10,     17, 10,  6,
			 8,  0, 16,      8, 16,  2,      8,  2, 10,
			 0, 12,  1,      0,  1, 18,      0, 18, 16,
			 6, 10,  2,      6,  2, 13,      6, 13, 15,
			 2, 16, 18,      2, 18,  3,      2,  3, 13,
			18,  1,  9,     18,  9, 11,     18, 11,  3,
			 4, 14, 12,      4, 12,  0,      4,  0,  8,
			11,  9,  5,     11,  5, 19,     11, 19,  7,
			19,  5, 14,     19, 14,  4,     19,  4, 17,
			 1, 12, 14,      1, 14,  5,      1,  5,  9
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	};

	THREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

	// File:src/extras/geometries/IcosahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.IcosahedronGeometry = function ( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;

		var vertices = [
			- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
			 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
			 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
		];

		var indices = [
			 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
			 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
			 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
			 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};
	};

	THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

	// File:src/extras/geometries/OctahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.OctahedronGeometry = function ( radius, detail ) {

		this.parameters = {
			radius: radius,
			detail: detail
		};

		var vertices = [
			1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1
		];

		var indices = [
			0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};
	};

	THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

	// File:src/extras/geometries/TetrahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.TetrahedronGeometry = function ( radius, detail ) {

		var vertices = [
			 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
		];

		var indices = [
			 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

	// File:src/extras/geometries/ParametricGeometry.js

	/**
	 * @author zz85 / https://github.com/zz85
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 *
	 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
	 *
	 */

	THREE.ParametricGeometry = function ( func, slices, stacks ) {

		THREE.Geometry.call( this );

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		var verts = this.vertices;
		var faces = this.faces;
		var uvs = this.faceVertexUvs[ 0 ];

		var i, j, p;
		var u, v;

		var sliceCount = slices + 1;

		for ( i = 0; i <= stacks; i ++ ) {

			v = i / stacks;

			for ( j = 0; j <= slices; j ++ ) {

				u = j / slices;

				p = func( u, v );
				verts.push( p );

			}
		}

		var a, b, c, d;
		var uva, uvb, uvc, uvd;

		for ( i = 0; i < stacks; i ++ ) {

			for ( j = 0; j < slices; j ++ ) {

				a = i * sliceCount + j;
				b = i * sliceCount + j + 1;
				c = (i + 1) * sliceCount + j + 1;
				d = (i + 1) * sliceCount + j;

				uva = new THREE.Vector2( j / slices, i / stacks );
				uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
				uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
				uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

				faces.push( new THREE.Face3( a, b, d ) );
				uvs.push( [ uva, uvb, uvd ] );

				faces.push( new THREE.Face3( b, c, d ) );
				uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

		// console.log(this);

		// magic bullet
		// var diff = this.mergeVertices();
		// console.log('removed ', diff, ' vertices by merging');

		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

	// File:src/extras/helpers/AxisHelper.js

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AxisHelper = function ( size ) {

		size = size || 1;

		var vertices = new Float32Array( [
			0, 0, 0,  size, 0, 0,
			0, 0, 0,  0, size, 0,
			0, 0, 0,  0, 0, size
		] );

		var colors = new Float32Array( [
			1, 0, 0,  1, 0.6, 0,
			0, 1, 0,  0.6, 1, 0,
			0, 0, 1,  0, 0.6, 1
		] );

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

		THREE.Line.call( this, geometry, material, THREE.LinePieces );

	};

	THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

	// File:src/extras/helpers/ArrowHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */

	THREE.ArrowHelper = ( function () {

		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

		var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );

		return function ( dir, origin, length, color, headLength, headWidth ) {

			// dir is assumed to be normalized

			THREE.Object3D.call( this );

			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;

			this.position.copy( origin );

			this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );

			this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );

			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );

		}

	}() );

	THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

	THREE.ArrowHelper.prototype.setDirection = ( function () {

		var axis = new THREE.Vector3();
		var radians;

		return function ( dir ) {

			// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

				this.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

				this.quaternion.set( 1, 0, 0, 0 );

			} else {

				axis.set( dir.z, 0, - dir.x ).normalize();

				radians = Math.acos( dir.y );

				this.quaternion.setFromAxisAngle( axis, radians );

			}

		};

	}() );

	THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.line.scale.set( 1, length - headLength, 1 );
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	};

	THREE.ArrowHelper.prototype.setColor = function ( color ) {

		this.line.material.color.set( color );
		this.cone.material.color.set( color );

	};

	// File:src/extras/helpers/BoxHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BoxHelper = function ( object ) {

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );

		if ( object !== undefined ) {

			this.update( object );

		}

	};

	THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

	THREE.BoxHelper.prototype.update = function ( object ) {

		var geometry = object.geometry;

		if ( geometry.boundingBox === null ) {

			geometry.computeBoundingBox();

		}

		var min = geometry.boundingBox.min;
		var max = geometry.boundingBox.max;

		/*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		var vertices = this.geometry.attributes.position.array;

		vertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;
		vertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;

		vertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;
		vertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;

		vertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;
		vertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;

		vertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;
		vertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;

		//

		vertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;
		vertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;

		vertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;
		vertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;

		vertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;
		vertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;

		vertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;
		vertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;

		//

		vertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;
		vertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;

		vertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;
		vertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;

		vertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;
		vertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;

		vertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;
		vertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;

		this.geometry.attributes.position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	// File:src/extras/helpers/BoundingBoxHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	// a helper to show the world-axis-aligned bounding box for an object

	THREE.BoundingBoxHelper = function ( object, hex ) {

		var color = ( hex !== undefined ) ? hex : 0x888888;

		this.object = object;

		this.box = new THREE.Box3();

		THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

	};

	THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

	THREE.BoundingBoxHelper.prototype.update = function () {

		this.box.setFromObject( this.object );

		this.box.size( this.scale );

		this.box.center( this.position );

	};

	// File:src/extras/helpers/CameraHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	THREE.CameraHelper = function ( camera ) {

		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

		var pointMap = {};

		// colors

		var hexFrustum = 0xffaa00;
		var hexCone = 0xff0000;
		var hexUp = 0x00aaff;
		var hexTarget = 0xffffff;
		var hexCross = 0x333333;

		// near

		addLine( "n1", "n2", hexFrustum );
		addLine( "n2", "n4", hexFrustum );
		addLine( "n4", "n3", hexFrustum );
		addLine( "n3", "n1", hexFrustum );

		// far

		addLine( "f1", "f2", hexFrustum );
		addLine( "f2", "f4", hexFrustum );
		addLine( "f4", "f3", hexFrustum );
		addLine( "f3", "f1", hexFrustum );

		// sides

		addLine( "n1", "f1", hexFrustum );
		addLine( "n2", "f2", hexFrustum );
		addLine( "n3", "f3", hexFrustum );
		addLine( "n4", "f4", hexFrustum );

		// cone

		addLine( "p", "n1", hexCone );
		addLine( "p", "n2", hexCone );
		addLine( "p", "n3", hexCone );
		addLine( "p", "n4", hexCone );

		// up

		addLine( "u1", "u2", hexUp );
		addLine( "u2", "u3", hexUp );
		addLine( "u3", "u1", hexUp );

		// target

		addLine( "c", "t", hexTarget );
		addLine( "p", "c", hexCross );

		// cross

		addLine( "cn1", "cn2", hexCross );
		addLine( "cn3", "cn4", hexCross );

		addLine( "cf1", "cf2", hexCross );
		addLine( "cf3", "cf4", hexCross );

		function addLine( a, b, hex ) {

			addPoint( a, hex );
			addPoint( b, hex );

		}

		function addPoint( id, hex ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( hex ) );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( geometry.vertices.length - 1 );

		}

		THREE.Line.call( this, geometry, material, THREE.LinePieces );

		this.camera = camera;
		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	};

	THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

	THREE.CameraHelper.prototype.update = function () {

		var geometry, pointMap;
		
		var vector = new THREE.Vector3();
		var camera = new THREE.Camera();

		var setPoint = function ( point, x, y, z ) {

			vector.set( x, y, z ).unproject( camera );

			var points = pointMap[ point ];

			if ( points !== undefined ) {

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					geometry.vertices[ points[ i ] ].copy( vector );

				}

			}

		};

		return function () {

			geometry = this.geometry;
			pointMap = this.pointMap;

			var w = 1, h = 1;

			// we need just camera projection matrix
			// world matrix must be identity

			camera.projectionMatrix.copy( this.camera.projectionMatrix );

			// center / target

			setPoint( "c", 0, 0, - 1 );
			setPoint( "t", 0, 0,  1 );

			// near

			setPoint( "n1", - w, - h, - 1 );
			setPoint( "n2",   w, - h, - 1 );
			setPoint( "n3", - w,   h, - 1 );
			setPoint( "n4",   w,   h, - 1 );

			// far

			setPoint( "f1", - w, - h, 1 );
			setPoint( "f2",   w, - h, 1 );
			setPoint( "f3", - w,   h, 1 );
			setPoint( "f4",   w,   h, 1 );

			// up

			setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
			setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
			setPoint( "u3",         0, h * 2,   - 1 );

			// cross

			setPoint( "cf1", - w,   0, 1 );
			setPoint( "cf2",   w,   0, 1 );
			setPoint( "cf3",   0, - h, 1 );
			setPoint( "cf4",   0,   h, 1 );

			setPoint( "cn1", - w,   0, - 1 );
			setPoint( "cn2",   w,   0, - 1 );
			setPoint( "cn3",   0, - h, - 1 );
			setPoint( "cn4",   0,   h, - 1 );

			geometry.verticesNeedUpdate = true;

		};

	}();

	// File:src/extras/helpers/DirectionalLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.DirectionalLightHelper = function ( light, size ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		size = size || 1;

		var geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3( - size,   size, 0 ),
			new THREE.Vector3(   size,   size, 0 ),
			new THREE.Vector3(   size, - size, 0 ),
			new THREE.Vector3( - size, - size, 0 ),
			new THREE.Vector3( - size,   size, 0 )
		);

		var material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.lightPlane = new THREE.Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3(),
			new THREE.Vector3()
		);

		material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine = new THREE.Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	};

	THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

	THREE.DirectionalLightHelper.prototype.dispose = function () {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();
	};

	THREE.DirectionalLightHelper.prototype.update = function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var v3 = new THREE.Vector3();

		return function () {

			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );

			this.lightPlane.lookAt( v3 );
			this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			this.targetLine.geometry.vertices[ 1 ].copy( v3 );
			this.targetLine.geometry.verticesNeedUpdate = true;
			this.targetLine.material.color.copy( this.lightPlane.material.color );

		};

	}();

	// File:src/extras/helpers/EdgesHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @param object THREE.Mesh whose geometry will be used
	 * @param hex line color
	 * @param thresholdAngle the minimim angle (in degrees),
	 * between the face normals of adjacent faces,
	 * that is required to render an edge. A value of 10 means
	 * an edge is only rendered if the angle is at least 10 degrees.
	 */

	THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

		var color = ( hex !== undefined ) ? hex : 0xffffff;
		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

		var edge = [ 0, 0 ], hash = {};
		var sortFunction = function ( a, b ) { return a - b };

		var keys = [ 'a', 'b', 'c' ];
		var geometry = new THREE.BufferGeometry();

		var geometry2;

		if ( object.geometry instanceof THREE.BufferGeometry ) {

			geometry2 = new THREE.Geometry();
			geometry2.fromBufferGeometry( object.geometry );

		} else {

			geometry2 = object.geometry.clone();

		}

		geometry2.mergeVertices();
		geometry2.computeFaceNormals();

		var vertices = geometry2.vertices;
		var faces = geometry2.faces;
		var numEdges = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
					numEdges ++;

				} else {

					hash[ key ].face2 = i;

				}

			}

		}

		var coords = new Float32Array( numEdges * 2 * 3 );

		var index = 0;

		for ( var key in hash ) {

			var h = hash[ key ];

			if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

				var vertex = vertices[ h.vert1 ];
				coords[ index ++ ] = vertex.x;
				coords[ index ++ ] = vertex.y;
				coords[ index ++ ] = vertex.z;

				vertex = vertices[ h.vert2 ];
				coords[ index ++ ] = vertex.x;
				coords[ index ++ ] = vertex.y;
				coords[ index ++ ] = vertex.z;

			}

		}

		geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

	// File:src/extras/helpers/FaceNormalsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		var geometry = new THREE.Geometry();

		var faces = this.object.geometry.faces;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

		}

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

		this.matrixAutoUpdate = false;

		this.normalMatrix = new THREE.Matrix3();

		this.update();

	};

	THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

	THREE.FaceNormalsHelper.prototype.update = function () {

		var vertices = this.geometry.vertices;

		var object = this.object;
		var objectVertices = object.geometry.vertices;
		var objectFaces = object.geometry.faces;
		var objectWorldMatrix = object.matrixWorld;

		object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( objectWorldMatrix );

		for ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {

			var face = objectFaces[ i ];

			vertices[ i2 ].copy( objectVertices[ face.a ] )
				.add( objectVertices[ face.b ] )
				.add( objectVertices[ face.c ] )
				.divideScalar( 3 )
				.applyMatrix4( objectWorldMatrix );

			vertices[ i2 + 1 ].copy( face.normal )
				.applyMatrix3( this.normalMatrix )
				.normalize()
				.multiplyScalar( this.size )
				.add( vertices[ i2 ] );

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	};


	// File:src/extras/helpers/GridHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.GridHelper = function ( size, step ) {

		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

		this.color1 = new THREE.Color( 0x444444 );
		this.color2 = new THREE.Color( 0x888888 );

		for ( var i = - size; i <= size; i += step ) {

			geometry.vertices.push(
				new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
				new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
			);

			var color = i === 0 ? this.color1 : this.color2;

			geometry.colors.push( color, color, color, color );

		}

		THREE.Line.call( this, geometry, material, THREE.LinePieces );

	};

	THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.GridHelper.prototype.constructor = THREE.GridHelper;

	THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

		this.color1.set( colorCenterLine );
		this.color2.set( colorGrid );

		this.geometry.colorsNeedUpdate = true;

	}

	// File:src/extras/helpers/HemisphereLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.HemisphereLightHelper = function ( light, sphereSize ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.colors = [ new THREE.Color(), new THREE.Color() ];

		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

		for ( var i = 0, il = 8; i < il; i ++ ) {

			geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

		}

		var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

		this.lightSphere = new THREE.Mesh( geometry, material );
		this.add( this.lightSphere );

		this.update();

	};

	THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

	THREE.HemisphereLightHelper.prototype.dispose = function () {
		this.lightSphere.geometry.dispose();
		this.lightSphere.material.dispose();
	};

	THREE.HemisphereLightHelper.prototype.update = function () {

		var vector = new THREE.Vector3();

		return function () {

			this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
			this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

			this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
			this.lightSphere.geometry.colorsNeedUpdate = true;

		}

	}();

	// File:src/extras/helpers/PointLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.PointLightHelper = function ( light, sphereSize ) {

		this.light = light;
		this.light.updateMatrixWorld();

		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		THREE.Mesh.call( this, geometry, material );

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

	};

	THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

	THREE.PointLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();
	};

	THREE.PointLightHelper.prototype.update = function () {

		this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	};

	// File:src/extras/helpers/SkeletonHelper.js

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.SkeletonHelper = function ( object ) {

		this.bones = this.getBoneList( object );

		var geometry = new THREE.Geometry();

		for ( var i = 0; i < this.bones.length; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.parent instanceof THREE.Bone ) {

				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );
				geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
				geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

			}

		}

		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

		THREE.Line.call( this, geometry, material, THREE.LinePieces );

		this.root = object;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();

	};


	THREE.SkeletonHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

	THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

		var boneList = [];

		if ( object instanceof THREE.Bone ) {

			boneList.push( object );

		}

		for ( var i = 0; i < object.children.length; i ++ ) {

			boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

		}

		return boneList;

	};

	THREE.SkeletonHelper.prototype.update = function () {

		var geometry = this.geometry;

		var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

		var boneMatrix = new THREE.Matrix4();

		var j = 0;

		for ( var i = 0; i < this.bones.length; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.parent instanceof THREE.Bone ) {

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

				j += 2;

			}

		}

		geometry.verticesNeedUpdate = true;

		geometry.computeBoundingSphere();

	};

	// File:src/extras/helpers/SpotLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.SpotLightHelper = function ( light ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

		geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );
		geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

		this.cone = new THREE.Mesh( geometry, material );
		this.add( this.cone );

		this.update();

	};

	THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

	THREE.SpotLightHelper.prototype.dispose = function () {
		this.cone.geometry.dispose();
		this.cone.material.dispose();
	};

	THREE.SpotLightHelper.prototype.update = function () {

		var vector = new THREE.Vector3();
		var vector2 = new THREE.Vector3();

		return function () {

			var coneLength = this.light.distance ? this.light.distance : 10000;
			var coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( vector2.sub( vector ) );

			this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		};

	}();

	// File:src/extras/helpers/VertexNormalsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xff0000;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		var geometry = new THREE.Geometry();

		var faces = object.geometry.faces;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

			}

		}

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

		this.matrixAutoUpdate = false;

		this.normalMatrix = new THREE.Matrix3();

		this.update();

	};

	THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

	THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {

		var v1 = new THREE.Vector3();

		return function( object ) {

			var keys = [ 'a', 'b', 'c', 'd' ];

			this.object.updateMatrixWorld( true );

			this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var vertices = this.geometry.vertices;

			var verts = this.object.geometry.vertices;

			var faces = this.object.geometry.faces;

			var worldMatrix = this.object.matrixWorld;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					var vertexId = face[ keys[ j ] ];
					var vertex = verts[ vertexId ];

					var normal = face.vertexNormals[ j ];

					vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

					v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

					v1.add( vertices[ idx ] );
					idx = idx + 1;

					vertices[ idx ].copy( v1 );
					idx = idx + 1;

				}

			}

			this.geometry.verticesNeedUpdate = true;

			return this;

		}

	}());

	// File:src/extras/helpers/VertexTangentsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0x0000ff;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		var geometry = new THREE.Geometry();

		var faces = object.geometry.faces;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );

			}

		}

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

		this.matrixAutoUpdate = false;

		this.update();

	};

	THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;

	THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

		var v1 = new THREE.Vector3();

		return function( object ) {

			var keys = [ 'a', 'b', 'c', 'd' ];

			this.object.updateMatrixWorld( true );

			var vertices = this.geometry.vertices;

			var verts = this.object.geometry.vertices;

			var faces = this.object.geometry.faces;

			var worldMatrix = this.object.matrixWorld;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

					var vertexId = face[ keys[ j ] ];
					var vertex = verts[ vertexId ];

					var tangent = face.vertexTangents[ j ];

					vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

					v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );

					v1.add( vertices[ idx ] );
					idx = idx + 1;

					vertices[ idx ].copy( v1 );
					idx = idx + 1;

				}

			}

			this.geometry.verticesNeedUpdate = true;

			return this;

		}

	}());

	// File:src/extras/helpers/WireframeHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WireframeHelper = function ( object, hex ) {

		var color = ( hex !== undefined ) ? hex : 0xffffff;

		var edge = [ 0, 0 ], hash = {};
		var sortFunction = function ( a, b ) { return a - b };

		var keys = [ 'a', 'b', 'c' ];
		var geometry = new THREE.BufferGeometry();

		if ( object.geometry instanceof THREE.Geometry ) {

			var vertices = object.geometry.vertices;
			var faces = object.geometry.faces;
			var numEdges = 0;

			// allocate maximal size
			var edges = new Uint32Array( 6 * faces.length );

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0; j < 3; j ++ ) {

					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );

					var key = edge.toString();

					if ( hash[ key ] === undefined ) {

						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var vertex = vertices[ edges [ 2 * i + j] ];

					var index = 6 * i + 3 * j;
					coords[ index + 0 ] = vertex.x;
					coords[ index + 1 ] = vertex.y;
					coords[ index + 2 ] = vertex.z;

				}

			}

			geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		} else if ( object.geometry instanceof THREE.BufferGeometry ) {

			if ( object.geometry.attributes.index !== undefined ) { // Indexed BufferGeometry

				var vertices = object.geometry.attributes.position.array;
				var indices = object.geometry.attributes.index.array;
				var drawcalls = object.geometry.drawcalls;
				var numEdges = 0;

				if ( drawcalls.length === 0 ) {

					drawcalls = [ { count : indices.length, index : 0, start : 0 } ];

				}

				// allocate maximal size
				var edges = new Uint32Array( 2 * indices.length );

				for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

					var start = drawcalls[ o ].start;
					var count = drawcalls[ o ].count;
					var index = drawcalls[ o ].index;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						for ( var j = 0; j < 3; j ++ ) {

							edge[ 0 ] = index + indices[ i + j ];
							edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];
							edge.sort( sortFunction );

							var key = edge.toString();

							if ( hash[ key ] === undefined ) {

								edges[ 2 * numEdges ] = edge[ 0 ];
								edges[ 2 * numEdges + 1 ] = edge[ 1 ];
								hash[ key ] = true;
								numEdges ++;

							}

						}

					}

				}

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numEdges; i < l; i ++ ) {

					for ( var j = 0; j < 2; j ++ ) {

						var index = 6 * i + 3 * j;
						var index2 = 3 * edges[ 2 * i + j];
						coords[ index + 0 ] = vertices[ index2 ];
						coords[ index + 1 ] = vertices[ index2 + 1 ];
						coords[ index + 2 ] = vertices[ index2 + 2 ];

					}

				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

			} else { // non-indexed BufferGeometry

				var vertices = object.geometry.attributes.position.array;
				var numEdges = vertices.length / 3;
				var numTris = numEdges / 3;

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numTris; i < l; i ++ ) {

					for ( var j = 0; j < 3; j ++ ) {

						var index = 18 * i + 6 * j;

						var index1 = 9 * i + 3 * j;
						coords[ index + 0 ] = vertices[ index1 ];
						coords[ index + 1 ] = vertices[ index1 + 1 ];
						coords[ index + 2 ] = vertices[ index1 + 2 ];

						var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
						coords[ index + 3 ] = vertices[ index2 ];
						coords[ index + 4 ] = vertices[ index2 + 1 ];
						coords[ index + 5 ] = vertices[ index2 + 2 ];

					}

				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

			}

		}

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

	// File:src/extras/objects/ImmediateRenderObject.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.ImmediateRenderObject = function () {

		THREE.Object3D.call( this );

		this.render = function ( renderCallback ) {};

	};

	THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

	// File:src/extras/objects/MorphBlendMesh.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.MorphBlendMesh = function( geometry, material ) {

		THREE.Mesh.call( this, geometry, material );

		this.animationsMap = {};
		this.animationsList = [];

		// prepare default animation
		// (all frames played together in 1 second)

		var numFrames = this.geometry.morphTargets.length;

		var name = "__default";

		var startFrame = 0;
		var endFrame = numFrames - 1;

		var fps = numFrames / 1;

		this.createAnimation( name, startFrame, endFrame, fps );
		this.setAnimationWeight( name, 1 );

	};

	THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

	THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

		var animation = {

			startFrame: start,
			endFrame: end,

			length: end - start + 1,

			fps: fps,
			duration: ( end - start ) / fps,

			lastFrame: 0,
			currentFrame: 0,

			active: false,

			time: 0,
			direction: 1,
			weight: 1,

			directionBackwards: false,
			mirroredLoop: false

		};

		this.animationsMap[ name ] = animation;
		this.animationsList.push( animation );

	};

	THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

		var pattern = /([a-z]+)_?(\d+)/;

		var firstAnimation, frameRanges = {};

		var geometry = this.geometry;

		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

			var morph = geometry.morphTargets[ i ];
			var chunks = morph.name.match( pattern );

			if ( chunks && chunks.length > 1 ) {

				var name = chunks[ 1 ];

				if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

				var range = frameRanges[ name ];

				if ( i < range.start ) range.start = i;
				if ( i > range.end ) range.end = i;

				if ( ! firstAnimation ) firstAnimation = name;

			}

		}

		for ( var name in frameRanges ) {

			var range = frameRanges[ name ];
			this.createAnimation( name, range.start, range.end, fps );

		}

		this.firstAnimation = firstAnimation;

	};

	THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.direction = 1;
			animation.directionBackwards = false;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.direction = - 1;
			animation.directionBackwards = true;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.fps = fps;
			animation.duration = ( animation.end - animation.start ) / animation.fps;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.duration = duration;
			animation.fps = ( animation.end - animation.start ) / animation.duration;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.weight = weight;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.time = time;

		}

	};

	THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

		var time = 0;

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			time = animation.time;

		}

		return time;

	};

	THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

		var duration = - 1;

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			duration = animation.duration;

		}

		return duration;

	};

	THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.time = 0;
			animation.active = true;

		} else {

			THREE.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

		}

	};

	THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.active = false;

		}

	};

	THREE.MorphBlendMesh.prototype.update = function ( delta ) {

		for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

			var animation = this.animationsList[ i ];

			if ( ! animation.active ) continue;

			var frameTime = animation.duration / animation.length;

			animation.time += animation.direction * delta;

			if ( animation.mirroredLoop ) {

				if ( animation.time > animation.duration || animation.time < 0 ) {

					animation.direction *= - 1;

					if ( animation.time > animation.duration ) {

						animation.time = animation.duration;
						animation.directionBackwards = true;

					}

					if ( animation.time < 0 ) {

						animation.time = 0;
						animation.directionBackwards = false;

					}

				}

			} else {

				animation.time = animation.time % animation.duration;

				if ( animation.time < 0 ) animation.time += animation.duration;

			}

			var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
			var weight = animation.weight;

			if ( keyframe !== animation.currentFrame ) {

				this.morphTargetInfluences[ animation.lastFrame ] = 0;
				this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

				this.morphTargetInfluences[ keyframe ] = 0;

				animation.lastFrame = animation.currentFrame;
				animation.currentFrame = keyframe;

			}

			var mix = ( animation.time % frameTime ) / frameTime;

			if ( animation.directionBackwards ) mix = 1 - mix;

			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

		}

	};


	// Export the THREE object for **Node.js**, with
	// backwards-compatibility for the old `require()` API. If we're in
	// the browser, add `_` as a global object via a string identifier,
	// for Closure Compiler "advanced" mode.
	if (true) {
	  if (typeof module !== 'undefined' && module.exports) {
	    exports = module.exports = THREE;
	  }
	  exports.THREE = THREE;
	} else {
	  this['THREE'] = THREE;
	}


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _three = __webpack_require__(2);

	var _three2 = _interopRequireDefault(_three);

	var _datGui = __webpack_require__(4);

	var _datGui2 = _interopRequireDefault(_datGui);

	var _tween = __webpack_require__(7);

	var _tween2 = _interopRequireDefault(_tween);

	var _potree = __webpack_require__(8);

	var _potree2 = _interopRequireDefault(_potree);

	var _stats = __webpack_require__(11);

	var _stats2 = _interopRequireDefault(_stats);

	var _ProgressBar = __webpack_require__(12);

	var _ProgressBar2 = _interopRequireDefault(_ProgressBar);

	var _TransformControls = __webpack_require__(13);

	var _TransformControls2 = _interopRequireDefault(_TransformControls);

	var _FirstPersonControls = __webpack_require__(14);

	var _FirstPersonControls2 = _interopRequireDefault(_FirstPersonControls);

	var _EarthControls = __webpack_require__(15);

	var _EarthControls2 = _interopRequireDefault(_EarthControls);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Viewer = function Viewer(domElement, settings, args) {
	  var scope = this;
	  var defaultSettings = settings;
	  var args = args || {};

	  this.renderArea = domElement;

	  {
	    // create stats fields
	    var createField = function createField(id, top) {
	      var field = document.createElement("div");
	      field.id = id;
	      field.classList.add("info");
	      field.style.position = "absolute";
	      field.style.left = "10px";
	      field.style.top = top + "px";
	      field.style.width = "400px";
	      field.style.color = "white";

	      return field;
	    };

	    var elNumVisibleNodes = createField("lblNumVisibleNodes", 80);
	    var elNumVisiblePoints = createField("lblNumVisiblePoints", 100);

	    scope.renderArea.appendChild(elNumVisibleNodes);
	    scope.renderArea.appendChild(elNumVisiblePoints);
	  }

	  {
	    // infos
	    scope.infos = new function () {

	      var _this = this;

	      this.elements = {};

	      this.domElement = document.createElement("div");
	      this.domElement.id = "infos";
	      this.domElement.classList.add("info");
	      this.domElement.style.position = "fixed";
	      this.domElement.style.left = "10px";
	      this.domElement.style.top = "120px";
	      this.domElement.style.pointerEvents = "none";

	      scope.renderArea.appendChild(this.domElement);

	      this.set = function (key, value) {
	        var element = this.elements[key];
	        if (typeof element === "undefined") {
	          element = document.createElement("div");
	          _this.domElement.appendChild(element);
	          this.elements[key] = element;
	        }

	        element.innerHTML = value;
	      };
	    }();
	  }

	  // { // create toolbar
	  //   var elToolbar = document.createElement("div");
	  //   elToolbar.style.position = "absolute";
	  //   elToolbar.style.width = "400px";
	  //   elToolbar.style.bottom = "10px";
	  //   elToolbar.style.right = "10px";
	  //   this.renderArea.appendChild(elToolbar);

	  //   var createToolIcon = function(icon, title, callback){
	  //     var tool = document.createElement("img");
	  //     tool.src = icon;
	  //     tool.title = title;
	  //     tool.onclick = callback;

	  //     return tool;
	  //   };

	  //   elToolbar.appendChild(createToolIcon(
	  //     "../resources/icons/earth_controls_1.png",
	  //     "Earth Controls",
	  //     function(){scope.useEarthControls()}
	  //   ));

	  //   elToolbar.appendChild(createToolIcon(
	  //     "../resources/icons/fps_controls.png",
	  //     "Flight Controls",
	  //     function(){scope.useFPSControls()}
	  //   ));

	  //   elToolbar.appendChild(createToolIcon(
	  //     "../resources/icons/orbit_controls.png",
	  //     "Orbit Controls",
	  //     function(){scope.useOrbitControls()}
	  //   ));

	  //   elToolbar.appendChild(createToolIcon(
	  //     "../resources/icons/focus.png",
	  //     "focus on pointcloud",
	  //     function(){scope.zoomTo(viewer.pointcloud)}
	  //   ));

	  //   elToolbar.appendChild(createToolIcon(
	  //     "../resources/icons/flip_y_z.png",
	  //     "flip y and z coordinates",
	  //     function(){scope.flipYZ()}
	  //   ));

	  //   elToolbar.appendChild(createToolIcon(
	  //     "../resources/icons/angle.png",
	  //     "angle measurements",
	  //     function(){scope.measuringTool.startInsertion({showDistances: false, showAngles: true, showArea: false, closed: true, maxMarkers: 3})}
	  //   ));

	  //   elToolbar.appendChild(createToolIcon(
	  //     "../resources/icons/distance.png",
	  //     "distance measurements",
	  //     function(){scope.measuringTool.startInsertion({showDistances: true, showArea: false, closed: false})}
	  //   ));

	  //   elToolbar.appendChild(createToolIcon(
	  //     "../resources/icons/area.png",
	  //     "area measurements",
	  //     function(){scope.measuringTool.startInsertion({showDistances: true, showArea: true, closed: true})}
	  //   ));

	  //   elToolbar.appendChild(createToolIcon(
	  //     "../resources/icons/volume.png",
	  //     "volume measurements",
	  //     function(){scope.volumeTool.startInsertion()}
	  //   ));

	  //   elToolbar.appendChild(createToolIcon(
	  //     "../resources/icons/profile.png",
	  //     "height profiles",
	  //     function(){scope.profileTool.startInsertion({width: viewer.pointcloud.boundingSphere.radius / 100})}
	  //   ));

	  //   elToolbar.appendChild(createToolIcon(
	  //     "../resources/icons/clip_volume.png",
	  //     "clipping volumes",
	  //     function(){scope.volumeTool.startInsertion({clip: true})}
	  //   ));

	  // }

	  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
	    defaultSettings.navigation = "Orbit";
	  }

	  if (defaultSettings.useEDL && !_potree2.default.Features.SHADER_EDL.isSupported()) {
	    defaultSettings.useEDL = false;
	  }

	  if (typeof args.onPointCloudLoaded !== "undefined") {
	    this.addEventListener("pointcloud_loaded", args.onPointCloudLoaded);
	  }

	  this.annotations = [];
	  this.fov = defaultSettings.fov || 60;
	  this.pointSize = defaultSettings.pointSize || 1;
	  this.pointCountTarget = defaultSettings.pointLimit || 1;
	  this.opacity = 1;
	  this.pointSizeType = null;
	  this.pointColorType = null;
	  this.clipMode = _potree2.default.ClipMode.HIGHLIGHT_INSIDE;
	  this.quality = defaultSettings.quality || "Squares";
	  this.isFlipYZ = false;
	  this.useDEMCollisions = false;
	  this.minNodeSize = 100;
	  this.directionalLight;
	  this.edlScale = defaultSettings.edlScale || 1;
	  this.edlRadius = defaultSettings.edlRadius || 3;
	  this.useEDL = defaultSettings.useEDL || false;

	  this.showDebugInfos = false;
	  this.showStats = false;
	  this.showBoundingBox = false;
	  this.freeze = false;

	  this.fpControls;
	  this.orbitControls;
	  this.earthControls;
	  this.transformControls;
	  this.controls;

	  var progressBar = new _ProgressBar2.default();

	  var pointcloudPath = defaultSettings.path;

	  var gui;

	  this.renderer;
	  this.camera;
	  this.scene;
	  this.scenePointCloud;
	  this.sceneBG;
	  this.cameraBG;
	  this.pointcloud = null;
	  this.measuringTool;
	  this.volumeTool;
	  this.transformationTool;

	  var skybox;
	  var stats;
	  var clock = new _three2.default.Clock();
	  var showSkybox = false;
	  var referenceFrame;

	  this.setPointSizeType = function (value) {
	    if (value === "Fixed") {
	      scope.pointSizeType = _potree2.default.PointSizeType.FIXED;
	    } else if (value === "Attenuated") {
	      scope.pointSizeType = _potree2.default.PointSizeType.ATTENUATED;
	    } else if (value === "Adaptive") {
	      scope.pointSizeType = _potree2.default.PointSizeType.ADAPTIVE;
	    }
	  };

	  this.setQuality = function (value) {
	    if (value == "Interpolation" && !_potree2.default.Features.SHADER_INTERPOLATION.isSupported()) {
	      scope.quality = "Squares";
	    } else if (value == "Splats" && !_potree2.default.Features.SHADER_SPLATS.isSupported()) {
	      scope.quality = "Squares";
	    } else {
	      scope.quality = value;
	    }
	  };

	  this.setMaterial = function (value) {
	    if (value === "RGB") {
	      scope.pointColorType = _potree2.default.PointColorType.RGB;
	    } else if (value === "Color") {
	      scope.pointColorType = _potree2.default.PointColorType.COLOR;
	    } else if (value === "Elevation") {
	      scope.pointColorType = _potree2.default.PointColorType.HEIGHT;
	    } else if (value === "Intensity") {
	      scope.pointColorType = _potree2.default.PointColorType.INTENSITY;
	    } else if (value === "Intensity Gradient") {
	      scope.pointColorType = _potree2.default.PointColorType.INTENSITY_GRADIENT;
	    } else if (value === "Classification") {
	      scope.pointColorType = _potree2.default.PointColorType.CLASSIFICATION;
	    } else if (value === "Return Number") {
	      scope.pointColorType = _potree2.default.PointColorType.RETURN_NUMBER;
	    } else if (value === "Source") {
	      scope.pointColorType = _potree2.default.PointColorType.SOURCE;
	    } else if (value === "Tree Depth") {
	      scope.pointColorType = _potree2.default.PointColorType.TREE_DEPTH;
	    } else if (value === "Point Index") {
	      scope.pointColorType = _potree2.default.PointColorType.POINT_INDEX;
	    } else if (value === "Normal") {
	      scope.pointColorType = _potree2.default.PointColorType.NORMAL;
	    } else if (value === "Phong") {
	      scope.pointColorType = _potree2.default.PointColorType.PHONG;
	    }
	  };

	  this.zoomTo = function (node, factor) {
	    scope.camera.zoomTo(node, factor);

	    var bs;
	    if (node.boundingSphere) {
	      bs = node.boundingSphere;
	    } else if (node.geometry && node.geometry.boundingSphere) {
	      bs = node.geometry.boundingSphere;
	    } else {
	      bs = node.boundingBox.getBoundingSphere();
	    }

	    bs = bs.clone().applyMatrix4(node.matrixWorld);

	    scope.orbitControls.target.copy(bs.center);
	    scope.transformControls.target.copy(bs.center);
	  };

	  this.initGUI = function () {

	    scope.setPointSizeType(defaultSettings.sizeType);
	    scope.setQuality(defaultSettings.quality);
	    scope.setMaterial(defaultSettings.material);

	    // dat.gui
	    var gui = new _datGui2.default.GUI({
	      autoPlace: false
	      //height : 5 * 32 - 1
	    });
	    gui.domElement.style.position = "absolute";
	    gui.domElement.style.top = "5px";
	    gui.domElement.style.right = "5px";
	    this.renderArea.appendChild(gui.domElement);

	    var params = {
	      "max. points(m)": scope.pointCountTarget,
	      PointSize: scope.pointSize,
	      "FOV": scope.fov,
	      "opacity": scope.opacity,
	      "SizeType": defaultSettings.sizeType,
	      "show octree": false,
	      "Materials": defaultSettings.material,
	      "Clip Mode": "Highlight Inside",
	      "quality": defaultSettings.quality,
	      "EDL": defaultSettings.useEDL,
	      "EDLScale": scope.edlScale,
	      "skybox": false,
	      "stats": scope.showStats,
	      "debugInfos": scope.showDebugInfos,
	      "BoundingBox": scope.showBoundingBox,
	      "DEM Collisions": scope.useDEMCollisions,
	      "MinNodeSize": scope.minNodeSize,
	      "freeze": scope.freeze
	    };

	    var pPoints = gui.add(params, 'max. points(m)', 0, 4);
	    pPoints.onChange(function (value) {
	      scope.pointCountTarget = value;
	    });

	    var fAppearance = gui.addFolder('Appearance');

	    var pPointSize = fAppearance.add(params, 'PointSize', 0, 3);
	    pPointSize.onChange(function (value) {
	      scope.pointSize = value;
	    });

	    var fFOV = fAppearance.add(params, 'FOV', 20, 100);
	    fFOV.onChange(function (value) {
	      scope.fov = value;
	    });

	    var pOpacity = fAppearance.add(params, 'opacity', 0, 1);
	    pOpacity.onChange(function (value) {
	      scope.opacity = value;
	    });

	    var pSizeType = fAppearance.add(params, 'SizeType', ["Fixed", "Attenuated", "Adaptive"]);
	    pSizeType.onChange(function (value) {
	      scope.setPointSizeType(value);
	    });

	    var options = [];
	    var attributes = scope.pointcloud.pcoGeometry.pointAttributes;
	    if (attributes === "LAS" || attributes === "LAZ") {
	      options = ["RGB", "Color", "Elevation", "Intensity", "Intensity Gradient", "Classification", "Return Number", "Source", "Tree Depth"];
	    } else {
	      for (var i = 0; i < attributes.attributes.length; i++) {
	        var attribute = attributes.attributes[i];

	        if (attribute === _potree2.default.PointAttribute.COLOR_PACKED) {
	          options.push("RGB");
	        } else if (attribute === _potree2.default.PointAttribute.INTENSITY) {
	          options.push("Intensity");
	          options.push("Intensity Gradient");
	        } else if (attribute === _potree2.default.PointAttribute.CLASSIFICATION) {
	          options.push("Classification");
	        }
	      }
	      if (attributes.hasNormals()) {
	        options.push("Phong");
	        options.push("Normal");
	      }

	      options.push("Elevation");
	      options.push("Color");
	      options.push("Tree Depth");
	    }

	    // default material is not available. set material to Elevation
	    if (options.indexOf(params.Materials) < 0) {
	      console.error("Default Material '" + params.Material + "' is not available. Using Elevation instead");
	      scope.setMaterial("Elevation");
	      params.Materials = "Elevation";
	    }

	    var pMaterial = fAppearance.add(params, 'Materials', options);
	    pMaterial.onChange(function (value) {
	      scope.setMaterial(value);
	    });

	    var qualityOptions = ["Squares", "Circles"];
	    if (_potree2.default.Features.SHADER_INTERPOLATION.isSupported()) {
	      qualityOptions.push("Interpolation");
	    }
	    if (_potree2.default.Features.SHADER_SPLATS.isSupported()) {
	      qualityOptions.push("Splats");
	    }
	    var pQuality = fAppearance.add(params, 'quality', qualityOptions);
	    pQuality.onChange(function (value) {
	      scope.quality = value;
	    });

	    {
	      // Eye-Dome-Lighting
	      if (_potree2.default.Features.SHADER_EDL.isSupported()) {

	        var edlParams = {
	          "enable": scope.useEDL,
	          "strength": scope.edlScale,
	          "radius": scope.edlRadius
	        };

	        var fEDL = fAppearance.addFolder('Eye-Dome-Lighting');
	        var pEDL = fEDL.add(edlParams, 'enable');
	        pEDL.onChange(function (value) {
	          scope.useEDL = value;
	        });

	        var pEDLScale = fEDL.add(edlParams, 'strength', 0, 3, 0.01);
	        pEDLScale.onChange(function (value) {
	          scope.edlScale = value;
	        });

	        var pRadius = fEDL.add(edlParams, 'radius', 1, 5);
	        pRadius.onChange(function (value) {
	          scope.edlRadius = value;
	        });
	      }
	    }

	    {
	      // Classification
	      var classificationParams = {
	        "never classified": true,
	        "unclassified": true,
	        "ground": true,
	        "low vegetation": true,
	        "medium vegetation": true,
	        "high vegetation": true,
	        "building": true,
	        "low point(noise)": true,
	        "key-point": true,
	        "water": true,
	        "overlap": true
	      };

	      var setClassificationVisibility = function setClassificationVisibility(key, value) {
	        if (!scope.pointcloud) {
	          return;
	        }
	        var newClass = scope.pointcloud.material.classification;
	        newClass[key].w = value ? 1 : 0;

	        scope.pointcloud.material.classification = newClass;
	      };

	      var fClassification = fAppearance.addFolder('Classification');

	      var pNeverClassified = fClassification.add(classificationParams, 'never classified');
	      pNeverClassified.onChange(function (value) {
	        setClassificationVisibility(0, value);
	      });

	      var pUnclassified = fClassification.add(classificationParams, 'unclassified');
	      pUnclassified.onChange(function (value) {
	        setClassificationVisibility(1, value);
	      });

	      var pGround = fClassification.add(classificationParams, 'ground');
	      pGround.onChange(function (value) {
	        setClassificationVisibility(2, value);
	      });

	      var pLowVeg = fClassification.add(classificationParams, 'low vegetation');
	      pLowVeg.onChange(function (value) {
	        setClassificationVisibility(3, value);
	      });

	      var pMedVeg = fClassification.add(classificationParams, 'medium vegetation');
	      pMedVeg.onChange(function (value) {
	        setClassificationVisibility(4, value);
	      });

	      var pHighVeg = fClassification.add(classificationParams, 'high vegetation');
	      pHighVeg.onChange(function (value) {
	        setClassificationVisibility(5, value);
	      });

	      var pBuilding = fClassification.add(classificationParams, 'building');
	      pBuilding.onChange(function (value) {
	        setClassificationVisibility(6, value);
	      });

	      var pNoise = fClassification.add(classificationParams, 'low point(noise)');
	      pNoise.onChange(function (value) {
	        setClassificationVisibility(7, value);
	      });

	      var pKeyPoint = fClassification.add(classificationParams, 'key-point');
	      pKeyPoint.onChange(function (value) {
	        setClassificationVisibility(8, value);
	      });

	      var pWater = fClassification.add(classificationParams, 'water');
	      pWater.onChange(function (value) {
	        setClassificationVisibility(9, value);
	      });

	      var pOverlap = fClassification.add(classificationParams, 'overlap');
	      pOverlap.onChange(function (value) {
	        setClassificationVisibility(12, value);
	      });
	    }

	    var pSykbox = fAppearance.add(params, 'skybox');
	    pSykbox.onChange(function (value) {
	      showSkybox = value;
	    });

	    var fSettings = gui.addFolder('Settings');

	    var pClipMode = fSettings.add(params, 'Clip Mode', ["No Clipping", "Clip Outside", "Highlight Inside"]);
	    pClipMode.onChange(function (value) {
	      if (value === "No Clipping") {
	        scope.clipMode = _potree2.default.ClipMode.DISABLED;
	      } else if (value === "Clip Outside") {
	        scope.clipMode = _potree2.default.ClipMode.CLIP_OUTSIDE;
	      } else if (value === "Highlight Inside") {
	        scope.clipMode = _potree2.default.ClipMode.HIGHLIGHT_INSIDE;
	      }
	    });

	    var pDEMCollisions = fSettings.add(params, 'DEM Collisions');
	    pDEMCollisions.onChange(function (value) {
	      scope.useDEMCollisions = value;
	    });

	    var pMinNodeSize = fSettings.add(params, 'MinNodeSize', 0, 1500);
	    pMinNodeSize.onChange(function (value) {
	      scope.minNodeSize = value;
	    });

	    var fDebug = gui.addFolder('Debug');

	    var pStats = fDebug.add(params, 'stats');
	    pStats.onChange(function (value) {
	      scope.showStats = value;
	    });

	    var pShowDebugInfos = fDebug.add(params, "debugInfos");
	    pShowDebugInfos.onChange(function (value) {
	      scope.showDebugInfos = value;
	      scope.infos.domElement.style.display = scope.showDebugInfos ? "block" : "none";
	    });

	    var pBoundingBox = fDebug.add(params, 'BoundingBox');
	    pBoundingBox.onChange(function (value) {
	      scope.showBoundingBox = value;
	    });

	    var pFreeze = fDebug.add(params, 'freeze');
	    pFreeze.onChange(function (value) {
	      scope.freeze = value;
	    });

	    // stats
	    stats = new _stats2.default();
	    stats.domElement.style.position = 'absolute';
	    stats.domElement.style.top = '0px';
	    stats.domElement.style.margin = '5px';
	    document.body.appendChild(stats.domElement);
	  };

	  this.createControls = function () {
	    {
	      // create FIRST PERSON CONTROLS
	      scope.fpControls = new _FirstPersonControls2.default(scope.camera, scope.renderer.domElement);
	      scope.fpControls.addEventListener("proposeTransform", function (event) {
	        if (!scope.pointcloud || !scope.useDEMCollisions) {
	          return;
	        }

	        var demHeight = scope.pointcloud.getDEMHeight(event.newPosition);
	        if (event.newPosition.y < demHeight) {
	          event.objections++;

	          var counterProposal = event.newPosition.clone();
	          counterProposal.y = demHeight;

	          event.counterProposals.push(counterProposal);
	        }
	      });
	    }

	    {
	      // create ORBIT CONTROLS
	      scope.orbitControls = new _potree2.default.OrbitControls(scope.camera, scope.renderer.domElement);
	      scope.orbitControls.addEventListener("proposeTransform", function (event) {
	        if (!scope.pointcloud || !scope.useDEMCollisions) {
	          return;
	        }

	        var demHeight = scope.pointcloud.getDEMHeight(event.newPosition);
	        if (event.newPosition.y < demHeight) {
	          event.objections++;

	          var counterProposal = event.newPosition.clone();
	          counterProposal.y = demHeight;

	          event.counterProposals.push(counterProposal);
	        }
	      });
	      scope.renderArea.addEventListener("dblclick", function (event) {
	        if (!scope.pointcloud) {
	          return;
	        }

	        event.preventDefault();

	        var rect = scope.renderArea.getBoundingClientRect();

	        var mouse = {
	          x: (event.clientX - rect.left) / scope.renderArea.clientWidth * 2 - 1,
	          y: -((event.clientY - rect.top) / scope.renderArea.clientHeight) * 2 + 1
	        };

	        var I = getMousePointCloudIntersection(mouse, scope.camera, scope.renderer, [scope.pointcloud]);
	        if (I != null) {
	          var camTargetDistance = scope.camera.position.distanceTo(scope.transformControls.target);

	          var vector = new _three2.default.Vector3(mouse.x, mouse.y, 0.5);
	          vector.unproject(scope.camera);

	          var direction = vector.sub(scope.camera.position).normalize();
	          var ray = new _three2.default.Ray(scope.camera.position, direction);

	          var nodes = scope.pointcloud.nodesOnRay(scope.pointcloud.visibleNodes, ray);
	          var lastNode = nodes[nodes.length - 1];
	          var radius = lastNode.boundingSphere.radius;
	          var targetRadius = Math.min(camTargetDistance, radius);

	          var d = scope.camera.getWorldDirection().multiplyScalar(-1);
	          var cameraTargetPosition = new _three2.default.Vector3().addVectors(I, d.multiplyScalar(targetRadius));
	          var controlsTargetPosition = I;

	          var animationDuration = 600;

	          var easing = _tween2.default.Easing.Quartic.Out;

	          scope.controls.enabled = false;

	          // animate position
	          var tween = new _tween2.default.Tween(scope.camera.position).to(cameraTargetPosition, animationDuration);
	          tween.easing(easing);
	          tween.start();

	          // animate target
	          var tween = new _tween2.default.Tween(scope.transformControls.target).to(I, animationDuration);
	          tween.easing(easing);
	          tween.onComplete(function () {
	            scope.controls.enabled = true;
	            scope.fpControls.moveSpeed = radius / 2;
	          });
	          tween.start();
	        }
	      });
	    }

	    {
	      // create EARTH CONTROLS
	      scope.earthControls = new _EarthControls2.default(scope.camera, scope.renderer, scope.scenePointCloud);
	      scope.earthControls.addEventListener("proposeTransform", function (event) {
	        if (!scope.pointcloud || !scope.useDEMCollisions) {
	          return;
	        }

	        var demHeight = scope.pointcloud.getDEMHeight(event.newPosition);
	        if (event.newPosition.y < demHeight) {
	          event.objections++;
	        }
	      });
	    }

	    {
	      // create TRANSFORM CONTROLS
	      scope.transformControls = new _TransformControls2.default(scope.camera, scope.renderer.domElement);
	      scope.transformControls.addEventListener("proposeTransform", function (event) {
	        if (!scope.pointcloud || !scope.useDEMCollisions) {
	          return;
	        }

	        var demHeight = scope.pointcloud.getDEMHeight(event.newPosition);
	        if (event.newPosition.y < demHeight) {
	          event.objections++;

	          var counterProposal = event.newPosition.clone();
	          counterProposal.y = demHeight;

	          event.counterProposals.push(counterProposal);
	        }
	      });

	      scope.transformControls.zoomSpeed = 5.0;
	      scope.transformControls.rotateSpeed = 5.0;
	      scope.transformControls.panSpeed = 0.8;

	      scope.transformControls.staticMoving = true;
	      scope.transformControls.dynamicDampingFactor = 0.3;
	      scope.transformControls.addEventListener('change', scope.render);
	    }
	  };

	  this.initThree = function () {
	    var width = scope.renderArea.clientWidth;
	    var height = scope.renderArea.clientHeight;
	    var aspect = width / height;
	    var near = 0.1;
	    var far = 1000 * 1000;

	    scope.scene = new _three2.default.Scene();
	    scope.scenePointCloud = new _three2.default.Scene();
	    scope.sceneBG = new _three2.default.Scene();

	    scope.camera = new _three2.default.PerspectiveCamera(scope.fov, aspect, near, far);
	    //camera = new THREE.OrthographicCamera(-50, 50, 50, -50, 1, 100000);
	    scope.cameraBG = new _three2.default.Camera();
	    scope.camera.rotation.order = 'ZYX';

	    referenceFrame = new _three2.default.Object3D();
	    scope.scenePointCloud.add(referenceFrame);

	    scope.renderer = new _three2.default.WebGLRenderer();
	    scope.renderer.setSize(width, height);
	    scope.renderer.autoClear = false;
	    scope.renderArea.appendChild(scope.renderer.domElement);

	    // skybox = Potree.utils.loadSkybox("../resources/textures/skybox/");

	    // camera and controls
	    scope.camera.position.set(-304, 372, 318);
	    scope.camera.rotation.y = -Math.PI / 4;
	    scope.camera.rotation.x = -Math.PI / 6;

	    this.createControls();

	    scope.useTransformControls();
	    // scope.useOrbitControls();

	    // enable frag_depth extension for the interpolation shader, if available
	    scope.renderer.context.getExtension("EXT_frag_depth");

	    // load pointcloud
	    if (!pointcloudPath) {} else if (pointcloudPath.indexOf("cloud.js") > 0) {
	      _potree2.default.POCLoader.load(pointcloudPath, function (geometry) {
	        scope.pointcloud = new _potree2.default.PointCloudOctree(geometry);

	        scope.pointcloud.material.pointSizeType = _potree2.default.PointSizeType.ADAPTIVE;
	        scope.pointcloud.material.size = scope.pointSize;
	        scope.pointcloud.visiblePointsTarget = scope.pointCountTarget * 1000 * 1000;

	        referenceFrame.add(scope.pointcloud);

	        referenceFrame.updateMatrixWorld(true);
	        var sg = scope.pointcloud.boundingSphere.clone().applyMatrix4(scope.pointcloud.matrixWorld);

	        referenceFrame.position.copy(sg.center).multiplyScalar(-1);
	        referenceFrame.updateMatrixWorld(true);

	        if (sg.radius > 50 * 1000) {
	          scope.camera.near = 10;
	        } else if (sg.radius > 10 * 1000) {
	          scope.camera.near = 2;
	        } else if (sg.radius > 1000) {
	          scope.camera.near = 1;
	        } else if (sg.radius > 100) {
	          scope.camera.near = 0.5;
	        } else {
	          scope.camera.near = 0.1;
	        }

	        scope.flipYZ();
	        scope.zoomTo(scope.pointcloud, 1);

	        scope.initGUI();

	        scope.earthControls.pointclouds.push(scope.pointcloud);

	        if (defaultSettings.navigation === "Earth") {
	          scope.useEarthControls();
	        } else if (defaultSettings.navigation === "Orbit") {
	          scope.useOrbitControls();
	        } else if (defaultSettings.navigation === "Flight") {
	          scope.useFPSControls();
	        } else {
	          // console.warning("No navigation mode specified. Using OrbitControls");
	          scope.useTransformControls();
	        }

	        if (defaultSettings.cameraPosition != null) {
	          var cp = new _three2.default.Vector3(defaultSettings.cameraPosition[0], defaultSettings.cameraPosition[1], defaultSettings.cameraPosition[2]);
	          scope.camera.position.copy(cp);
	        }

	        if (defaultSettings.cameraTarget != null) {
	          var ct = new _three2.default.Vector3(defaultSettings.cameraTarget[0], defaultSettings.cameraTarget[1], defaultSettings.cameraTarget[2]);
	          scope.camera.lookAt(ct);

	          if (defaultSettings.navigation === "Orbit" || defaultSettings.navigation === 'Transform') {
	            scope.controls.target.copy(ct);
	          }
	        }

	        scope.dispatchEvent({
	          "type": "pointcloud_loaded",
	          "pointcloud": scope.pointcloud
	        });
	      });
	    } else if (pointcloudPath.indexOf(".vpc") > 0) {
	      _potree2.default.PointCloudArena4DGeometry.load(pointcloudPath, function (geometry) {
	        scope.pointcloud = new _potree2.default.PointCloudArena4D(geometry);
	        scope.pointcloud.visiblePointsTarget = 500 * 1000;

	        //scope.pointcloud.applyMatrix(new THREE.Matrix4().set(
	        //  1,0,0,0,
	        //  0,0,1,0,
	        //  0,-1,0,0,
	        //  0,0,0,1
	        //));

	        referenceFrame.add(scope.pointcloud);

	        flipYZ();

	        referenceFrame.updateMatrixWorld(true);
	        var sg = scope.pointcloud.boundingSphere.clone().applyMatrix4(scope.pointcloud.matrixWorld);

	        referenceFrame.position.sub(sg.center);
	        referenceFrame.position.y += sg.radius / 2;
	        referenceFrame.updateMatrixWorld(true);

	        scope.zoomTo(scope.pointcloud, 1);

	        initGUI();
	        scope.pointcloud.material.interpolation = false;
	        scope.pointcloud.material.pointSizeType = _potree2.default.PointSizeType.ATTENUATED;
	        scope.earthControls.pointclouds.push(scope.pointcloud);

	        if (defaultSettings.navigation === "Earth") {
	          scope.useEarthControls();
	        } else if (defaultSettings.navigation === "Orbit") {
	          scope.useOrbitControls();
	        } else if (defaultSettings.navigation === "Flight") {
	          scope.useFPSControls();
	        } else {
	          console.warning("No navigation mode specivied. Using OrbitControls");
	          scope.useTransformControls();
	        }

	        if (defaultSettings.cameraPosition != null) {
	          var cp = new _three2.default.Vector3(defaultSettings.cameraPosition[0], defaultSettings.cameraPosition[1], defaultSettings.cameraPosition[2]);
	          scope.camera.position.copy(cp);
	        }

	        if (defaultSettings.cameraTarget != null) {
	          var ct = new _three2.default.Vector3(defaultSettings.cameraTarget[0], defaultSettings.cameraTarget[1], defaultSettings.cameraTarget[2]);
	          scope.camera.lookAt(ct);
	        }
	      });
	    }

	    // var grid = Potree.utils.createGrid(5, 5, 2);
	    // scope.scene.add(grid);

	    scope.measuringTool = new _potree2.default.MeasuringTool(scope.scenePointCloud, scope.camera, scope.renderer);
	    scope.profileTool = new _potree2.default.ProfileTool(scope.scenePointCloud, scope.camera, scope.renderer);
	    scope.transformationTool = new _potree2.default.TransformationTool(scope.scenePointCloud, scope.camera, scope.renderer);
	    scope.volumeTool = new _potree2.default.VolumeTool(scope.scenePointCloud, scope.camera, scope.renderer, scope.transformationTool);

	    // background
	    // var texture = THREE.ImageUtils.loadTexture( '../resources/textures/background.gif' );
	    var texture = _potree2.default.utils.createBackgroundTexture(512, 512);

	    texture.minFilter = texture.magFilter = _three2.default.NearestFilter;
	    texture.minFilter = texture.magFilter = _three2.default.LinearFilter;

	    var bg = new _three2.default.Mesh(new _three2.default.PlaneBufferGeometry(2, 2, 0), new _three2.default.MeshBasicMaterial({
	      map: texture
	    }));
	    //bg.position.z = -1;
	    bg.material.depthTest = false;
	    bg.material.depthWrite = false;
	    scope.sceneBG.add(bg);

	    window.addEventListener('keydown', onKeyDown, false);

	    scope.directionalLight = new _three2.default.DirectionalLight(0xffffff, 0.5);
	    scope.directionalLight.position.set(10, 10, 10);
	    scope.directionalLight.lookAt(new _three2.default.Vector3(0, 0, 0));
	    scope.scenePointCloud.add(scope.directionalLight);

	    var light = new _three2.default.AmbientLight(0x555555); // soft white light
	    scope.scenePointCloud.add(light);
	  };

	  this.flipYZ = function () {
	    scope.isFlipYZ = !scope.isFlipYZ;

	    if (scope.isFlipYZ) {
	      referenceFrame.matrix.copy(new _three2.default.Matrix4());
	      referenceFrame.applyMatrix(new _three2.default.Matrix4().set(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1));
	    } else {
	      referenceFrame.matrix.copy(new _three2.default.Matrix4());
	      referenceFrame.applyMatrix(new _three2.default.Matrix4().set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
	    }

	    referenceFrame.updateMatrixWorld(true);
	    scope.pointcloud.updateMatrixWorld();
	    var sg = scope.pointcloud.boundingSphere.clone().applyMatrix4(scope.pointcloud.matrixWorld);
	    referenceFrame.position.copy(sg.center).multiplyScalar(-1);
	    referenceFrame.updateMatrixWorld(true);
	    referenceFrame.position.y -= scope.pointcloud.getWorldPosition().y;
	    referenceFrame.updateMatrixWorld(true);
	  };

	  function onKeyDown(event) {
	    //console.log(event.keyCode);

	    if (event.keyCode === 69) {
	      // e pressed

	      scope.transformationTool.translate();
	    } else if (event.keyCode === 82) {
	      // r pressed

	      scope.transformationTool.scale();
	    } else if (event.keyCode === 84) {
	      // r pressed

	      scope.transformationTool.rotate();
	    }
	  };

	  var intensityMax = null;
	  var heightMin = null;
	  var heightMax = null;

	  this.update = function (delta, timestamp) {
	    _potree2.default.pointLoadLimit = scope.pointCountTarget * 2 * 1000 * 1000;

	    scope.directionalLight.position.copy(scope.camera.position);
	    scope.directionalLight.lookAt(new _three2.default.Vector3().addVectors(scope.camera.position, scope.camera.getWorldDirection()));

	    if (scope.pointcloud) {

	      var bbWorld = _potree2.default.utils.computeTransformedBoundingBox(scope.pointcloud.boundingBox, scope.pointcloud.matrixWorld);

	      if (!intensityMax) {
	        var root = scope.pointcloud.pcoGeometry.root;
	        if (root != null && root.loaded) {
	          var attributes = scope.pointcloud.pcoGeometry.root.geometry.attributes;
	          if (attributes.intensity) {
	            var array = attributes.intensity.array;
	            var max = 0;
	            for (var i = 0; i < array.length; i++) {
	              max = Math.max(array[i]);
	            }

	            if (max <= 1) {
	              intensityMax = 1;
	            } else if (max <= 256) {
	              intensityMax = 255;
	            } else {
	              intensityMax = max;
	            }
	          }
	        }
	      }

	      if (heightMin === null) {
	        heightMin = bbWorld.min.y;
	        heightMax = bbWorld.max.y;
	      }

	      scope.pointcloud.material.clipMode = scope.clipMode;
	      scope.pointcloud.material.heightMin = heightMin;
	      scope.pointcloud.material.heightMax = heightMax;
	      scope.pointcloud.material.intensityMin = 0;
	      scope.pointcloud.material.intensityMax = intensityMax;
	      scope.pointcloud.showBoundingBox = scope.showBoundingBox;
	      scope.pointcloud.generateDEM = scope.useDEMCollisions;
	      scope.pointcloud.minimumNodePixelSize = scope.minNodeSize;

	      if (!scope.freeze) {
	        scope.pointcloud.update(scope.camera, scope.renderer);
	      }
	    }

	    if (stats && scope.showStats) {
	      document.getElementById("lblNumVisibleNodes").style.display = "";
	      document.getElementById("lblNumVisiblePoints").style.display = "";
	      stats.domElement.style.display = "";

	      stats.update();

	      if (scope.pointcloud) {
	        document.getElementById("lblNumVisibleNodes").innerHTML = "visible nodes: " + scope.pointcloud.numVisibleNodes;
	        document.getElementById("lblNumVisiblePoints").innerHTML = "visible points: " + _potree2.default.utils.addCommas(scope.pointcloud.numVisiblePoints);
	      }
	    } else if (stats) {
	      document.getElementById("lblNumVisibleNodes").style.display = "none";
	      document.getElementById("lblNumVisiblePoints").style.display = "none";
	      stats.domElement.style.display = "none";
	    }

	    scope.camera.fov = scope.fov;

	    if (scope.controls) {
	      scope.controls.update(delta);
	    }

	    // update progress bar
	    if (scope.pointcloud) {
	      var progress = scope.pointcloud.progress;

	      progressBar.progress = progress;

	      var message;
	      if (progress === 0 || scope.pointcloud instanceof _potree2.default.PointCloudArena4D) {
	        message = "loading";
	      } else {
	        message = "loading: " + parseInt(progress * 100) + "%";
	      }
	      progressBar.message = message;

	      if (progress === 1) {
	        progressBar.hide();
	      } else if (progress < 1) {
	        progressBar.show();
	      }
	    }

	    scope.volumeTool.update();
	    scope.transformationTool.update();
	    scope.profileTool.update();

	    var clipBoxes = [];

	    for (var i = 0; i < scope.profileTool.profiles.length; i++) {
	      var profile = scope.profileTool.profiles[i];

	      for (var j = 0; j < profile.boxes.length; j++) {
	        var box = profile.boxes[j];
	        box.updateMatrixWorld();
	        var boxInverse = new _three2.default.Matrix4().getInverse(box.matrixWorld);
	        clipBoxes.push(boxInverse);
	      }
	    }

	    for (var i = 0; i < scope.volumeTool.volumes.length; i++) {
	      var volume = scope.volumeTool.volumes[i];

	      if (volume.clip) {
	        volume.updateMatrixWorld();
	        var boxInverse = new _three2.default.Matrix4().getInverse(volume.matrixWorld);

	        clipBoxes.push(boxInverse);
	      }
	    }

	    if (scope.pointcloud) {
	      scope.pointcloud.material.setClipBoxes(clipBoxes);
	    }

	    {
	      // update annotations
	      var distances = [];
	      for (var i = 0; i < scope.annotations.length; i++) {
	        var ann = scope.annotations[i];
	        var screenPos = ann.position.clone().project(scope.camera);

	        screenPos.x = scope.renderArea.clientWidth * (screenPos.x + 1) / 2;
	        screenPos.y = scope.renderArea.clientHeight * (1 - (screenPos.y + 1) / 2);

	        ann.domElement.style.left = screenPos.x - ann.domElement.clientWidth / 2;
	        ann.domElement.style.top = screenPos.y;

	        distances.push({ annotation: ann, distance: screenPos.z });

	        if (-1 > screenPos.z || screenPos.z > 1) {
	          ann.domElement.style.display = "none";
	        } else {
	          ann.domElement.style.display = "initial";
	        }
	      }
	      distances.sort(function (a, b) {
	        return b.distance - a.distance;
	      });
	      for (var i = 0; i < distances.length; i++) {
	        var ann = distances[i].annotation;
	        ann.domElement.style.zIndex = "" + i;
	      }
	    }

	    if (scope.showDebugInfos) {
	      scope.infos.set("camera.position", "camera.position: " + viewer.camera.position.x.toFixed(2) + ", " + viewer.camera.position.y.toFixed(2) + ", " + viewer.camera.position.z.toFixed(2));
	    }

	    _tween2.default.update(timestamp);
	  };

	  this.useEarthControls = function () {
	    if (scope.controls) {
	      scope.controls.enabled = false;
	    }

	    scope.controls = scope.earthControls;
	    scope.controls.enabled = true;
	  };

	  this.useFPSControls = function () {
	    if (scope.controls) {
	      scope.controls.enabled = false;
	    }

	    scope.controls = scope.fpControls;
	    scope.controls.enabled = true;

	    scope.controls.moveSpeed = scope.pointcloud.boundingSphere.radius / 6;
	  };

	  this.useOrbitControls = function () {
	    if (scope.controls) {
	      scope.controls.enabled = false;
	    }

	    scope.controls = scope.orbitControls;
	    scope.controls.enabled = true;

	    if (scope.pointcloud) {
	      scope.controls.target.copy(scope.pointcloud.boundingSphere.center.clone().applyMatrix4(scope.pointcloud.matrixWorld));
	    }
	  };

	  this.useTransformControls = function () {
	    if (scope.controls) {
	      scope.controls.enabled = false;
	    }

	    scope.earthControls.enabled = false;
	    scope.fpControls.enabled = false;
	    scope.orbitControls.enabled = false;

	    scope.controls = scope.transformControls;
	    scope.controls.enabled = true;
	    scope.controls.addEventListener('change', scope.render);
	    scope.scene.add(scope.controls);

	    if (scope.pointcloud) {
	      scope.controls.target.copy(scope.pointcloud.boundingSphere.center.clone().applyMatrix4(scope.pointcloud.matrixWorld));
	    }
	  };

	  this.addAnnotation = function (position, args) {
	    var cameraPosition = args.cameraPosition;
	    var cameraTarget = args.cameraTarget || position;

	    var annotation = new _potree2.default.Annotation(scope, {
	      "position": position,
	      "cameraPosition": cameraPosition,
	      "cameraTarget": cameraTarget
	    });

	    scope.annotations.push(annotation);
	    scope.renderArea.appendChild(annotation.domElement);
	  };

	  var PotreeRenderer = function PotreeRenderer() {

	    this.render = function () {
	      {
	        // resize
	        var width = scope.renderArea.clientWidth;
	        var height = scope.renderArea.clientHeight;
	        var aspect = width / height;

	        scope.camera.aspect = aspect;
	        scope.camera.updateProjectionMatrix();

	        scope.renderer.setSize(width, height);
	      }

	      // render skybox
	      if (showSkybox) {
	        scope.camera.rotation.copy(scope.camera.rotation);
	        scope.renderer.render(skybox.scene, skybox.camera);
	      } else {
	        scope.renderer.render(scope.sceneBG, scope.cameraBG);
	      }

	      if (scope.pointcloud) {
	        if (scope.pointcloud.originalMaterial) {
	          scope.pointcloud.material = scope.pointcloud.originalMaterial;
	        }

	        var bbWorld = _potree2.default.utils.computeTransformedBoundingBox(scope.pointcloud.boundingBox, scope.pointcloud.matrixWorld);

	        scope.pointcloud.visiblePointsTarget = scope.pointCountTarget * 1000 * 1000;
	        scope.pointcloud.material.size = scope.pointSize;
	        scope.pointcloud.material.opacity = scope.opacity;
	        scope.pointcloud.material.pointColorType = scope.pointColorType;
	        scope.pointcloud.material.pointSizeType = scope.pointSizeType;
	        scope.pointcloud.material.pointShape = scope.quality === "Circles" ? _potree2.default.PointShape.CIRCLE : _potree2.default.PointShape.SQUARE;
	        scope.pointcloud.material.interpolate = scope.quality === "Interpolation";
	        scope.pointcloud.material.weighted = false;
	      }

	      // render scene
	      scope.renderer.render(scope.scene, scope.camera);
	      scope.renderer.render(scope.scenePointCloud, scope.camera);

	      scope.profileTool.render();
	      scope.volumeTool.render();

	      scope.renderer.clearDepth();
	      scope.measuringTool.render();
	      scope.transformationTool.render();
	    };
	  };
	  var potreeRenderer = new PotreeRenderer();
	  this.render = potreeRenderer.render;

	  // high quality rendering using splats
	  var highQualityRenderer = null;
	  var HighQualityRenderer = function HighQualityRenderer() {

	    var depthMaterial = null;
	    var attributeMaterial = null;
	    var normalizationMaterial = null;

	    var rtDepth;
	    var rtNormalize;

	    var initHQSPlats = function initHQSPlats() {
	      if (depthMaterial != null) {
	        return;
	      }

	      depthMaterial = new _potree2.default.PointCloudMaterial();
	      attributeMaterial = new _potree2.default.PointCloudMaterial();

	      depthMaterial.pointColorType = _potree2.default.PointColorType.DEPTH;
	      depthMaterial.pointShape = _potree2.default.PointShape.CIRCLE;
	      depthMaterial.interpolate = false;
	      depthMaterial.weighted = false;
	      depthMaterial.minSize = 2;

	      attributeMaterial.pointShape = _potree2.default.PointShape.CIRCLE;
	      attributeMaterial.interpolate = false;
	      attributeMaterial.weighted = true;
	      attributeMaterial.minSize = 2;

	      rtDepth = new _three2.default.WebGLRenderTarget(1024, 1024, {
	        minFilter: _three2.default.NearestFilter,
	        magFilter: _three2.default.NearestFilter,
	        format: _three2.default.RGBAFormat,
	        type: _three2.default.FloatType
	      });

	      rtNormalize = new _three2.default.WebGLRenderTarget(1024, 1024, {
	        minFilter: _three2.default.LinearFilter,
	        magFilter: _three2.default.NearestFilter,
	        format: _three2.default.RGBAFormat,
	        type: _three2.default.FloatType
	      });

	      var uniformsNormalize = {
	        depthMap: { type: "t", value: rtDepth },
	        texture: { type: "t", value: rtNormalize }
	      };

	      normalizationMaterial = new _three2.default.ShaderMaterial({
	        uniforms: uniformsNormalize,
	        vertexShader: _potree2.default.Shaders["normalize.vs"],
	        fragmentShader: _potree2.default.Shaders["normalize.fs"]
	      });
	    };

	    var resize = function resize(width, height) {
	      if (rtDepth.width == width && rtDepth.height == height) {
	        return;
	      }

	      rtDepth.dispose();
	      rtNormalize.dispose();

	      scope.camera.aspect = width / height;
	      scope.camera.updateProjectionMatrix();

	      scope.renderer.setSize(width, height);
	      rtDepth.setSize(width, height);
	      rtNormalize.setSize(width, height);
	    };

	    // render with splats
	    this.render = function (renderer) {

	      var width = scope.renderArea.clientWidth;
	      var height = scope.renderArea.clientHeight;

	      initHQSPlats();

	      resize(width, height);

	      scope.renderer.clear();
	      if (showSkybox) {
	        skybox.camera.rotation.copy(scope.camera.rotation);
	        scope.renderer.render(skybox.scene, skybox.camera);
	      } else {
	        scope.renderer.render(scope.sceneBG, scope.cameraBG);
	      }
	      scope.renderer.render(scope.scene, scope.camera);

	      if (scope.pointcloud) {

	        depthMaterial.uniforms.octreeSize.value = scope.pointcloud.pcoGeometry.boundingBox.size().x;
	        attributeMaterial.uniforms.octreeSize.value = scope.pointcloud.pcoGeometry.boundingBox.size().x;

	        scope.pointcloud.visiblePointsTarget = scope.pointCountTarget * 1000 * 1000;
	        var originalMaterial = scope.pointcloud.material;

	        {
	          // DEPTH PASS
	          depthMaterial.size = scope.pointSize;
	          depthMaterial.pointSizeType = scope.pointSizeType;
	          depthMaterial.screenWidth = width;
	          depthMaterial.screenHeight = height;
	          depthMaterial.uniforms.visibleNodes.value = scope.pointcloud.material.visibleNodesTexture;
	          depthMaterial.uniforms.octreeSize.value = scope.pointcloud.pcoGeometry.boundingBox.size().x;
	          depthMaterial.fov = scope.camera.fov * (Math.PI / 180);
	          depthMaterial.spacing = scope.pointcloud.pcoGeometry.spacing;
	          depthMaterial.near = scope.camera.near;
	          depthMaterial.far = scope.camera.far;
	          depthMaterial.heightMin = heightMin;
	          depthMaterial.heightMax = heightMax;
	          depthMaterial.uniforms.visibleNodes.value = scope.pointcloud.material.visibleNodesTexture;
	          depthMaterial.uniforms.octreeSize.value = scope.pointcloud.pcoGeometry.boundingBox.size().x;
	          depthMaterial.bbSize = scope.pointcloud.material.bbSize;
	          depthMaterial.treeType = scope.pointcloud.material.treeType;
	          depthMaterial.uniforms.classificationLUT.value = scope.pointcloud.material.uniforms.classificationLUT.value;

	          scope.scenePointCloud.overrideMaterial = depthMaterial;
	          scope.renderer.clearTarget(rtDepth, true, true, true);
	          scope.renderer.render(scope.scenePointCloud, scope.camera, rtDepth);
	          scope.scenePointCloud.overrideMaterial = null;
	        }

	        {
	          // ATTRIBUTE PASS
	          attributeMaterial.size = scope.pointSize;
	          attributeMaterial.pointSizeType = scope.pointSizeType;
	          attributeMaterial.screenWidth = width;
	          attributeMaterial.screenHeight = height;
	          attributeMaterial.pointColorType = scope.pointColorType;
	          attributeMaterial.depthMap = rtDepth;
	          attributeMaterial.uniforms.visibleNodes.value = scope.pointcloud.material.visibleNodesTexture;
	          attributeMaterial.uniforms.octreeSize.value = scope.pointcloud.pcoGeometry.boundingBox.size().x;
	          attributeMaterial.fov = scope.camera.fov * (Math.PI / 180);
	          attributeMaterial.spacing = scope.pointcloud.pcoGeometry.spacing;
	          attributeMaterial.near = scope.camera.near;
	          attributeMaterial.far = scope.camera.far;
	          attributeMaterial.heightMin = heightMin;
	          attributeMaterial.heightMax = heightMax;
	          attributeMaterial.intensityMin = scope.pointcloud.material.intensityMin;
	          attributeMaterial.intensityMax = scope.pointcloud.material.intensityMax;
	          attributeMaterial.setClipBoxes(scope.pointcloud.material.clipBoxes);
	          attributeMaterial.clipMode = scope.pointcloud.material.clipMode;
	          attributeMaterial.bbSize = scope.pointcloud.material.bbSize;
	          attributeMaterial.treeType = scope.pointcloud.material.treeType;
	          attributeMaterial.uniforms.classificationLUT.value = scope.pointcloud.material.uniforms.classificationLUT.value;

	          scope.scenePointCloud.overrideMaterial = attributeMaterial;
	          scope.renderer.clearTarget(rtNormalize, true, true, true);
	          scope.renderer.render(scope.scenePointCloud, scope.camera, rtNormalize);
	          scope.scenePointCloud.overrideMaterial = null;
	        }

	        {
	          // NORMALIZATION PASS
	          normalizationMaterial.uniforms.depthMap.value = rtDepth;
	          normalizationMaterial.uniforms.texture.value = rtNormalize;
	          _potree2.default.utils.screenPass.render(scope.renderer, normalizationMaterial);
	        }

	        scope.pointcloud.material = originalMaterial;

	        scope.volumeTool.render();
	        scope.renderer.clearDepth();
	        scope.profileTool.render();
	        scope.measuringTool.render();
	        scope.transformationTool.render();
	      }
	    };
	  };

	  var edlRenderer = null;
	  var EDLRenderer = function EDLRenderer() {

	    var edlMaterial = null;
	    var attributeMaterial = null;

	    //var depthTexture = null;

	    var rtColor = null;
	    var gl = scope.renderer.context;

	    var initEDL = function initEDL() {
	      if (edlMaterial != null) {
	        return;
	      }

	      //var depthTextureExt = gl.getExtension("WEBGL_depth_texture");

	      edlMaterial = new _potree2.default.EyeDomeLightingMaterial();
	      attributeMaterial = new _potree2.default.PointCloudMaterial();

	      attributeMaterial.pointShape = _potree2.default.PointShape.CIRCLE;
	      attributeMaterial.interpolate = false;
	      attributeMaterial.weighted = false;
	      attributeMaterial.minSize = 2;
	      attributeMaterial.useLogarithmicDepthBuffer = false;
	      attributeMaterial.useEDL = true;

	      rtColor = new _three2.default.WebGLRenderTarget(1024, 1024, {
	        minFilter: _three2.default.LinearFilter,
	        magFilter: _three2.default.NearestFilter,
	        format: _three2.default.RGBAFormat,
	        type: _three2.default.FloatType
	      });
	    };

	    //type: THREE.UnsignedByteType,
	    //depthBuffer: false,
	    //stencilBuffer: false
	    var resize = function resize() {
	      var width = scope.renderArea.clientWidth;
	      var height = scope.renderArea.clientHeight;
	      var aspect = width / height;

	      var needsResize = rtColor.width != width || rtColor.height != height;

	      // disposal will be unnecessary once this fix made it into three.js master:
	      // https://github.com/mrdoob/three.js/pull/6355
	      if (needsResize) {
	        rtColor.dispose();
	      }

	      scope.camera.aspect = aspect;
	      scope.camera.updateProjectionMatrix();

	      scope.renderer.setSize(width, height);
	      rtColor.setSize(width, height);
	    };

	    this.render = function () {

	      initEDL();

	      resize();

	      scope.renderer.clear();
	      if (showSkybox) {
	        scope.camera.rotation.copy(scope.camera.rotation);
	        scope.renderer.render(skybox.scene, skybox.camera);
	      } else {
	        scope.renderer.render(scope.sceneBG, scope.cameraBG);
	      }
	      scope.renderer.render(scope.scene, scope.camera);

	      if (scope.pointcloud) {
	        var width = scope.renderArea.clientWidth;
	        var height = scope.renderArea.clientHeight;

	        var octreeSize = scope.pointcloud.pcoGeometry.boundingBox.size().x;

	        scope.pointcloud.visiblePointsTarget = scope.pointCountTarget * 1000 * 1000;
	        var originalMaterial = scope.pointcloud.material;

	        {
	          // COLOR & DEPTH PASS
	          attributeMaterial = scope.pointcloud.material;
	          attributeMaterial.pointShape = _potree2.default.PointShape.CIRCLE;
	          attributeMaterial.interpolate = false;
	          attributeMaterial.weighted = false;
	          attributeMaterial.minSize = 2;
	          attributeMaterial.useLogarithmicDepthBuffer = false;
	          attributeMaterial.useEDL = true;

	          attributeMaterial.size = scope.pointSize;
	          attributeMaterial.pointSizeType = scope.pointSizeType;
	          attributeMaterial.screenWidth = width;
	          attributeMaterial.screenHeight = height;
	          attributeMaterial.pointColorType = scope.pointColorType;
	          attributeMaterial.uniforms.visibleNodes.value = scope.pointcloud.material.visibleNodesTexture;
	          attributeMaterial.uniforms.octreeSize.value = octreeSize;
	          attributeMaterial.fov = scope.camera.fov * (Math.PI / 180);
	          attributeMaterial.spacing = scope.pointcloud.pcoGeometry.spacing;
	          attributeMaterial.near = scope.camera.near;
	          attributeMaterial.far = scope.camera.far;
	          attributeMaterial.heightMin = heightMin;
	          attributeMaterial.heightMax = heightMax;
	          attributeMaterial.intensityMin = scope.pointcloud.material.intensityMin;
	          attributeMaterial.intensityMax = scope.pointcloud.material.intensityMax;
	          attributeMaterial.setClipBoxes(scope.pointcloud.material.clipBoxes);
	          attributeMaterial.clipMode = scope.pointcloud.material.clipMode;
	          attributeMaterial.bbSize = scope.pointcloud.material.bbSize;
	          attributeMaterial.treeType = scope.pointcloud.material.treeType;
	          attributeMaterial.uniforms.classificationLUT.value = scope.pointcloud.material.uniforms.classificationLUT.value;

	          scope.pointcloud.material = attributeMaterial;
	          for (var i = 0; i < scope.pointcloud.visibleNodes.length; i++) {
	            var node = scope.pointcloud.visibleNodes[i];
	            node.sceneNode.material = attributeMaterial;
	          }

	          scope.renderer.clearTarget(rtColor, true, true, true);
	          scope.renderer.render(scope.scenePointCloud, scope.camera, rtColor);

	          scope.pointcloud.material = originalMaterial;
	          for (var i = 0; i < scope.pointcloud.visibleNodes.length; i++) {
	            var node = scope.pointcloud.visibleNodes[i];
	            node.sceneNode.material = originalMaterial;
	          }
	        }

	        // bit of a hack here. The EDL pass will mess up the text of the volume tool
	        // so volume tool is rendered again afterwards
	        scope.volumeTool.render(rtColor);

	        {
	          // EDL OCCLUSION PASS
	          edlMaterial.uniforms.screenWidth.value = width;
	          edlMaterial.uniforms.screenHeight.value = height;
	          edlMaterial.uniforms.near.value = scope.camera.near;
	          edlMaterial.uniforms.far.value = scope.camera.far;
	          edlMaterial.uniforms.colorMap.value = rtColor;
	          edlMaterial.uniforms.expScale.value = scope.camera.far;
	          edlMaterial.uniforms.edlScale.value = scope.edlScale;
	          edlMaterial.uniforms.radius.value = scope.edlRadius;
	          edlMaterial.uniforms.opacity.value = scope.opacity;
	          edlMaterial.depthTest = true;
	          edlMaterial.depthWrite = true;
	          edlMaterial.transparent = true;

	          _potree2.default.utils.screenPass.render(scope.renderer, edlMaterial);
	        }

	        scope.renderer.render(scope.scene, scope.camera);

	        scope.profileTool.render();
	        scope.volumeTool.render();
	        scope.renderer.clearDepth();
	        scope.measuringTool.render();
	        scope.transformationTool.render();
	      }
	    };
	  };

	  //var toggleMessage = 0;

	  function loop(timestamp) {
	    requestAnimationFrame(loop);

	    //var start = new Date().getTime();
	    scope.update(clock.getDelta(), timestamp);
	    //var end = new Date().getTime();
	    //var duration = end - start;
	    //toggleMessage++;
	    //if(toggleMessage > 30){
	    //  document.getElementById("lblMessage").innerHTML = "update: " + duration + "ms";
	    //  toggleMessage = 0;
	    //}

	    if (scope.useEDL) {
	      if (!edlRenderer) {
	        edlRenderer = new EDLRenderer();
	      }
	      edlRenderer.render(scope.renderer);
	    } else if (scope.quality === "Splats") {
	      if (!highQualityRenderer) {
	        highQualityRenderer = new HighQualityRenderer();
	      }
	      highQualityRenderer.render(scope.renderer);
	    } else {
	      potreeRenderer.render();
	    }
	  };

	  scope.initThree();

	  requestAnimationFrame(loop);
	};

	function getMousePointCloudIntersection(mouse, camera, renderer, pointclouds) {
	  var vector = new _three2.default.Vector3(mouse.x, mouse.y, 0.5);
	  vector.unproject(camera);

	  var direction = vector.sub(camera.position).normalize();
	  var ray = new _three2.default.Ray(camera.position, direction);

	  var closestPoint = null;
	  var closestPointDistance = null;

	  for (var i = 0; i < pointclouds.length; i++) {
	    var pointcloud = pointclouds[i];
	    var point = pointcloud.pick(renderer, camera, ray);

	    if (!point) {
	      continue;
	    }

	    var distance = camera.position.distanceTo(point.position);

	    if (!closestPoint || distance < closestPointDistance) {
	      closestPoint = point;
	      closestPointDistance = distance;
	    }
	  }

	  console.log(closestPoint);

	  return closestPoint ? closestPoint.position : null;
	}

	Viewer.prototype = Object.create(_three2.default.EventDispatcher.prototype);

	exports.default = Viewer;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(5)
	module.exports.color = __webpack_require__(6)

/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * dat-gui JavaScript Controller Library
	 * http://code.google.com/p/dat-gui
	 *
	 * Copyright 2011 Data Arts Team, Google Creative Lab
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 */

	/** @namespace */
	var dat = module.exports = dat || {};

	/** @namespace */
	dat.gui = dat.gui || {};

	/** @namespace */
	dat.utils = dat.utils || {};

	/** @namespace */
	dat.controllers = dat.controllers || {};

	/** @namespace */
	dat.dom = dat.dom || {};

	/** @namespace */
	dat.color = dat.color || {};

	dat.utils.css = (function () {
	  return {
	    load: function (url, doc) {
	      doc = doc || document;
	      var link = doc.createElement('link');
	      link.type = 'text/css';
	      link.rel = 'stylesheet';
	      link.href = url;
	      doc.getElementsByTagName('head')[0].appendChild(link);
	    },
	    inject: function(css, doc) {
	      doc = doc || document;
	      var injected = document.createElement('style');
	      injected.type = 'text/css';
	      injected.innerHTML = css;
	      doc.getElementsByTagName('head')[0].appendChild(injected);
	    }
	  }
	})();


	dat.utils.common = (function () {
	  
	  var ARR_EACH = Array.prototype.forEach;
	  var ARR_SLICE = Array.prototype.slice;

	  /**
	   * Band-aid methods for things that should be a lot easier in JavaScript.
	   * Implementation and structure inspired by underscore.js
	   * http://documentcloud.github.com/underscore/
	   */

	  return { 
	    
	    BREAK: {},
	  
	    extend: function(target) {
	      
	      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
	        
	        for (var key in obj)
	          if (!this.isUndefined(obj[key])) 
	            target[key] = obj[key];
	        
	      }, this);
	      
	      return target;
	      
	    },
	    
	    defaults: function(target) {
	      
	      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
	        
	        for (var key in obj)
	          if (this.isUndefined(target[key])) 
	            target[key] = obj[key];
	        
	      }, this);
	      
	      return target;
	    
	    },
	    
	    compose: function() {
	      var toCall = ARR_SLICE.call(arguments);
	            return function() {
	              var args = ARR_SLICE.call(arguments);
	              for (var i = toCall.length -1; i >= 0; i--) {
	                args = [toCall[i].apply(this, args)];
	              }
	              return args[0];
	            }
	    },
	    
	    each: function(obj, itr, scope) {

	      
	      if (ARR_EACH && obj.forEach === ARR_EACH) { 
	        
	        obj.forEach(itr, scope);
	        
	      } else if (obj.length === obj.length + 0) { // Is number but not NaN
	        
	        for (var key = 0, l = obj.length; key < l; key++)
	          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
	            return;
	            
	      } else {

	        for (var key in obj) 
	          if (itr.call(scope, obj[key], key) === this.BREAK)
	            return;
	            
	      }
	            
	    },
	    
	    defer: function(fnc) {
	      setTimeout(fnc, 0);
	    },
	    
	    toArray: function(obj) {
	      if (obj.toArray) return obj.toArray();
	      return ARR_SLICE.call(obj);
	    },

	    isUndefined: function(obj) {
	      return obj === undefined;
	    },
	    
	    isNull: function(obj) {
	      return obj === null;
	    },
	    
	    isNaN: function(obj) {
	      return obj !== obj;
	    },
	    
	    isArray: Array.isArray || function(obj) {
	      return obj.constructor === Array;
	    },
	    
	    isObject: function(obj) {
	      return obj === Object(obj);
	    },
	    
	    isNumber: function(obj) {
	      return obj === obj+0;
	    },
	    
	    isString: function(obj) {
	      return obj === obj+'';
	    },
	    
	    isBoolean: function(obj) {
	      return obj === false || obj === true;
	    },
	    
	    isFunction: function(obj) {
	      return Object.prototype.toString.call(obj) === '[object Function]';
	    }
	  
	  };
	    
	})();


	dat.controllers.Controller = (function (common) {

	  /**
	   * @class An "abstract" class that represents a given property of an object.
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   *
	   * @member dat.controllers
	   */
	  var Controller = function(object, property) {

	    this.initialValue = object[property];

	    /**
	     * Those who extend this class will put their DOM elements in here.
	     * @type {DOMElement}
	     */
	    this.domElement = document.createElement('div');

	    /**
	     * The object to manipulate
	     * @type {Object}
	     */
	    this.object = object;

	    /**
	     * The name of the property to manipulate
	     * @type {String}
	     */
	    this.property = property;

	    /**
	     * The function to be called on change.
	     * @type {Function}
	     * @ignore
	     */
	    this.__onChange = undefined;

	    /**
	     * The function to be called on finishing change.
	     * @type {Function}
	     * @ignore
	     */
	    this.__onFinishChange = undefined;

	  };

	  common.extend(

	      Controller.prototype,

	      /** @lends dat.controllers.Controller.prototype */
	      {

	        /**
	         * Specify that a function fire every time someone changes the value with
	         * this Controller.
	         *
	         * @param {Function} fnc This function will be called whenever the value
	         * is modified via this Controller.
	         * @returns {dat.controllers.Controller} this
	         */
	        onChange: function(fnc) {
	          this.__onChange = fnc;
	          return this;
	        },

	        /**
	         * Specify that a function fire every time someone "finishes" changing
	         * the value wih this Controller. Useful for values that change
	         * incrementally like numbers or strings.
	         *
	         * @param {Function} fnc This function will be called whenever
	         * someone "finishes" changing the value via this Controller.
	         * @returns {dat.controllers.Controller} this
	         */
	        onFinishChange: function(fnc) {
	          this.__onFinishChange = fnc;
	          return this;
	        },

	        /**
	         * Change the value of <code>object[property]</code>
	         *
	         * @param {Object} newValue The new value of <code>object[property]</code>
	         */
	        setValue: function(newValue) {
	          this.object[this.property] = newValue;
	          if (this.__onChange) {
	            this.__onChange.call(this, newValue);
	          }
	          this.updateDisplay();
	          return this;
	        },

	        /**
	         * Gets the value of <code>object[property]</code>
	         *
	         * @returns {Object} The current value of <code>object[property]</code>
	         */
	        getValue: function() {
	          return this.object[this.property];
	        },

	        /**
	         * Refreshes the visual display of a Controller in order to keep sync
	         * with the object's current value.
	         * @returns {dat.controllers.Controller} this
	         */
	        updateDisplay: function() {
	          return this;
	        },

	        /**
	         * @returns {Boolean} true if the value has deviated from initialValue
	         */
	        isModified: function() {
	          return this.initialValue !== this.getValue()
	        }

	      }

	  );

	  return Controller;


	})(dat.utils.common);


	dat.dom.dom = (function (common) {

	  var EVENT_MAP = {
	    'HTMLEvents': ['change'],
	    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],
	    'KeyboardEvents': ['keydown']
	  };

	  var EVENT_MAP_INV = {};
	  common.each(EVENT_MAP, function(v, k) {
	    common.each(v, function(e) {
	      EVENT_MAP_INV[e] = k;
	    });
	  });

	  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

	  function cssValueToPixels(val) {

	    if (val === '0' || common.isUndefined(val)) return 0;

	    var match = val.match(CSS_VALUE_PIXELS);

	    if (!common.isNull(match)) {
	      return parseFloat(match[1]);
	    }

	    // TODO ...ems? %?

	    return 0;

	  }

	  /**
	   * @namespace
	   * @member dat.dom
	   */
	  var dom = {

	    /**
	     * 
	     * @param elem
	     * @param selectable
	     */
	    makeSelectable: function(elem, selectable) {

	      if (elem === undefined || elem.style === undefined) return;

	      elem.onselectstart = selectable ? function() {
	        return false;
	      } : function() {
	      };

	      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
	      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
	      elem.unselectable = selectable ? 'on' : 'off';

	    },

	    /**
	     *
	     * @param elem
	     * @param horizontal
	     * @param vertical
	     */
	    makeFullscreen: function(elem, horizontal, vertical) {

	      if (common.isUndefined(horizontal)) horizontal = true;
	      if (common.isUndefined(vertical)) vertical = true;

	      elem.style.position = 'absolute';

	      if (horizontal) {
	        elem.style.left = 0;
	        elem.style.right = 0;
	      }
	      if (vertical) {
	        elem.style.top = 0;
	        elem.style.bottom = 0;
	      }

	    },

	    /**
	     *
	     * @param elem
	     * @param eventType
	     * @param params
	     */
	    fakeEvent: function(elem, eventType, params, aux) {
	      params = params || {};
	      var className = EVENT_MAP_INV[eventType];
	      if (!className) {
	        throw new Error('Event type ' + eventType + ' not supported.');
	      }
	      var evt = document.createEvent(className);
	      switch (className) {
	        case 'MouseEvents':
	          var clientX = params.x || params.clientX || 0;
	          var clientY = params.y || params.clientY || 0;
	          evt.initMouseEvent(eventType, params.bubbles || false,
	              params.cancelable || true, window, params.clickCount || 1,
	              0, //screen X
	              0, //screen Y
	              clientX, //client X
	              clientY, //client Y
	              false, false, false, false, 0, null);
	          break;
	        case 'KeyboardEvents':
	          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
	          common.defaults(params, {
	            cancelable: true,
	            ctrlKey: false,
	            altKey: false,
	            shiftKey: false,
	            metaKey: false,
	            keyCode: undefined,
	            charCode: undefined
	          });
	          init(eventType, params.bubbles || false,
	              params.cancelable, window,
	              params.ctrlKey, params.altKey,
	              params.shiftKey, params.metaKey,
	              params.keyCode, params.charCode);
	          break;
	        default:
	          evt.initEvent(eventType, params.bubbles || false,
	              params.cancelable || true);
	          break;
	      }
	      common.defaults(evt, aux);
	      elem.dispatchEvent(evt);
	    },

	    /**
	     *
	     * @param elem
	     * @param event
	     * @param func
	     * @param bool
	     */
	    bind: function(elem, event, func, bool) {
	      bool = bool || false;
	      if (elem.addEventListener)
	        elem.addEventListener(event, func, bool);
	      else if (elem.attachEvent)
	        elem.attachEvent('on' + event, func);
	      return dom;
	    },

	    /**
	     *
	     * @param elem
	     * @param event
	     * @param func
	     * @param bool
	     */
	    unbind: function(elem, event, func, bool) {
	      bool = bool || false;
	      if (elem.removeEventListener)
	        elem.removeEventListener(event, func, bool);
	      else if (elem.detachEvent)
	        elem.detachEvent('on' + event, func);
	      return dom;
	    },

	    /**
	     *
	     * @param elem
	     * @param className
	     */
	    addClass: function(elem, className) {
	      if (elem.className === undefined) {
	        elem.className = className;
	      } else if (elem.className !== className) {
	        var classes = elem.className.split(/ +/);
	        if (classes.indexOf(className) == -1) {
	          classes.push(className);
	          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
	        }
	      }
	      return dom;
	    },

	    /**
	     *
	     * @param elem
	     * @param className
	     */
	    removeClass: function(elem, className) {
	      if (className) {
	        if (elem.className === undefined) {
	          // elem.className = className;
	        } else if (elem.className === className) {
	          elem.removeAttribute('class');
	        } else {
	          var classes = elem.className.split(/ +/);
	          var index = classes.indexOf(className);
	          if (index != -1) {
	            classes.splice(index, 1);
	            elem.className = classes.join(' ');
	          }
	        }
	      } else {
	        elem.className = undefined;
	      }
	      return dom;
	    },

	    hasClass: function(elem, className) {
	      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
	    },

	    /**
	     *
	     * @param elem
	     */
	    getWidth: function(elem) {

	      var style = getComputedStyle(elem);

	      return cssValueToPixels(style['border-left-width']) +
	          cssValueToPixels(style['border-right-width']) +
	          cssValueToPixels(style['padding-left']) +
	          cssValueToPixels(style['padding-right']) +
	          cssValueToPixels(style['width']);
	    },

	    /**
	     *
	     * @param elem
	     */
	    getHeight: function(elem) {

	      var style = getComputedStyle(elem);

	      return cssValueToPixels(style['border-top-width']) +
	          cssValueToPixels(style['border-bottom-width']) +
	          cssValueToPixels(style['padding-top']) +
	          cssValueToPixels(style['padding-bottom']) +
	          cssValueToPixels(style['height']);
	    },

	    /**
	     *
	     * @param elem
	     */
	    getOffset: function(elem) {
	      var offset = {left: 0, top:0};
	      if (elem.offsetParent) {
	        do {
	          offset.left += elem.offsetLeft;
	          offset.top += elem.offsetTop;
	        } while (elem = elem.offsetParent);
	      }
	      return offset;
	    },

	    // http://stackoverflow.com/posts/2684561/revisions
	    /**
	     * 
	     * @param elem
	     */
	    isActive: function(elem) {
	      return elem === document.activeElement && ( elem.type || elem.href );
	    }

	  };

	  return dom;

	})(dat.utils.common);


	dat.controllers.OptionController = (function (Controller, dom, common) {

	  /**
	   * @class Provides a select input to alter the property of an object, using a
	   * list of accepted values.
	   *
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   * @param {Object|string[]} options A map of labels to acceptable values, or
	   * a list of acceptable string values.
	   *
	   * @member dat.controllers
	   */
	  var OptionController = function(object, property, options) {

	    OptionController.superclass.call(this, object, property);

	    var _this = this;

	    /**
	     * The drop down menu
	     * @ignore
	     */
	    this.__select = document.createElement('select');

	    if (common.isArray(options)) {
	      var map = {};
	      common.each(options, function(element) {
	        map[element] = element;
	      });
	      options = map;
	    }

	    common.each(options, function(value, key) {

	      var opt = document.createElement('option');
	      opt.innerHTML = key;
	      opt.setAttribute('value', value);
	      _this.__select.appendChild(opt);

	    });

	    // Acknowledge original value
	    this.updateDisplay();

	    dom.bind(this.__select, 'change', function() {
	      var desiredValue = this.options[this.selectedIndex].value;
	      _this.setValue(desiredValue);
	    });

	    this.domElement.appendChild(this.__select);

	  };

	  OptionController.superclass = Controller;

	  common.extend(

	      OptionController.prototype,
	      Controller.prototype,

	      {

	        setValue: function(v) {
	          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);
	          if (this.__onFinishChange) {
	            this.__onFinishChange.call(this, this.getValue());
	          }
	          return toReturn;
	        },

	        updateDisplay: function() {
	          this.__select.value = this.getValue();
	          return OptionController.superclass.prototype.updateDisplay.call(this);
	        }

	      }

	  );

	  return OptionController;

	})(dat.controllers.Controller,
	dat.dom.dom,
	dat.utils.common);


	dat.controllers.NumberController = (function (Controller, common) {

	  /**
	   * @class Represents a given property of an object that is a number.
	   *
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   * @param {Object} [params] Optional parameters
	   * @param {Number} [params.min] Minimum allowed value
	   * @param {Number} [params.max] Maximum allowed value
	   * @param {Number} [params.step] Increment by which to change value
	   *
	   * @member dat.controllers
	   */
	  var NumberController = function(object, property, params) {

	    NumberController.superclass.call(this, object, property);

	    params = params || {};

	    this.__min = params.min;
	    this.__max = params.max;
	    this.__step = params.step;

	    if (common.isUndefined(this.__step)) {

	      if (this.initialValue == 0) {
	        this.__impliedStep = 1; // What are we, psychics?
	      } else {
	        // Hey Doug, check this out.
	        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;
	      }

	    } else {

	      this.__impliedStep = this.__step;

	    }

	    this.__precision = numDecimals(this.__impliedStep);


	  };

	  NumberController.superclass = Controller;

	  common.extend(

	      NumberController.prototype,
	      Controller.prototype,

	      /** @lends dat.controllers.NumberController.prototype */
	      {

	        setValue: function(v) {

	          if (this.__min !== undefined && v < this.__min) {
	            v = this.__min;
	          } else if (this.__max !== undefined && v > this.__max) {
	            v = this.__max;
	          }

	          if (this.__step !== undefined && v % this.__step != 0) {
	            v = Math.round(v / this.__step) * this.__step;
	          }

	          return NumberController.superclass.prototype.setValue.call(this, v);

	        },

	        /**
	         * Specify a minimum value for <code>object[property]</code>.
	         *
	         * @param {Number} minValue The minimum value for
	         * <code>object[property]</code>
	         * @returns {dat.controllers.NumberController} this
	         */
	        min: function(v) {
	          this.__min = v;
	          return this;
	        },

	        /**
	         * Specify a maximum value for <code>object[property]</code>.
	         *
	         * @param {Number} maxValue The maximum value for
	         * <code>object[property]</code>
	         * @returns {dat.controllers.NumberController} this
	         */
	        max: function(v) {
	          this.__max = v;
	          return this;
	        },

	        /**
	         * Specify a step value that dat.controllers.NumberController
	         * increments by.
	         *
	         * @param {Number} stepValue The step value for
	         * dat.controllers.NumberController
	         * @default if minimum and maximum specified increment is 1% of the
	         * difference otherwise stepValue is 1
	         * @returns {dat.controllers.NumberController} this
	         */
	        step: function(v) {
	          this.__step = v;
	          return this;
	        }

	      }

	  );

	  function numDecimals(x) {
	    x = x.toString();
	    if (x.indexOf('.') > -1) {
	      return x.length - x.indexOf('.') - 1;
	    } else {
	      return 0;
	    }
	  }

	  return NumberController;

	})(dat.controllers.Controller,
	dat.utils.common);


	dat.controllers.NumberControllerBox = (function (NumberController, dom, common) {

	  /**
	   * @class Represents a given property of an object that is a number and
	   * provides an input element with which to manipulate it.
	   *
	   * @extends dat.controllers.Controller
	   * @extends dat.controllers.NumberController
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   * @param {Object} [params] Optional parameters
	   * @param {Number} [params.min] Minimum allowed value
	   * @param {Number} [params.max] Maximum allowed value
	   * @param {Number} [params.step] Increment by which to change value
	   *
	   * @member dat.controllers
	   */
	  var NumberControllerBox = function(object, property, params) {

	    this.__truncationSuspended = false;

	    NumberControllerBox.superclass.call(this, object, property, params);

	    var _this = this;

	    /**
	     * {Number} Previous mouse y position
	     * @ignore
	     */
	    var prev_y;

	    this.__input = document.createElement('input');
	    this.__input.setAttribute('type', 'text');

	    // Makes it so manually specified values are not truncated.

	    dom.bind(this.__input, 'change', onChange);
	    dom.bind(this.__input, 'blur', onBlur);
	    dom.bind(this.__input, 'mousedown', onMouseDown);
	    dom.bind(this.__input, 'keydown', function(e) {

	      // When pressing entire, you can be as precise as you want.
	      if (e.keyCode === 13) {
	        _this.__truncationSuspended = true;
	        this.blur();
	        _this.__truncationSuspended = false;
	      }

	    });

	    function onChange() {
	      var attempted = parseFloat(_this.__input.value);
	      if (!common.isNaN(attempted)) _this.setValue(attempted);
	    }

	    function onBlur() {
	      onChange();
	      if (_this.__onFinishChange) {
	        _this.__onFinishChange.call(_this, _this.getValue());
	      }
	    }

	    function onMouseDown(e) {
	      dom.bind(window, 'mousemove', onMouseDrag);
	      dom.bind(window, 'mouseup', onMouseUp);
	      prev_y = e.clientY;
	    }

	    function onMouseDrag(e) {

	      var diff = prev_y - e.clientY;
	      _this.setValue(_this.getValue() + diff * _this.__impliedStep);

	      prev_y = e.clientY;

	    }

	    function onMouseUp() {
	      dom.unbind(window, 'mousemove', onMouseDrag);
	      dom.unbind(window, 'mouseup', onMouseUp);
	    }

	    this.updateDisplay();

	    this.domElement.appendChild(this.__input);

	  };

	  NumberControllerBox.superclass = NumberController;

	  common.extend(

	      NumberControllerBox.prototype,
	      NumberController.prototype,

	      {

	        updateDisplay: function() {

	          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
	          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);
	        }

	      }

	  );

	  function roundToDecimal(value, decimals) {
	    var tenTo = Math.pow(10, decimals);
	    return Math.round(value * tenTo) / tenTo;
	  }

	  return NumberControllerBox;

	})(dat.controllers.NumberController,
	dat.dom.dom,
	dat.utils.common);


	dat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {

	  /**
	   * @class Represents a given property of an object that is a number, contains
	   * a minimum and maximum, and provides a slider element with which to
	   * manipulate it. It should be noted that the slider element is made up of
	   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
	   * <code>&lt;slider&gt;</code> element.
	   *
	   * @extends dat.controllers.Controller
	   * @extends dat.controllers.NumberController
	   * 
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   * @param {Number} minValue Minimum allowed value
	   * @param {Number} maxValue Maximum allowed value
	   * @param {Number} stepValue Increment by which to change value
	   *
	   * @member dat.controllers
	   */
	  var NumberControllerSlider = function(object, property, min, max, step) {

	    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });

	    var _this = this;

	    this.__background = document.createElement('div');
	    this.__foreground = document.createElement('div');
	    


	    dom.bind(this.__background, 'mousedown', onMouseDown);
	    
	    dom.addClass(this.__background, 'slider');
	    dom.addClass(this.__foreground, 'slider-fg');

	    function onMouseDown(e) {

	      dom.bind(window, 'mousemove', onMouseDrag);
	      dom.bind(window, 'mouseup', onMouseUp);

	      onMouseDrag(e);
	    }

	    function onMouseDrag(e) {

	      e.preventDefault();

	      var offset = dom.getOffset(_this.__background);
	      var width = dom.getWidth(_this.__background);
	      
	      _this.setValue(
	        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)
	      );

	      return false;

	    }

	    function onMouseUp() {
	      dom.unbind(window, 'mousemove', onMouseDrag);
	      dom.unbind(window, 'mouseup', onMouseUp);
	      if (_this.__onFinishChange) {
	        _this.__onFinishChange.call(_this, _this.getValue());
	      }
	    }

	    this.updateDisplay();

	    this.__background.appendChild(this.__foreground);
	    this.domElement.appendChild(this.__background);

	  };

	  NumberControllerSlider.superclass = NumberController;

	  /**
	   * Injects default stylesheet for slider elements.
	   */
	  NumberControllerSlider.useDefaultStyles = function() {
	    css.inject(styleSheet);
	  };

	  common.extend(

	      NumberControllerSlider.prototype,
	      NumberController.prototype,

	      {

	        updateDisplay: function() {
	          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);
	          this.__foreground.style.width = pct*100+'%';
	          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);
	        }

	      }



	  );

	  function map(v, i1, i2, o1, o2) {
	    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
	  }

	  return NumberControllerSlider;
	  
	})(dat.controllers.NumberController,
	dat.dom.dom,
	dat.utils.css,
	dat.utils.common,
	".slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");


	dat.controllers.FunctionController = (function (Controller, dom, common) {

	  /**
	   * @class Provides a GUI interface to fire a specified method, a property of an object.
	   *
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   *
	   * @member dat.controllers
	   */
	  var FunctionController = function(object, property, text) {

	    FunctionController.superclass.call(this, object, property);

	    var _this = this;

	    this.__button = document.createElement('div');
	    this.__button.innerHTML = text === undefined ? 'Fire' : text;
	    dom.bind(this.__button, 'click', function(e) {
	      e.preventDefault();
	      _this.fire();
	      return false;
	    });

	    dom.addClass(this.__button, 'button');

	    this.domElement.appendChild(this.__button);


	  };

	  FunctionController.superclass = Controller;

	  common.extend(

	      FunctionController.prototype,
	      Controller.prototype,
	      {
	        
	        fire: function() {
	          if (this.__onChange) {
	            this.__onChange.call(this);
	          }
	          if (this.__onFinishChange) {
	            this.__onFinishChange.call(this, this.getValue());
	          }
	          this.getValue().call(this.object);
	        }
	      }

	  );

	  return FunctionController;

	})(dat.controllers.Controller,
	dat.dom.dom,
	dat.utils.common);


	dat.controllers.BooleanController = (function (Controller, dom, common) {

	  /**
	   * @class Provides a checkbox input to alter the boolean property of an object.
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   *
	   * @member dat.controllers
	   */
	  var BooleanController = function(object, property) {

	    BooleanController.superclass.call(this, object, property);

	    var _this = this;
	    this.__prev = this.getValue();

	    this.__checkbox = document.createElement('input');
	    this.__checkbox.setAttribute('type', 'checkbox');


	    dom.bind(this.__checkbox, 'change', onChange, false);

	    this.domElement.appendChild(this.__checkbox);

	    // Match original value
	    this.updateDisplay();

	    function onChange() {
	      _this.setValue(!_this.__prev);
	    }

	  };

	  BooleanController.superclass = Controller;

	  common.extend(

	      BooleanController.prototype,
	      Controller.prototype,

	      {

	        setValue: function(v) {
	          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);
	          if (this.__onFinishChange) {
	            this.__onFinishChange.call(this, this.getValue());
	          }
	          this.__prev = this.getValue();
	          return toReturn;
	        },

	        updateDisplay: function() {
	          
	          if (this.getValue() === true) {
	            this.__checkbox.setAttribute('checked', 'checked');
	            this.__checkbox.checked = true;    
	          } else {
	              this.__checkbox.checked = false;
	          }

	          return BooleanController.superclass.prototype.updateDisplay.call(this);

	        }


	      }

	  );

	  return BooleanController;

	})(dat.controllers.Controller,
	dat.dom.dom,
	dat.utils.common);


	dat.color.toString = (function (common) {

	  return function(color) {

	    if (color.a == 1 || common.isUndefined(color.a)) {

	      var s = color.hex.toString(16);
	      while (s.length < 6) {
	        s = '0' + s;
	      }

	      return '#' + s;

	    } else {

	      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

	    }

	  }

	})(dat.utils.common);


	dat.color.interpret = (function (toString, common) {

	  var result, toReturn;

	  var interpret = function() {

	    toReturn = false;

	    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

	    common.each(INTERPRETATIONS, function(family) {

	      if (family.litmus(original)) {

	        common.each(family.conversions, function(conversion, conversionName) {

	          result = conversion.read(original);

	          if (toReturn === false && result !== false) {
	            toReturn = result;
	            result.conversionName = conversionName;
	            result.conversion = conversion;
	            return common.BREAK;

	          }

	        });

	        return common.BREAK;

	      }

	    });

	    return toReturn;

	  };

	  var INTERPRETATIONS = [

	    // Strings
	    {

	      litmus: common.isString,

	      conversions: {

	        THREE_CHAR_HEX: {

	          read: function(original) {

	            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
	            if (test === null) return false;

	            return {
	              space: 'HEX',
	              hex: parseInt(
	                  '0x' +
	                      test[1].toString() + test[1].toString() +
	                      test[2].toString() + test[2].toString() +
	                      test[3].toString() + test[3].toString())
	            };

	          },

	          write: toString

	        },

	        SIX_CHAR_HEX: {

	          read: function(original) {

	            var test = original.match(/^#([A-F0-9]{6})$/i);
	            if (test === null) return false;

	            return {
	              space: 'HEX',
	              hex: parseInt('0x' + test[1].toString())
	            };

	          },

	          write: toString

	        },

	        CSS_RGB: {

	          read: function(original) {

	            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
	            if (test === null) return false;

	            return {
	              space: 'RGB',
	              r: parseFloat(test[1]),
	              g: parseFloat(test[2]),
	              b: parseFloat(test[3])
	            };

	          },

	          write: toString

	        },

	        CSS_RGBA: {

	          read: function(original) {

	            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
	            if (test === null) return false;

	            return {
	              space: 'RGB',
	              r: parseFloat(test[1]),
	              g: parseFloat(test[2]),
	              b: parseFloat(test[3]),
	              a: parseFloat(test[4])
	            };

	          },

	          write: toString

	        }

	      }

	    },

	    // Numbers
	    {

	      litmus: common.isNumber,

	      conversions: {

	        HEX: {
	          read: function(original) {
	            return {
	              space: 'HEX',
	              hex: original,
	              conversionName: 'HEX'
	            }
	          },

	          write: function(color) {
	            return color.hex;
	          }
	        }

	      }

	    },

	    // Arrays
	    {

	      litmus: common.isArray,

	      conversions: {

	        RGB_ARRAY: {
	          read: function(original) {
	            if (original.length != 3) return false;
	            return {
	              space: 'RGB',
	              r: original[0],
	              g: original[1],
	              b: original[2]
	            };
	          },

	          write: function(color) {
	            return [color.r, color.g, color.b];
	          }

	        },

	        RGBA_ARRAY: {
	          read: function(original) {
	            if (original.length != 4) return false;
	            return {
	              space: 'RGB',
	              r: original[0],
	              g: original[1],
	              b: original[2],
	              a: original[3]
	            };
	          },

	          write: function(color) {
	            return [color.r, color.g, color.b, color.a];
	          }

	        }

	      }

	    },

	    // Objects
	    {

	      litmus: common.isObject,

	      conversions: {

	        RGBA_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.r) &&
	                common.isNumber(original.g) &&
	                common.isNumber(original.b) &&
	                common.isNumber(original.a)) {
	              return {
	                space: 'RGB',
	                r: original.r,
	                g: original.g,
	                b: original.b,
	                a: original.a
	              }
	            }
	            return false;
	          },

	          write: function(color) {
	            return {
	              r: color.r,
	              g: color.g,
	              b: color.b,
	              a: color.a
	            }
	          }
	        },

	        RGB_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.r) &&
	                common.isNumber(original.g) &&
	                common.isNumber(original.b)) {
	              return {
	                space: 'RGB',
	                r: original.r,
	                g: original.g,
	                b: original.b
	              }
	            }
	            return false;
	          },

	          write: function(color) {
	            return {
	              r: color.r,
	              g: color.g,
	              b: color.b
	            }
	          }
	        },

	        HSVA_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.h) &&
	                common.isNumber(original.s) &&
	                common.isNumber(original.v) &&
	                common.isNumber(original.a)) {
	              return {
	                space: 'HSV',
	                h: original.h,
	                s: original.s,
	                v: original.v,
	                a: original.a
	              }
	            }
	            return false;
	          },

	          write: function(color) {
	            return {
	              h: color.h,
	              s: color.s,
	              v: color.v,
	              a: color.a
	            }
	          }
	        },

	        HSV_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.h) &&
	                common.isNumber(original.s) &&
	                common.isNumber(original.v)) {
	              return {
	                space: 'HSV',
	                h: original.h,
	                s: original.s,
	                v: original.v
	              }
	            }
	            return false;
	          },

	          write: function(color) {
	            return {
	              h: color.h,
	              s: color.s,
	              v: color.v
	            }
	          }

	        }

	      }

	    }


	  ];

	  return interpret;


	})(dat.color.toString,
	dat.utils.common);


	dat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {

	  css.inject(styleSheet);

	  /** Outer-most className for GUI's */
	  var CSS_NAMESPACE = 'dg';

	  var HIDE_KEY_CODE = 72;

	  /** The only value shared between the JS and SCSS. Use caution. */
	  var CLOSE_BUTTON_HEIGHT = 20;

	  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

	  var SUPPORTS_LOCAL_STORAGE = (function() {
	    try {
	      return 'localStorage' in window && window['localStorage'] !== null;
	    } catch (e) {
	      return false;
	    }
	  })();

	  var SAVE_DIALOGUE;

	  /** Have we yet to create an autoPlace GUI? */
	  var auto_place_virgin = true;

	  /** Fixed position div that auto place GUI's go inside */
	  var auto_place_container;

	  /** Are we hiding the GUI's ? */
	  var hide = false;

	  /** GUI's which should be hidden */
	  var hideable_guis = [];

	  /**
	   * A lightweight controller library for JavaScript. It allows you to easily
	   * manipulate variables and fire functions on the fly.
	   * @class
	   *
	   * @member dat.gui
	   *
	   * @param {Object} [params]
	   * @param {String} [params.name] The name of this GUI.
	   * @param {Object} [params.load] JSON object representing the saved state of
	   * this GUI.
	   * @param {Boolean} [params.auto=true]
	   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
	   * @param {Boolean} [params.closed] If true, starts closed
	   */
	  var GUI = function(params) {

	    var _this = this;

	    /**
	     * Outermost DOM Element
	     * @type DOMElement
	     */
	    this.domElement = document.createElement('div');
	    this.__ul = document.createElement('ul');
	    this.domElement.appendChild(this.__ul);

	    dom.addClass(this.domElement, CSS_NAMESPACE);

	    /**
	     * Nested GUI's by name
	     * @ignore
	     */
	    this.__folders = {};

	    this.__controllers = [];

	    /**
	     * List of objects I'm remembering for save, only used in top level GUI
	     * @ignore
	     */
	    this.__rememberedObjects = [];

	    /**
	     * Maps the index of remembered objects to a map of controllers, only used
	     * in top level GUI.
	     *
	     * @private
	     * @ignore
	     *
	     * @example
	     * [
	     *  {
	     *    propertyName: Controller,
	     *    anotherPropertyName: Controller
	     *  },
	     *  {
	     *    propertyName: Controller
	     *  }
	     * ]
	     */
	    this.__rememberedObjectIndecesToControllers = [];

	    this.__listening = [];

	    params = params || {};

	    // Default parameters
	    params = common.defaults(params, {
	      autoPlace: true,
	      width: GUI.DEFAULT_WIDTH
	    });

	    params = common.defaults(params, {
	      resizable: params.autoPlace,
	      hideable: params.autoPlace
	    });


	    if (!common.isUndefined(params.load)) {

	      // Explicit preset
	      if (params.preset) params.load.preset = params.preset;

	    } else {

	      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };

	    }

	    if (common.isUndefined(params.parent) && params.hideable) {
	      hideable_guis.push(this);
	    }

	    // Only root level GUI's are resizable.
	    params.resizable = common.isUndefined(params.parent) && params.resizable;


	    if (params.autoPlace && common.isUndefined(params.scrollable)) {
	      params.scrollable = true;
	    }
	//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;

	    // Not part of params because I don't want people passing this in via
	    // constructor. Should be a 'remembered' value.
	    var use_local_storage =
	        SUPPORTS_LOCAL_STORAGE &&
	            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';

	    Object.defineProperties(this,

	        /** @lends dat.gui.GUI.prototype */
	        {

	          /**
	           * The parent <code>GUI</code>
	           * @type dat.gui.GUI
	           */
	          parent: {
	            get: function() {
	              return params.parent;
	            }
	          },

	          scrollable: {
	            get: function() {
	              return params.scrollable;
	            }
	          },

	          /**
	           * Handles <code>GUI</code>'s element placement for you
	           * @type Boolean
	           */
	          autoPlace: {
	            get: function() {
	              return params.autoPlace;
	            }
	          },

	          /**
	           * The identifier for a set of saved values
	           * @type String
	           */
	          preset: {

	            get: function() {
	              if (_this.parent) {
	                return _this.getRoot().preset;
	              } else {
	                return params.load.preset;
	              }
	            },

	            set: function(v) {
	              if (_this.parent) {
	                _this.getRoot().preset = v;
	              } else {
	                params.load.preset = v;
	              }
	              setPresetSelectIndex(this);
	              _this.revert();
	            }

	          },

	          /**
	           * The width of <code>GUI</code> element
	           * @type Number
	           */
	          width: {
	            get: function() {
	              return params.width;
	            },
	            set: function(v) {
	              params.width = v;
	              setWidth(_this, v);
	            }
	          },

	          /**
	           * The name of <code>GUI</code>. Used for folders. i.e
	           * a folder's name
	           * @type String
	           */
	          name: {
	            get: function() {
	              return params.name;
	            },
	            set: function(v) {
	              // TODO Check for collisions among sibling folders
	              params.name = v;
	              if (title_row_name) {
	                title_row_name.innerHTML = params.name;
	              }
	            }
	          },

	          /**
	           * Whether the <code>GUI</code> is collapsed or not
	           * @type Boolean
	           */
	          closed: {
	            get: function() {
	              return params.closed;
	            },
	            set: function(v) {
	              params.closed = v;
	              if (params.closed) {
	                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
	              } else {
	                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
	              }
	              // For browsers that aren't going to respect the CSS transition,
	              // Lets just check our height against the window height right off
	              // the bat.
	              this.onResize();

	              if (_this.__closeButton) {
	                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
	              }
	            }
	          },

	          /**
	           * Contains all presets
	           * @type Object
	           */
	          load: {
	            get: function() {
	              return params.load;
	            }
	          },

	          /**
	           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
	           * <code>remember</code>ing
	           * @type Boolean
	           */
	          useLocalStorage: {

	            get: function() {
	              return use_local_storage;
	            },
	            set: function(bool) {
	              if (SUPPORTS_LOCAL_STORAGE) {
	                use_local_storage = bool;
	                if (bool) {
	                  dom.bind(window, 'unload', saveToLocalStorage);
	                } else {
	                  dom.unbind(window, 'unload', saveToLocalStorage);
	                }
	                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
	              }
	            }

	          }

	        });

	    // Are we a root level GUI?
	    if (common.isUndefined(params.parent)) {

	      params.closed = false;

	      dom.addClass(this.domElement, GUI.CLASS_MAIN);
	      dom.makeSelectable(this.domElement, false);

	      // Are we supposed to be loading locally?
	      if (SUPPORTS_LOCAL_STORAGE) {

	        if (use_local_storage) {

	          _this.useLocalStorage = true;

	          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

	          if (saved_gui) {
	            params.load = JSON.parse(saved_gui);
	          }

	        }

	      }

	      this.__closeButton = document.createElement('div');
	      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
	      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
	      this.domElement.appendChild(this.__closeButton);

	      dom.bind(this.__closeButton, 'click', function() {

	        _this.closed = !_this.closed;


	      });


	      // Oh, you're a nested GUI!
	    } else {

	      if (params.closed === undefined) {
	        params.closed = true;
	      }

	      var title_row_name = document.createTextNode(params.name);
	      dom.addClass(title_row_name, 'controller-name');

	      var title_row = addRow(_this, title_row_name);

	      var on_click_title = function(e) {
	        e.preventDefault();
	        _this.closed = !_this.closed;
	        return false;
	      };

	      dom.addClass(this.__ul, GUI.CLASS_CLOSED);

	      dom.addClass(title_row, 'title');
	      dom.bind(title_row, 'click', on_click_title);

	      if (!params.closed) {
	        this.closed = false;
	      }

	    }

	    if (params.autoPlace) {

	      if (common.isUndefined(params.parent)) {

	        if (auto_place_virgin) {
	          auto_place_container = document.createElement('div');
	          dom.addClass(auto_place_container, CSS_NAMESPACE);
	          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);
	          document.body.appendChild(auto_place_container);
	          auto_place_virgin = false;
	        }

	        // Put it in the dom for you.
	        auto_place_container.appendChild(this.domElement);

	        // Apply the auto styles
	        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);

	      }


	      // Make it not elastic.
	      if (!this.parent) setWidth(_this, params.width);

	    }

	    dom.bind(window, 'resize', function() { _this.onResize() });
	    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });
	    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });
	    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });
	    this.onResize();


	    if (params.resizable) {
	      addResizeHandle(this);
	    }

	    function saveToLocalStorage() {
	      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
	    }

	    var root = _this.getRoot();
	    function resetWidth() {
	        var root = _this.getRoot();
	        root.width += 1;
	        common.defer(function() {
	          root.width -= 1;
	        });
	      }

	      if (!params.parent) {
	        resetWidth();
	      }

	  };

	  GUI.toggleHide = function() {

	    hide = !hide;
	    common.each(hideable_guis, function(gui) {
	      gui.domElement.style.zIndex = hide ? -999 : 999;
	      gui.domElement.style.opacity = hide ? 0 : 1;
	    });
	  };

	  GUI.CLASS_AUTO_PLACE = 'a';
	  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
	  GUI.CLASS_MAIN = 'main';
	  GUI.CLASS_CONTROLLER_ROW = 'cr';
	  GUI.CLASS_TOO_TALL = 'taller-than-window';
	  GUI.CLASS_CLOSED = 'closed';
	  GUI.CLASS_CLOSE_BUTTON = 'close-button';
	  GUI.CLASS_DRAG = 'drag';

	  GUI.DEFAULT_WIDTH = 245;
	  GUI.TEXT_CLOSED = 'Close Controls';
	  GUI.TEXT_OPEN = 'Open Controls';

	  dom.bind(window, 'keydown', function(e) {

	    if (document.activeElement.type !== 'text' &&
	        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {
	      GUI.toggleHide();
	    }

	  }, false);

	  common.extend(

	      GUI.prototype,

	      /** @lends dat.gui.GUI */
	      {

	        /**
	         * @param object
	         * @param property
	         * @returns {dat.controllers.Controller} The new controller that was added.
	         * @instance
	         */
	        add: function(object, property) {

	          return add(
	              this,
	              object,
	              property,
	              {
	                factoryArgs: Array.prototype.slice.call(arguments, 2)
	              }
	          );

	        },

	        /**
	         * @param object
	         * @param property
	         * @returns {dat.controllers.ColorController} The new controller that was added.
	         * @instance
	         */
	        addColor: function(object, property) {

	          return add(
	              this,
	              object,
	              property,
	              {
	                color: true
	              }
	          );

	        },

	        /**
	         * @param controller
	         * @instance
	         */
	        remove: function(controller) {

	          // TODO listening?
	          this.__ul.removeChild(controller.__li);
	          this.__controllers.slice(this.__controllers.indexOf(controller), 1);
	          var _this = this;
	          common.defer(function() {
	            _this.onResize();
	          });

	        },

	        destroy: function() {

	          if (this.autoPlace) {
	            auto_place_container.removeChild(this.domElement);
	          }

	        },

	        /**
	         * @param name
	         * @returns {dat.gui.GUI} The new folder.
	         * @throws {Error} if this GUI already has a folder by the specified
	         * name
	         * @instance
	         */
	        addFolder: function(name) {

	          // We have to prevent collisions on names in order to have a key
	          // by which to remember saved values
	          if (this.__folders[name] !== undefined) {
	            throw new Error('You already have a folder in this GUI by the' +
	                ' name "' + name + '"');
	          }

	          var new_gui_params = { name: name, parent: this };

	          // We need to pass down the autoPlace trait so that we can
	          // attach event listeners to open/close folder actions to
	          // ensure that a scrollbar appears if the window is too short.
	          new_gui_params.autoPlace = this.autoPlace;

	          // Do we have saved appearance data for this folder?

	          if (this.load && // Anything loaded?
	              this.load.folders && // Was my parent a dead-end?
	              this.load.folders[name]) { // Did daddy remember me?

	            // Start me closed if I was closed
	            new_gui_params.closed = this.load.folders[name].closed;

	            // Pass down the loaded data
	            new_gui_params.load = this.load.folders[name];

	          }

	          var gui = new GUI(new_gui_params);
	          this.__folders[name] = gui;

	          var li = addRow(this, gui.domElement);
	          dom.addClass(li, 'folder');
	          return gui;

	        },

	        open: function() {
	          this.closed = false;
	        },

	        close: function() {
	          this.closed = true;
	        },

	        onResize: function() {

	          var root = this.getRoot();

	          if (root.scrollable) {

	            var top = dom.getOffset(root.__ul).top;
	            var h = 0;

	            common.each(root.__ul.childNodes, function(node) {
	              if (! (root.autoPlace && node === root.__save_row))
	                h += dom.getHeight(node);
	            });

	            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
	              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
	              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
	            } else {
	              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
	              root.__ul.style.height = 'auto';
	            }

	          }

	          if (root.__resize_handle) {
	            common.defer(function() {
	              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
	            });
	          }

	          if (root.__closeButton) {
	            root.__closeButton.style.width = root.width + 'px';
	          }

	        },

	        /**
	         * Mark objects for saving. The order of these objects cannot change as
	         * the GUI grows. When remembering new objects, append them to the end
	         * of the list.
	         *
	         * @param {Object...} objects
	         * @throws {Error} if not called on a top level GUI.
	         * @instance
	         */
	        remember: function() {

	          if (common.isUndefined(SAVE_DIALOGUE)) {
	            SAVE_DIALOGUE = new CenteredDiv();
	            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;
	          }

	          if (this.parent) {
	            throw new Error("You can only call remember on a top level GUI.");
	          }

	          var _this = this;

	          common.each(Array.prototype.slice.call(arguments), function(object) {
	            if (_this.__rememberedObjects.length == 0) {
	              addSaveMenu(_this);
	            }
	            if (_this.__rememberedObjects.indexOf(object) == -1) {
	              _this.__rememberedObjects.push(object);
	            }
	          });

	          if (this.autoPlace) {
	            // Set save row width
	            setWidth(this, this.width);
	          }

	        },

	        /**
	         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
	         * @instance
	         */
	        getRoot: function() {
	          var gui = this;
	          while (gui.parent) {
	            gui = gui.parent;
	          }
	          return gui;
	        },

	        /**
	         * @returns {Object} a JSON object representing the current state of
	         * this GUI as well as its remembered properties.
	         * @instance
	         */
	        getSaveObject: function() {

	          var toReturn = this.load;

	          toReturn.closed = this.closed;

	          // Am I remembering any values?
	          if (this.__rememberedObjects.length > 0) {

	            toReturn.preset = this.preset;

	            if (!toReturn.remembered) {
	              toReturn.remembered = {};
	            }

	            toReturn.remembered[this.preset] = getCurrentPreset(this);

	          }

	          toReturn.folders = {};
	          common.each(this.__folders, function(element, key) {
	            toReturn.folders[key] = element.getSaveObject();
	          });

	          return toReturn;

	        },

	        save: function() {

	          if (!this.load.remembered) {
	            this.load.remembered = {};
	          }

	          this.load.remembered[this.preset] = getCurrentPreset(this);
	          markPresetModified(this, false);

	        },

	        saveAs: function(presetName) {

	          if (!this.load.remembered) {

	            // Retain default values upon first save
	            this.load.remembered = {};
	            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);

	          }

	          this.load.remembered[presetName] = getCurrentPreset(this);
	          this.preset = presetName;
	          addPresetOption(this, presetName, true);

	        },

	        revert: function(gui) {

	          common.each(this.__controllers, function(controller) {
	            // Make revert work on Default.
	            if (!this.getRoot().load.remembered) {
	              controller.setValue(controller.initialValue);
	            } else {
	              recallSavedValue(gui || this.getRoot(), controller);
	            }
	          }, this);

	          common.each(this.__folders, function(folder) {
	            folder.revert(folder);
	          });

	          if (!gui) {
	            markPresetModified(this.getRoot(), false);
	          }


	        },

	        listen: function(controller) {

	          var init = this.__listening.length == 0;
	          this.__listening.push(controller);
	          if (init) updateDisplays(this.__listening);

	        }

	      }

	  );

	  function add(gui, object, property, params) {

	    if (object[property] === undefined) {
	      throw new Error("Object " + object + " has no property \"" + property + "\"");
	    }

	    var controller;

	    if (params.color) {

	      controller = new ColorController(object, property);

	    } else {

	      var factoryArgs = [object,property].concat(params.factoryArgs);
	      controller = controllerFactory.apply(gui, factoryArgs);

	    }

	    if (params.before instanceof Controller) {
	      params.before = params.before.__li;
	    }

	    recallSavedValue(gui, controller);

	    dom.addClass(controller.domElement, 'c');

	    var name = document.createElement('span');
	    dom.addClass(name, 'property-name');
	    name.innerHTML = controller.property;

	    var container = document.createElement('div');
	    container.appendChild(name);
	    container.appendChild(controller.domElement);

	    var li = addRow(gui, container, params.before);

	    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
	    dom.addClass(li, typeof controller.getValue());

	    augmentController(gui, li, controller);

	    gui.__controllers.push(controller);

	    return controller;

	  }

	  /**
	   * Add a row to the end of the GUI or before another row.
	   *
	   * @param gui
	   * @param [dom] If specified, inserts the dom content in the new row
	   * @param [liBefore] If specified, places the new row before another row
	   */
	  function addRow(gui, dom, liBefore) {
	    var li = document.createElement('li');
	    if (dom) li.appendChild(dom);
	    if (liBefore) {
	      gui.__ul.insertBefore(li, params.before);
	    } else {
	      gui.__ul.appendChild(li);
	    }
	    gui.onResize();
	    return li;
	  }

	  function augmentController(gui, li, controller) {

	    controller.__li = li;
	    controller.__gui = gui;

	    common.extend(controller, {

	      options: function(options) {

	        if (arguments.length > 1) {
	          controller.remove();

	          return add(
	              gui,
	              controller.object,
	              controller.property,
	              {
	                before: controller.__li.nextElementSibling,
	                factoryArgs: [common.toArray(arguments)]
	              }
	          );

	        }

	        if (common.isArray(options) || common.isObject(options)) {
	          controller.remove();

	          return add(
	              gui,
	              controller.object,
	              controller.property,
	              {
	                before: controller.__li.nextElementSibling,
	                factoryArgs: [options]
	              }
	          );

	        }

	      },

	      name: function(v) {
	        controller.__li.firstElementChild.firstElementChild.innerHTML = v;
	        return controller;
	      },

	      listen: function() {
	        controller.__gui.listen(controller);
	        return controller;
	      },

	      remove: function() {
	        controller.__gui.remove(controller);
	        return controller;
	      }

	    });

	    // All sliders should be accompanied by a box.
	    if (controller instanceof NumberControllerSlider) {

	      var box = new NumberControllerBox(controller.object, controller.property,
	          { min: controller.__min, max: controller.__max, step: controller.__step });

	      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {
	        var pc = controller[method];
	        var pb = box[method];
	        controller[method] = box[method] = function() {
	          var args = Array.prototype.slice.call(arguments);
	          pc.apply(controller, args);
	          return pb.apply(box, args);
	        }
	      });

	      dom.addClass(li, 'has-slider');
	      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);

	    }
	    else if (controller instanceof NumberControllerBox) {

	      var r = function(returned) {

	        // Have we defined both boundaries?
	        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {

	          // Well, then lets just replace this with a slider.
	          controller.remove();
	          return add(
	              gui,
	              controller.object,
	              controller.property,
	              {
	                before: controller.__li.nextElementSibling,
	                factoryArgs: [controller.__min, controller.__max, controller.__step]
	              });

	        }

	        return returned;

	      };

	      controller.min = common.compose(r, controller.min);
	      controller.max = common.compose(r, controller.max);

	    }
	    else if (controller instanceof BooleanController) {

	      dom.bind(li, 'click', function() {
	        dom.fakeEvent(controller.__checkbox, 'click');
	      });

	      dom.bind(controller.__checkbox, 'click', function(e) {
	        e.stopPropagation(); // Prevents double-toggle
	      })

	    }
	    else if (controller instanceof FunctionController) {

	      dom.bind(li, 'click', function() {
	        dom.fakeEvent(controller.__button, 'click');
	      });

	      dom.bind(li, 'mouseover', function() {
	        dom.addClass(controller.__button, 'hover');
	      });

	      dom.bind(li, 'mouseout', function() {
	        dom.removeClass(controller.__button, 'hover');
	      });

	    }
	    else if (controller instanceof ColorController) {

	      dom.addClass(li, 'color');
	      controller.updateDisplay = common.compose(function(r) {
	        li.style.borderLeftColor = controller.__color.toString();
	        return r;
	      }, controller.updateDisplay);

	      controller.updateDisplay();

	    }

	    controller.setValue = common.compose(function(r) {
	      if (gui.getRoot().__preset_select && controller.isModified()) {
	        markPresetModified(gui.getRoot(), true);
	      }
	      return r;
	    }, controller.setValue);

	  }

	  function recallSavedValue(gui, controller) {

	    // Find the topmost GUI, that's where remembered objects live.
	    var root = gui.getRoot();

	    // Does the object we're controlling match anything we've been told to
	    // remember?
	    var matched_index = root.__rememberedObjects.indexOf(controller.object);

	    // Why yes, it does!
	    if (matched_index != -1) {

	      // Let me fetch a map of controllers for thcommon.isObject.
	      var controller_map =
	          root.__rememberedObjectIndecesToControllers[matched_index];

	      // Ohp, I believe this is the first controller we've created for this
	      // object. Lets make the map fresh.
	      if (controller_map === undefined) {
	        controller_map = {};
	        root.__rememberedObjectIndecesToControllers[matched_index] =
	            controller_map;
	      }

	      // Keep track of this controller
	      controller_map[controller.property] = controller;

	      // Okay, now have we saved any values for this controller?
	      if (root.load && root.load.remembered) {

	        var preset_map = root.load.remembered;

	        // Which preset are we trying to load?
	        var preset;

	        if (preset_map[gui.preset]) {

	          preset = preset_map[gui.preset];

	        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {

	          // Uhh, you can have the default instead?
	          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];

	        } else {

	          // Nada.

	          return;

	        }


	        // Did the loaded object remember thcommon.isObject?
	        if (preset[matched_index] &&

	          // Did we remember this particular property?
	            preset[matched_index][controller.property] !== undefined) {

	          // We did remember something for this guy ...
	          var value = preset[matched_index][controller.property];

	          // And that's what it is.
	          controller.initialValue = value;
	          controller.setValue(value);

	        }

	      }

	    }

	  }

	  function getLocalStorageHash(gui, key) {
	    // TODO how does this deal with multiple GUI's?
	    return document.location.href + '.' + key;

	  }

	  function addSaveMenu(gui) {

	    var div = gui.__save_row = document.createElement('li');

	    dom.addClass(gui.domElement, 'has-save');

	    gui.__ul.insertBefore(div, gui.__ul.firstChild);

	    dom.addClass(div, 'save-row');

	    var gears = document.createElement('span');
	    gears.innerHTML = '&nbsp;';
	    dom.addClass(gears, 'button gears');

	    // TODO replace with FunctionController
	    var button = document.createElement('span');
	    button.innerHTML = 'Save';
	    dom.addClass(button, 'button');
	    dom.addClass(button, 'save');

	    var button2 = document.createElement('span');
	    button2.innerHTML = 'New';
	    dom.addClass(button2, 'button');
	    dom.addClass(button2, 'save-as');

	    var button3 = document.createElement('span');
	    button3.innerHTML = 'Revert';
	    dom.addClass(button3, 'button');
	    dom.addClass(button3, 'revert');

	    var select = gui.__preset_select = document.createElement('select');

	    if (gui.load && gui.load.remembered) {

	      common.each(gui.load.remembered, function(value, key) {
	        addPresetOption(gui, key, key == gui.preset);
	      });

	    } else {
	      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
	    }

	    dom.bind(select, 'change', function() {


	      for (var index = 0; index < gui.__preset_select.length; index++) {
	        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
	      }

	      gui.preset = this.value;

	    });

	    div.appendChild(select);
	    div.appendChild(gears);
	    div.appendChild(button);
	    div.appendChild(button2);
	    div.appendChild(button3);

	    if (SUPPORTS_LOCAL_STORAGE) {

	      var saveLocally = document.getElementById('dg-save-locally');
	      var explain = document.getElementById('dg-local-explain');

	      saveLocally.style.display = 'block';

	      var localStorageCheckBox = document.getElementById('dg-local-storage');

	      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
	        localStorageCheckBox.setAttribute('checked', 'checked');
	      }

	      function showHideExplain() {
	        explain.style.display = gui.useLocalStorage ? 'block' : 'none';
	      }

	      showHideExplain();

	      // TODO: Use a boolean controller, fool!
	      dom.bind(localStorageCheckBox, 'change', function() {
	        gui.useLocalStorage = !gui.useLocalStorage;
	        showHideExplain();
	      });

	    }

	    var newConstructorTextArea = document.getElementById('dg-new-constructor');

	    dom.bind(newConstructorTextArea, 'keydown', function(e) {
	      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {
	        SAVE_DIALOGUE.hide();
	      }
	    });

	    dom.bind(gears, 'click', function() {
	      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
	      SAVE_DIALOGUE.show();
	      newConstructorTextArea.focus();
	      newConstructorTextArea.select();
	    });

	    dom.bind(button, 'click', function() {
	      gui.save();
	    });

	    dom.bind(button2, 'click', function() {
	      var presetName = prompt('Enter a new preset name.');
	      if (presetName) gui.saveAs(presetName);
	    });

	    dom.bind(button3, 'click', function() {
	      gui.revert();
	    });

	//    div.appendChild(button2);

	  }

	  function addResizeHandle(gui) {

	    gui.__resize_handle = document.createElement('div');

	    common.extend(gui.__resize_handle.style, {

	      width: '6px',
	      marginLeft: '-3px',
	      height: '200px',
	      cursor: 'ew-resize',
	      position: 'absolute'
	//      border: '1px solid blue'

	    });

	    var pmouseX;

	    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
	    dom.bind(gui.__closeButton, 'mousedown', dragStart);

	    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);

	    function dragStart(e) {

	      e.preventDefault();

	      pmouseX = e.clientX;

	      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
	      dom.bind(window, 'mousemove', drag);
	      dom.bind(window, 'mouseup', dragStop);

	      return false;

	    }

	    function drag(e) {

	      e.preventDefault();

	      gui.width += pmouseX - e.clientX;
	      gui.onResize();
	      pmouseX = e.clientX;

	      return false;

	    }

	    function dragStop() {

	      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
	      dom.unbind(window, 'mousemove', drag);
	      dom.unbind(window, 'mouseup', dragStop);

	    }

	  }

	  function setWidth(gui, w) {
	    gui.domElement.style.width = w + 'px';
	    // Auto placed save-rows are position fixed, so we have to
	    // set the width manually if we want it to bleed to the edge
	    if (gui.__save_row && gui.autoPlace) {
	      gui.__save_row.style.width = w + 'px';
	    }if (gui.__closeButton) {
	      gui.__closeButton.style.width = w + 'px';
	    }
	  }

	  function getCurrentPreset(gui, useInitialValues) {

	    var toReturn = {};

	    // For each object I'm remembering
	    common.each(gui.__rememberedObjects, function(val, index) {

	      var saved_values = {};

	      // The controllers I've made for thcommon.isObject by property
	      var controller_map =
	          gui.__rememberedObjectIndecesToControllers[index];

	      // Remember each value for each property
	      common.each(controller_map, function(controller, property) {
	        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();
	      });

	      // Save the values for thcommon.isObject
	      toReturn[index] = saved_values;

	    });

	    return toReturn;

	  }

	  function addPresetOption(gui, name, setSelected) {
	    var opt = document.createElement('option');
	    opt.innerHTML = name;
	    opt.value = name;
	    gui.__preset_select.appendChild(opt);
	    if (setSelected) {
	      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
	    }
	  }

	  function setPresetSelectIndex(gui) {
	    for (var index = 0; index < gui.__preset_select.length; index++) {
	      if (gui.__preset_select[index].value == gui.preset) {
	        gui.__preset_select.selectedIndex = index;
	      }
	    }
	  }

	  function markPresetModified(gui, modified) {
	    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
	//    console.log('mark', modified, opt);
	    if (modified) {
	      opt.innerHTML = opt.value + "*";
	    } else {
	      opt.innerHTML = opt.value;
	    }
	  }

	  function updateDisplays(controllerArray) {


	    if (controllerArray.length != 0) {

	      requestAnimationFrame(function() {
	        updateDisplays(controllerArray);
	      });

	    }

	    common.each(controllerArray, function(c) {
	      c.updateDisplay();
	    });

	  }

	  return GUI;

	})(dat.utils.css,
	"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",
	".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
	dat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {

	      return function(object, property) {

	        var initialValue = object[property];

	        // Providing options?
	        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {
	          return new OptionController(object, property, arguments[2]);
	        }

	        // Providing a map?

	        if (common.isNumber(initialValue)) {

	          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {

	            // Has min and max.
	            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);

	          } else {

	            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });

	          }

	        }

	        if (common.isString(initialValue)) {
	          return new StringController(object, property);
	        }

	        if (common.isFunction(initialValue)) {
	          return new FunctionController(object, property, '');
	        }

	        if (common.isBoolean(initialValue)) {
	          return new BooleanController(object, property);
	        }

	      }

	    })(dat.controllers.OptionController,
	dat.controllers.NumberControllerBox,
	dat.controllers.NumberControllerSlider,
	dat.controllers.StringController = (function (Controller, dom, common) {

	  /**
	   * @class Provides a text input to alter the string property of an object.
	   *
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   *
	   * @member dat.controllers
	   */
	  var StringController = function(object, property) {

	    StringController.superclass.call(this, object, property);

	    var _this = this;

	    this.__input = document.createElement('input');
	    this.__input.setAttribute('type', 'text');

	    dom.bind(this.__input, 'keyup', onChange);
	    dom.bind(this.__input, 'change', onChange);
	    dom.bind(this.__input, 'blur', onBlur);
	    dom.bind(this.__input, 'keydown', function(e) {
	      if (e.keyCode === 13) {
	        this.blur();
	      }
	    });
	    

	    function onChange() {
	      _this.setValue(_this.__input.value);
	    }

	    function onBlur() {
	      if (_this.__onFinishChange) {
	        _this.__onFinishChange.call(_this, _this.getValue());
	      }
	    }

	    this.updateDisplay();

	    this.domElement.appendChild(this.__input);

	  };

	  StringController.superclass = Controller;

	  common.extend(

	      StringController.prototype,
	      Controller.prototype,

	      {

	        updateDisplay: function() {
	          // Stops the caret from moving on account of:
	          // keyup -> setValue -> updateDisplay
	          if (!dom.isActive(this.__input)) {
	            this.__input.value = this.getValue();
	          }
	          return StringController.superclass.prototype.updateDisplay.call(this);
	        }

	      }

	  );

	  return StringController;

	})(dat.controllers.Controller,
	dat.dom.dom,
	dat.utils.common),
	dat.controllers.FunctionController,
	dat.controllers.BooleanController,
	dat.utils.common),
	dat.controllers.Controller,
	dat.controllers.BooleanController,
	dat.controllers.FunctionController,
	dat.controllers.NumberControllerBox,
	dat.controllers.NumberControllerSlider,
	dat.controllers.OptionController,
	dat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {

	  var ColorController = function(object, property) {

	    ColorController.superclass.call(this, object, property);

	    this.__color = new Color(this.getValue());
	    this.__temp = new Color(0);

	    var _this = this;

	    this.domElement = document.createElement('div');

	    dom.makeSelectable(this.domElement, false);

	    this.__selector = document.createElement('div');
	    this.__selector.className = 'selector';

	    this.__saturation_field = document.createElement('div');
	    this.__saturation_field.className = 'saturation-field';

	    this.__field_knob = document.createElement('div');
	    this.__field_knob.className = 'field-knob';
	    this.__field_knob_border = '2px solid ';

	    this.__hue_knob = document.createElement('div');
	    this.__hue_knob.className = 'hue-knob';

	    this.__hue_field = document.createElement('div');
	    this.__hue_field.className = 'hue-field';

	    this.__input = document.createElement('input');
	    this.__input.type = 'text';
	    this.__input_textShadow = '0 1px 1px ';

	    dom.bind(this.__input, 'keydown', function(e) {
	      if (e.keyCode === 13) { // on enter
	        onBlur.call(this);
	      }
	    });

	    dom.bind(this.__input, 'blur', onBlur);

	    dom.bind(this.__selector, 'mousedown', function(e) {

	      dom
	        .addClass(this, 'drag')
	        .bind(window, 'mouseup', function(e) {
	          dom.removeClass(_this.__selector, 'drag');
	        });

	    });

	    var value_field = document.createElement('div');

	    common.extend(this.__selector.style, {
	      width: '122px',
	      height: '102px',
	      padding: '3px',
	      backgroundColor: '#222',
	      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
	    });

	    common.extend(this.__field_knob.style, {
	      position: 'absolute',
	      width: '12px',
	      height: '12px',
	      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),
	      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
	      borderRadius: '12px',
	      zIndex: 1
	    });
	    
	    common.extend(this.__hue_knob.style, {
	      position: 'absolute',
	      width: '15px',
	      height: '2px',
	      borderRight: '4px solid #fff',
	      zIndex: 1
	    });

	    common.extend(this.__saturation_field.style, {
	      width: '100px',
	      height: '100px',
	      border: '1px solid #555',
	      marginRight: '3px',
	      display: 'inline-block',
	      cursor: 'pointer'
	    });

	    common.extend(value_field.style, {
	      width: '100%',
	      height: '100%',
	      background: 'none'
	    });
	    
	    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');

	    common.extend(this.__hue_field.style, {
	      width: '15px',
	      height: '100px',
	      display: 'inline-block',
	      border: '1px solid #555',
	      cursor: 'ns-resize'
	    });

	    hueGradient(this.__hue_field);

	    common.extend(this.__input.style, {
	      outline: 'none',
	//      width: '120px',
	      textAlign: 'center',
	//      padding: '4px',
	//      marginBottom: '6px',
	      color: '#fff',
	      border: 0,
	      fontWeight: 'bold',
	      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'
	    });

	    dom.bind(this.__saturation_field, 'mousedown', fieldDown);
	    dom.bind(this.__field_knob, 'mousedown', fieldDown);

	    dom.bind(this.__hue_field, 'mousedown', function(e) {
	      setH(e);
	      dom.bind(window, 'mousemove', setH);
	      dom.bind(window, 'mouseup', unbindH);
	    });

	    function fieldDown(e) {
	      setSV(e);
	      // document.body.style.cursor = 'none';
	      dom.bind(window, 'mousemove', setSV);
	      dom.bind(window, 'mouseup', unbindSV);
	    }

	    function unbindSV() {
	      dom.unbind(window, 'mousemove', setSV);
	      dom.unbind(window, 'mouseup', unbindSV);
	      // document.body.style.cursor = 'default';
	    }

	    function onBlur() {
	      var i = interpret(this.value);
	      if (i !== false) {
	        _this.__color.__state = i;
	        _this.setValue(_this.__color.toOriginal());
	      } else {
	        this.value = _this.__color.toString();
	      }
	    }

	    function unbindH() {
	      dom.unbind(window, 'mousemove', setH);
	      dom.unbind(window, 'mouseup', unbindH);
	    }

	    this.__saturation_field.appendChild(value_field);
	    this.__selector.appendChild(this.__field_knob);
	    this.__selector.appendChild(this.__saturation_field);
	    this.__selector.appendChild(this.__hue_field);
	    this.__hue_field.appendChild(this.__hue_knob);

	    this.domElement.appendChild(this.__input);
	    this.domElement.appendChild(this.__selector);

	    this.updateDisplay();

	    function setSV(e) {

	      e.preventDefault();

	      var w = dom.getWidth(_this.__saturation_field);
	      var o = dom.getOffset(_this.__saturation_field);
	      var s = (e.clientX - o.left + document.body.scrollLeft) / w;
	      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;

	      if (v > 1) v = 1;
	      else if (v < 0) v = 0;

	      if (s > 1) s = 1;
	      else if (s < 0) s = 0;

	      _this.__color.v = v;
	      _this.__color.s = s;

	      _this.setValue(_this.__color.toOriginal());


	      return false;

	    }

	    function setH(e) {

	      e.preventDefault();

	      var s = dom.getHeight(_this.__hue_field);
	      var o = dom.getOffset(_this.__hue_field);
	      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;

	      if (h > 1) h = 1;
	      else if (h < 0) h = 0;

	      _this.__color.h = h * 360;

	      _this.setValue(_this.__color.toOriginal());

	      return false;

	    }

	  };

	  ColorController.superclass = Controller;

	  common.extend(

	      ColorController.prototype,
	      Controller.prototype,

	      {

	        updateDisplay: function() {

	          var i = interpret(this.getValue());

	          if (i !== false) {

	            var mismatch = false;

	            // Check for mismatch on the interpreted value.

	            common.each(Color.COMPONENTS, function(component) {
	              if (!common.isUndefined(i[component]) &&
	                  !common.isUndefined(this.__color.__state[component]) &&
	                  i[component] !== this.__color.__state[component]) {
	                mismatch = true;
	                return {}; // break
	              }
	            }, this);

	            // If nothing diverges, we keep our previous values
	            // for statefulness, otherwise we recalculate fresh
	            if (mismatch) {
	              common.extend(this.__color.__state, i);
	            }

	          }

	          common.extend(this.__temp.__state, this.__color.__state);

	          this.__temp.a = 1;

	          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;
	          var _flip = 255 - flip;

	          common.extend(this.__field_knob.style, {
	            marginLeft: 100 * this.__color.s - 7 + 'px',
	            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
	            backgroundColor: this.__temp.toString(),
	            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'
	          });

	          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'

	          this.__temp.s = 1;
	          this.__temp.v = 1;

	          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());

	          common.extend(this.__input.style, {
	            backgroundColor: this.__input.value = this.__color.toString(),
	            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',
	            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'
	          });

	        }

	      }

	  );
	  
	  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];
	  
	  function linearGradient(elem, x, a, b) {
	    elem.style.background = '';
	    common.each(vendors, function(vendor) {
	      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';
	    });
	  }
	  
	  function hueGradient(elem) {
	    elem.style.background = '';
	    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
	    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
	    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
	    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
	    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
	  }


	  return ColorController;

	})(dat.controllers.Controller,
	dat.dom.dom,
	dat.color.Color = (function (interpret, math, toString, common) {

	  var Color = function() {

	    this.__state = interpret.apply(this, arguments);

	    if (this.__state === false) {
	      throw 'Failed to interpret color arguments';
	    }

	    this.__state.a = this.__state.a || 1;


	  };

	  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

	  common.extend(Color.prototype, {

	    toString: function() {
	      return toString(this);
	    },

	    toOriginal: function() {
	      return this.__state.conversion.write(this);
	    }

	  });

	  defineRGBComponent(Color.prototype, 'r', 2);
	  defineRGBComponent(Color.prototype, 'g', 1);
	  defineRGBComponent(Color.prototype, 'b', 0);

	  defineHSVComponent(Color.prototype, 'h');
	  defineHSVComponent(Color.prototype, 's');
	  defineHSVComponent(Color.prototype, 'v');

	  Object.defineProperty(Color.prototype, 'a', {

	    get: function() {
	      return this.__state.a;
	    },

	    set: function(v) {
	      this.__state.a = v;
	    }

	  });

	  Object.defineProperty(Color.prototype, 'hex', {

	    get: function() {

	      if (!this.__state.space !== 'HEX') {
	        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
	      }

	      return this.__state.hex;

	    },

	    set: function(v) {

	      this.__state.space = 'HEX';
	      this.__state.hex = v;

	    }

	  });

	  function defineRGBComponent(target, component, componentHexIndex) {

	    Object.defineProperty(target, component, {

	      get: function() {

	        if (this.__state.space === 'RGB') {
	          return this.__state[component];
	        }

	        recalculateRGB(this, component, componentHexIndex);

	        return this.__state[component];

	      },

	      set: function(v) {

	        if (this.__state.space !== 'RGB') {
	          recalculateRGB(this, component, componentHexIndex);
	          this.__state.space = 'RGB';
	        }

	        this.__state[component] = v;

	      }

	    });

	  }

	  function defineHSVComponent(target, component) {

	    Object.defineProperty(target, component, {

	      get: function() {

	        if (this.__state.space === 'HSV')
	          return this.__state[component];

	        recalculateHSV(this);

	        return this.__state[component];

	      },

	      set: function(v) {

	        if (this.__state.space !== 'HSV') {
	          recalculateHSV(this);
	          this.__state.space = 'HSV';
	        }

	        this.__state[component] = v;

	      }

	    });

	  }

	  function recalculateRGB(color, component, componentHexIndex) {

	    if (color.__state.space === 'HEX') {

	      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

	    } else if (color.__state.space === 'HSV') {

	      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

	    } else {

	      throw 'Corrupted color state';

	    }

	  }

	  function recalculateHSV(color) {

	    var result = math.rgb_to_hsv(color.r, color.g, color.b);

	    common.extend(color.__state,
	        {
	          s: result.s,
	          v: result.v
	        }
	    );

	    if (!common.isNaN(result.h)) {
	      color.__state.h = result.h;
	    } else if (common.isUndefined(color.__state.h)) {
	      color.__state.h = 0;
	    }

	  }

	  return Color;

	})(dat.color.interpret,
	dat.color.math = (function () {

	  var tmpComponent;

	  return {

	    hsv_to_rgb: function(h, s, v) {

	      var hi = Math.floor(h / 60) % 6;

	      var f = h / 60 - Math.floor(h / 60);
	      var p = v * (1.0 - s);
	      var q = v * (1.0 - (f * s));
	      var t = v * (1.0 - ((1.0 - f) * s));
	      var c = [
	        [v, t, p],
	        [q, v, p],
	        [p, v, t],
	        [p, q, v],
	        [t, p, v],
	        [v, p, q]
	      ][hi];

	      return {
	        r: c[0] * 255,
	        g: c[1] * 255,
	        b: c[2] * 255
	      };

	    },

	    rgb_to_hsv: function(r, g, b) {

	      var min = Math.min(r, g, b),
	          max = Math.max(r, g, b),
	          delta = max - min,
	          h, s;

	      if (max != 0) {
	        s = delta / max;
	      } else {
	        return {
	          h: NaN,
	          s: 0,
	          v: 0
	        };
	      }

	      if (r == max) {
	        h = (g - b) / delta;
	      } else if (g == max) {
	        h = 2 + (b - r) / delta;
	      } else {
	        h = 4 + (r - g) / delta;
	      }
	      h /= 6;
	      if (h < 0) {
	        h += 1;
	      }

	      return {
	        h: h * 360,
	        s: s,
	        v: max / 255
	      };
	    },

	    rgb_to_hex: function(r, g, b) {
	      var hex = this.hex_with_component(0, 2, r);
	      hex = this.hex_with_component(hex, 1, g);
	      hex = this.hex_with_component(hex, 0, b);
	      return hex;
	    },

	    component_from_hex: function(hex, componentIndex) {
	      return (hex >> (componentIndex * 8)) & 0xFF;
	    },

	    hex_with_component: function(hex, componentIndex, value) {
	      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
	    }

	  }

	})(),
	dat.color.toString,
	dat.utils.common),
	dat.color.interpret,
	dat.utils.common),
	dat.utils.requestAnimationFrame = (function () {

	  /**
	   * requirejs version of Paul Irish's RequestAnimationFrame
	   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	   */

	  return window.webkitRequestAnimationFrame ||
	      window.mozRequestAnimationFrame ||
	      window.oRequestAnimationFrame ||
	      window.msRequestAnimationFrame ||
	      function(callback, element) {

	        window.setTimeout(callback, 1000 / 60);

	      };
	})(),
	dat.dom.CenteredDiv = (function (dom, common) {


	  var CenteredDiv = function() {

	    this.backgroundElement = document.createElement('div');
	    common.extend(this.backgroundElement.style, {
	      backgroundColor: 'rgba(0,0,0,0.8)',
	      top: 0,
	      left: 0,
	      display: 'none',
	      zIndex: '1000',
	      opacity: 0,
	      WebkitTransition: 'opacity 0.2s linear'
	    });

	    dom.makeFullscreen(this.backgroundElement);
	    this.backgroundElement.style.position = 'fixed';

	    this.domElement = document.createElement('div');
	    common.extend(this.domElement.style, {
	      position: 'fixed',
	      display: 'none',
	      zIndex: '1001',
	      opacity: 0,
	      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'
	    });


	    document.body.appendChild(this.backgroundElement);
	    document.body.appendChild(this.domElement);

	    var _this = this;
	    dom.bind(this.backgroundElement, 'click', function() {
	      _this.hide();
	    });


	  };

	  CenteredDiv.prototype.show = function() {

	    var _this = this;
	    


	    this.backgroundElement.style.display = 'block';

	    this.domElement.style.display = 'block';
	    this.domElement.style.opacity = 0;
	//    this.domElement.style.top = '52%';
	    this.domElement.style.webkitTransform = 'scale(1.1)';

	    this.layout();

	    common.defer(function() {
	      _this.backgroundElement.style.opacity = 1;
	      _this.domElement.style.opacity = 1;
	      _this.domElement.style.webkitTransform = 'scale(1)';
	    });

	  };

	  CenteredDiv.prototype.hide = function() {

	    var _this = this;

	    var hide = function() {

	      _this.domElement.style.display = 'none';
	      _this.backgroundElement.style.display = 'none';

	      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
	      dom.unbind(_this.domElement, 'transitionend', hide);
	      dom.unbind(_this.domElement, 'oTransitionEnd', hide);

	    };

	    dom.bind(this.domElement, 'webkitTransitionEnd', hide);
	    dom.bind(this.domElement, 'transitionend', hide);
	    dom.bind(this.domElement, 'oTransitionEnd', hide);

	    this.backgroundElement.style.opacity = 0;
	//    this.domElement.style.top = '48%';
	    this.domElement.style.opacity = 0;
	    this.domElement.style.webkitTransform = 'scale(1.1)';

	  };

	  CenteredDiv.prototype.layout = function() {
	    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';
	    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';
	  };
	  
	  function lockScroll(e) {
	    console.log(e);
	  }

	  return CenteredDiv;

	})(dat.dom.dom,
	dat.utils.common),
	dat.dom.dom,
	dat.utils.common);

/***/ },
/* 6 */
/***/ function(module, exports) {

	/**
	 * dat-gui JavaScript Controller Library
	 * http://code.google.com/p/dat-gui
	 *
	 * Copyright 2011 Data Arts Team, Google Creative Lab
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 */

	/** @namespace */
	var dat = module.exports = dat || {};

	/** @namespace */
	dat.color = dat.color || {};

	/** @namespace */
	dat.utils = dat.utils || {};

	dat.utils.common = (function () {
	  
	  var ARR_EACH = Array.prototype.forEach;
	  var ARR_SLICE = Array.prototype.slice;

	  /**
	   * Band-aid methods for things that should be a lot easier in JavaScript.
	   * Implementation and structure inspired by underscore.js
	   * http://documentcloud.github.com/underscore/
	   */

	  return { 
	    
	    BREAK: {},
	  
	    extend: function(target) {
	      
	      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
	        
	        for (var key in obj)
	          if (!this.isUndefined(obj[key])) 
	            target[key] = obj[key];
	        
	      }, this);
	      
	      return target;
	      
	    },
	    
	    defaults: function(target) {
	      
	      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
	        
	        for (var key in obj)
	          if (this.isUndefined(target[key])) 
	            target[key] = obj[key];
	        
	      }, this);
	      
	      return target;
	    
	    },
	    
	    compose: function() {
	      var toCall = ARR_SLICE.call(arguments);
	            return function() {
	              var args = ARR_SLICE.call(arguments);
	              for (var i = toCall.length -1; i >= 0; i--) {
	                args = [toCall[i].apply(this, args)];
	              }
	              return args[0];
	            }
	    },
	    
	    each: function(obj, itr, scope) {

	      
	      if (ARR_EACH && obj.forEach === ARR_EACH) { 
	        
	        obj.forEach(itr, scope);
	        
	      } else if (obj.length === obj.length + 0) { // Is number but not NaN
	        
	        for (var key = 0, l = obj.length; key < l; key++)
	          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
	            return;
	            
	      } else {

	        for (var key in obj) 
	          if (itr.call(scope, obj[key], key) === this.BREAK)
	            return;
	            
	      }
	            
	    },
	    
	    defer: function(fnc) {
	      setTimeout(fnc, 0);
	    },
	    
	    toArray: function(obj) {
	      if (obj.toArray) return obj.toArray();
	      return ARR_SLICE.call(obj);
	    },

	    isUndefined: function(obj) {
	      return obj === undefined;
	    },
	    
	    isNull: function(obj) {
	      return obj === null;
	    },
	    
	    isNaN: function(obj) {
	      return obj !== obj;
	    },
	    
	    isArray: Array.isArray || function(obj) {
	      return obj.constructor === Array;
	    },
	    
	    isObject: function(obj) {
	      return obj === Object(obj);
	    },
	    
	    isNumber: function(obj) {
	      return obj === obj+0;
	    },
	    
	    isString: function(obj) {
	      return obj === obj+'';
	    },
	    
	    isBoolean: function(obj) {
	      return obj === false || obj === true;
	    },
	    
	    isFunction: function(obj) {
	      return Object.prototype.toString.call(obj) === '[object Function]';
	    }
	  
	  };
	    
	})();


	dat.color.toString = (function (common) {

	  return function(color) {

	    if (color.a == 1 || common.isUndefined(color.a)) {

	      var s = color.hex.toString(16);
	      while (s.length < 6) {
	        s = '0' + s;
	      }

	      return '#' + s;

	    } else {

	      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

	    }

	  }

	})(dat.utils.common);


	dat.Color = dat.color.Color = (function (interpret, math, toString, common) {

	  var Color = function() {

	    this.__state = interpret.apply(this, arguments);

	    if (this.__state === false) {
	      throw 'Failed to interpret color arguments';
	    }

	    this.__state.a = this.__state.a || 1;


	  };

	  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

	  common.extend(Color.prototype, {

	    toString: function() {
	      return toString(this);
	    },

	    toOriginal: function() {
	      return this.__state.conversion.write(this);
	    }

	  });

	  defineRGBComponent(Color.prototype, 'r', 2);
	  defineRGBComponent(Color.prototype, 'g', 1);
	  defineRGBComponent(Color.prototype, 'b', 0);

	  defineHSVComponent(Color.prototype, 'h');
	  defineHSVComponent(Color.prototype, 's');
	  defineHSVComponent(Color.prototype, 'v');

	  Object.defineProperty(Color.prototype, 'a', {

	    get: function() {
	      return this.__state.a;
	    },

	    set: function(v) {
	      this.__state.a = v;
	    }

	  });

	  Object.defineProperty(Color.prototype, 'hex', {

	    get: function() {

	      if (!this.__state.space !== 'HEX') {
	        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
	      }

	      return this.__state.hex;

	    },

	    set: function(v) {

	      this.__state.space = 'HEX';
	      this.__state.hex = v;

	    }

	  });

	  function defineRGBComponent(target, component, componentHexIndex) {

	    Object.defineProperty(target, component, {

	      get: function() {

	        if (this.__state.space === 'RGB') {
	          return this.__state[component];
	        }

	        recalculateRGB(this, component, componentHexIndex);

	        return this.__state[component];

	      },

	      set: function(v) {

	        if (this.__state.space !== 'RGB') {
	          recalculateRGB(this, component, componentHexIndex);
	          this.__state.space = 'RGB';
	        }

	        this.__state[component] = v;

	      }

	    });

	  }

	  function defineHSVComponent(target, component) {

	    Object.defineProperty(target, component, {

	      get: function() {

	        if (this.__state.space === 'HSV')
	          return this.__state[component];

	        recalculateHSV(this);

	        return this.__state[component];

	      },

	      set: function(v) {

	        if (this.__state.space !== 'HSV') {
	          recalculateHSV(this);
	          this.__state.space = 'HSV';
	        }

	        this.__state[component] = v;

	      }

	    });

	  }

	  function recalculateRGB(color, component, componentHexIndex) {

	    if (color.__state.space === 'HEX') {

	      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

	    } else if (color.__state.space === 'HSV') {

	      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

	    } else {

	      throw 'Corrupted color state';

	    }

	  }

	  function recalculateHSV(color) {

	    var result = math.rgb_to_hsv(color.r, color.g, color.b);

	    common.extend(color.__state,
	        {
	          s: result.s,
	          v: result.v
	        }
	    );

	    if (!common.isNaN(result.h)) {
	      color.__state.h = result.h;
	    } else if (common.isUndefined(color.__state.h)) {
	      color.__state.h = 0;
	    }

	  }

	  return Color;

	})(dat.color.interpret = (function (toString, common) {

	  var result, toReturn;

	  var interpret = function() {

	    toReturn = false;

	    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

	    common.each(INTERPRETATIONS, function(family) {

	      if (family.litmus(original)) {

	        common.each(family.conversions, function(conversion, conversionName) {

	          result = conversion.read(original);

	          if (toReturn === false && result !== false) {
	            toReturn = result;
	            result.conversionName = conversionName;
	            result.conversion = conversion;
	            return common.BREAK;

	          }

	        });

	        return common.BREAK;

	      }

	    });

	    return toReturn;

	  };

	  var INTERPRETATIONS = [

	    // Strings
	    {

	      litmus: common.isString,

	      conversions: {

	        THREE_CHAR_HEX: {

	          read: function(original) {

	            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
	            if (test === null) return false;

	            return {
	              space: 'HEX',
	              hex: parseInt(
	                  '0x' +
	                      test[1].toString() + test[1].toString() +
	                      test[2].toString() + test[2].toString() +
	                      test[3].toString() + test[3].toString())
	            };

	          },

	          write: toString

	        },

	        SIX_CHAR_HEX: {

	          read: function(original) {

	            var test = original.match(/^#([A-F0-9]{6})$/i);
	            if (test === null) return false;

	            return {
	              space: 'HEX',
	              hex: parseInt('0x' + test[1].toString())
	            };

	          },

	          write: toString

	        },

	        CSS_RGB: {

	          read: function(original) {

	            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
	            if (test === null) return false;

	            return {
	              space: 'RGB',
	              r: parseFloat(test[1]),
	              g: parseFloat(test[2]),
	              b: parseFloat(test[3])
	            };

	          },

	          write: toString

	        },

	        CSS_RGBA: {

	          read: function(original) {

	            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
	            if (test === null) return false;

	            return {
	              space: 'RGB',
	              r: parseFloat(test[1]),
	              g: parseFloat(test[2]),
	              b: parseFloat(test[3]),
	              a: parseFloat(test[4])
	            };

	          },

	          write: toString

	        }

	      }

	    },

	    // Numbers
	    {

	      litmus: common.isNumber,

	      conversions: {

	        HEX: {
	          read: function(original) {
	            return {
	              space: 'HEX',
	              hex: original,
	              conversionName: 'HEX'
	            }
	          },

	          write: function(color) {
	            return color.hex;
	          }
	        }

	      }

	    },

	    // Arrays
	    {

	      litmus: common.isArray,

	      conversions: {

	        RGB_ARRAY: {
	          read: function(original) {
	            if (original.length != 3) return false;
	            return {
	              space: 'RGB',
	              r: original[0],
	              g: original[1],
	              b: original[2]
	            };
	          },

	          write: function(color) {
	            return [color.r, color.g, color.b];
	          }

	        },

	        RGBA_ARRAY: {
	          read: function(original) {
	            if (original.length != 4) return false;
	            return {
	              space: 'RGB',
	              r: original[0],
	              g: original[1],
	              b: original[2],
	              a: original[3]
	            };
	          },

	          write: function(color) {
	            return [color.r, color.g, color.b, color.a];
	          }

	        }

	      }

	    },

	    // Objects
	    {

	      litmus: common.isObject,

	      conversions: {

	        RGBA_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.r) &&
	                common.isNumber(original.g) &&
	                common.isNumber(original.b) &&
	                common.isNumber(original.a)) {
	              return {
	                space: 'RGB',
	                r: original.r,
	                g: original.g,
	                b: original.b,
	                a: original.a
	              }
	            }
	            return false;
	          },

	          write: function(color) {
	            return {
	              r: color.r,
	              g: color.g,
	              b: color.b,
	              a: color.a
	            }
	          }
	        },

	        RGB_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.r) &&
	                common.isNumber(original.g) &&
	                common.isNumber(original.b)) {
	              return {
	                space: 'RGB',
	                r: original.r,
	                g: original.g,
	                b: original.b
	              }
	            }
	            return false;
	          },

	          write: function(color) {
	            return {
	              r: color.r,
	              g: color.g,
	              b: color.b
	            }
	          }
	        },

	        HSVA_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.h) &&
	                common.isNumber(original.s) &&
	                common.isNumber(original.v) &&
	                common.isNumber(original.a)) {
	              return {
	                space: 'HSV',
	                h: original.h,
	                s: original.s,
	                v: original.v,
	                a: original.a
	              }
	            }
	            return false;
	          },

	          write: function(color) {
	            return {
	              h: color.h,
	              s: color.s,
	              v: color.v,
	              a: color.a
	            }
	          }
	        },

	        HSV_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.h) &&
	                common.isNumber(original.s) &&
	                common.isNumber(original.v)) {
	              return {
	                space: 'HSV',
	                h: original.h,
	                s: original.s,
	                v: original.v
	              }
	            }
	            return false;
	          },

	          write: function(color) {
	            return {
	              h: color.h,
	              s: color.s,
	              v: color.v
	            }
	          }

	        }

	      }

	    }


	  ];

	  return interpret;


	})(dat.color.toString,
	dat.utils.common),
	dat.color.math = (function () {

	  var tmpComponent;

	  return {

	    hsv_to_rgb: function(h, s, v) {

	      var hi = Math.floor(h / 60) % 6;

	      var f = h / 60 - Math.floor(h / 60);
	      var p = v * (1.0 - s);
	      var q = v * (1.0 - (f * s));
	      var t = v * (1.0 - ((1.0 - f) * s));
	      var c = [
	        [v, t, p],
	        [q, v, p],
	        [p, v, t],
	        [p, q, v],
	        [t, p, v],
	        [v, p, q]
	      ][hi];

	      return {
	        r: c[0] * 255,
	        g: c[1] * 255,
	        b: c[2] * 255
	      };

	    },

	    rgb_to_hsv: function(r, g, b) {

	      var min = Math.min(r, g, b),
	          max = Math.max(r, g, b),
	          delta = max - min,
	          h, s;

	      if (max != 0) {
	        s = delta / max;
	      } else {
	        return {
	          h: NaN,
	          s: 0,
	          v: 0
	        };
	      }

	      if (r == max) {
	        h = (g - b) / delta;
	      } else if (g == max) {
	        h = 2 + (b - r) / delta;
	      } else {
	        h = 4 + (r - g) / delta;
	      }
	      h /= 6;
	      if (h < 0) {
	        h += 1;
	      }

	      return {
	        h: h * 360,
	        s: s,
	        v: max / 255
	      };
	    },

	    rgb_to_hex: function(r, g, b) {
	      var hex = this.hex_with_component(0, 2, r);
	      hex = this.hex_with_component(hex, 1, g);
	      hex = this.hex_with_component(hex, 0, b);
	      return hex;
	    },

	    component_from_hex: function(hex, componentIndex) {
	      return (hex >> (componentIndex * 8)) & 0xFF;
	    },

	    hex_with_component: function(hex, componentIndex, value) {
	      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
	    }

	  }

	})(),
	dat.color.toString,
	dat.utils.common);

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Tween.js - Licensed under the MIT license
	 * https://github.com/tweenjs/tween.js
	 * ----------------------------------------------
	 *
	 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
	 * Thank you all, you're awesome!
	 */

	// Include a performance.now polyfill
	(function () {

		if ('performance' in window === false) {
			window.performance = {};
		}

		// IE 8
		Date.now = (Date.now || function () {
			return new Date().getTime();
		});

		if ('now' in window.performance === false) {
			var offset = window.performance.timing && window.performance.timing.navigationStart ? window.performance.timing.navigationStart
			                                                                                    : Date.now();

			window.performance.now = function () {
				return Date.now() - offset;
			};
		}

	})();

	var TWEEN = TWEEN || (function () {

		var _tweens = [];

		return {

			getAll: function () {

				return _tweens;

			},

			removeAll: function () {

				_tweens = [];

			},

			add: function (tween) {

				_tweens.push(tween);

			},

			remove: function (tween) {

				var i = _tweens.indexOf(tween);

				if (i !== -1) {
					_tweens.splice(i, 1);
				}

			},

			update: function (time) {

				if (_tweens.length === 0) {
					return false;
				}

				var i = 0;

				time = time !== undefined ? time : window.performance.now();

				while (i < _tweens.length) {

					if (_tweens[i].update(time)) {
						i++;
					} else {
						_tweens.splice(i, 1);
					}

				}

				return true;

			}
		};

	})();

	TWEEN.Tween = function (object) {

		var _object = object;
		var _valuesStart = {};
		var _valuesEnd = {};
		var _valuesStartRepeat = {};
		var _duration = 1000;
		var _repeat = 0;
		var _yoyo = false;
		var _isPlaying = false;
		var _reversed = false;
		var _delayTime = 0;
		var _startTime = null;
		var _easingFunction = TWEEN.Easing.Linear.None;
		var _interpolationFunction = TWEEN.Interpolation.Linear;
		var _chainedTweens = [];
		var _onStartCallback = null;
		var _onStartCallbackFired = false;
		var _onUpdateCallback = null;
		var _onCompleteCallback = null;
		var _onStopCallback = null;

		// Set all starting values present on the target object
		for (var field in object) {
			_valuesStart[field] = parseFloat(object[field], 10);
		}

		this.to = function (properties, duration) {

			if (duration !== undefined) {
				_duration = duration;
			}

			_valuesEnd = properties;

			return this;

		};

		this.start = function (time) {

			TWEEN.add(this);

			_isPlaying = true;

			_onStartCallbackFired = false;

			_startTime = time !== undefined ? time : window.performance.now();
			_startTime += _delayTime;

			for (var property in _valuesEnd) {

				// Check if an Array was provided as property value
				if (_valuesEnd[property] instanceof Array) {

					if (_valuesEnd[property].length === 0) {
						continue;
					}

					// Create a local copy of the Array with the start value at the front
					_valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);

				}

				// If `to()` specifies a property that doesn't exist in the source object,
				// we should not set that property in the object
				if (_valuesStart[property] === undefined) {
					continue;
				}

				_valuesStart[property] = _object[property];

				if ((_valuesStart[property] instanceof Array) === false) {
					_valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
				}

				_valuesStartRepeat[property] = _valuesStart[property] || 0;

			}

			return this;

		};

		this.stop = function () {

			if (!_isPlaying) {
				return this;
			}

			TWEEN.remove(this);
			_isPlaying = false;

			if (_onStopCallback !== null) {
				_onStopCallback.call(_object);
			}

			this.stopChainedTweens();
			return this;

		};

		this.stopChainedTweens = function () {

			for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
				_chainedTweens[i].stop();
			}

		};

		this.delay = function (amount) {

			_delayTime = amount;
			return this;

		};

		this.repeat = function (times) {

			_repeat = times;
			return this;

		};

		this.yoyo = function (yoyo) {

			_yoyo = yoyo;
			return this;

		};


		this.easing = function (easing) {

			_easingFunction = easing;
			return this;

		};

		this.interpolation = function (interpolation) {

			_interpolationFunction = interpolation;
			return this;

		};

		this.chain = function () {

			_chainedTweens = arguments;
			return this;

		};

		this.onStart = function (callback) {

			_onStartCallback = callback;
			return this;

		};

		this.onUpdate = function (callback) {

			_onUpdateCallback = callback;
			return this;

		};

		this.onComplete = function (callback) {

			_onCompleteCallback = callback;
			return this;

		};

		this.onStop = function (callback) {

			_onStopCallback = callback;
			return this;

		};

		this.update = function (time) {

			var property;
			var elapsed;
			var value;

			if (time < _startTime) {
				return true;
			}

			if (_onStartCallbackFired === false) {

				if (_onStartCallback !== null) {
					_onStartCallback.call(_object);
				}

				_onStartCallbackFired = true;

			}

			elapsed = (time - _startTime) / _duration;
			elapsed = elapsed > 1 ? 1 : elapsed;

			value = _easingFunction(elapsed);

			for (property in _valuesEnd) {

				// Don't update properties that do not exist in the source object
				if (_valuesStart[property] === undefined) {
					continue;
				}

				var start = _valuesStart[property] || 0;
				var end = _valuesEnd[property];

				if (end instanceof Array) {

					_object[property] = _interpolationFunction(end, value);

				} else {

					// Parses relative end values with start as base (e.g.: +10, -3)
					if (typeof (end) === 'string') {

						if (end.startsWith('+') || end.startsWith('-')) {
							end = start + parseFloat(end, 10);
						} else {
							end = parseFloat(end, 10);
						}
					}

					// Protect against non numeric properties.
					if (typeof (end) === 'number') {
						_object[property] = start + (end - start) * value;
					}

				}

			}

			if (_onUpdateCallback !== null) {
				_onUpdateCallback.call(_object, value);
			}

			if (elapsed === 1) {

				if (_repeat > 0) {

					if (isFinite(_repeat)) {
						_repeat--;
					}

					// Reassign starting values, restart by making startTime = now
					for (property in _valuesStartRepeat) {

						if (typeof (_valuesEnd[property]) === 'string') {
							_valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property], 10);
						}

						if (_yoyo) {
							var tmp = _valuesStartRepeat[property];

							_valuesStartRepeat[property] = _valuesEnd[property];
							_valuesEnd[property] = tmp;
						}

						_valuesStart[property] = _valuesStartRepeat[property];

					}

					if (_yoyo) {
						_reversed = !_reversed;
					}

					_startTime = time + _delayTime;

					return true;

				} else {

					if (_onCompleteCallback !== null) {
						_onCompleteCallback.call(_object);
					}

					for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
						// Make the chained tweens start exactly at the time they should,
						// even if the `update()` method was called way past the duration of the tween
						_chainedTweens[i].start(_startTime + _duration);
					}

					return false;

				}

			}

			return true;

		};

	};


	TWEEN.Easing = {

		Linear: {

			None: function (k) {

				return k;

			}

		},

		Quadratic: {

			In: function (k) {

				return k * k;

			},

			Out: function (k) {

				return k * (2 - k);

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k;
				}

				return - 0.5 * (--k * (k - 2) - 1);

			}

		},

		Cubic: {

			In: function (k) {

				return k * k * k;

			},

			Out: function (k) {

				return --k * k * k + 1;

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k * k;
				}

				return 0.5 * ((k -= 2) * k * k + 2);

			}

		},

		Quartic: {

			In: function (k) {

				return k * k * k * k;

			},

			Out: function (k) {

				return 1 - (--k * k * k * k);

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k * k * k;
				}

				return - 0.5 * ((k -= 2) * k * k * k - 2);

			}

		},

		Quintic: {

			In: function (k) {

				return k * k * k * k * k;

			},

			Out: function (k) {

				return --k * k * k * k * k + 1;

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return 0.5 * k * k * k * k * k;
				}

				return 0.5 * ((k -= 2) * k * k * k * k + 2);

			}

		},

		Sinusoidal: {

			In: function (k) {

				return 1 - Math.cos(k * Math.PI / 2);

			},

			Out: function (k) {

				return Math.sin(k * Math.PI / 2);

			},

			InOut: function (k) {

				return 0.5 * (1 - Math.cos(Math.PI * k));

			}

		},

		Exponential: {

			In: function (k) {

				return k === 0 ? 0 : Math.pow(1024, k - 1);

			},

			Out: function (k) {

				return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);

			},

			InOut: function (k) {

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				if ((k *= 2) < 1) {
					return 0.5 * Math.pow(1024, k - 1);
				}

				return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);

			}

		},

		Circular: {

			In: function (k) {

				return 1 - Math.sqrt(1 - k * k);

			},

			Out: function (k) {

				return Math.sqrt(1 - (--k * k));

			},

			InOut: function (k) {

				if ((k *= 2) < 1) {
					return - 0.5 * (Math.sqrt(1 - k * k) - 1);
				}

				return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);

			}

		},

		Elastic: {

			In: function (k) {

				var s;
				var a = 0.1;
				var p = 0.4;

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				if (!a || a < 1) {
					a = 1;
					s = p / 4;
				} else {
					s = p * Math.asin(1 / a) / (2 * Math.PI);
				}

				return - (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));

			},

			Out: function (k) {

				var s;
				var a = 0.1;
				var p = 0.4;

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				if (!a || a < 1) {
					a = 1;
					s = p / 4;
				} else {
					s = p * Math.asin(1 / a) / (2 * Math.PI);
				}

				return (a * Math.pow(2, - 10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1);

			},

			InOut: function (k) {

				var s;
				var a = 0.1;
				var p = 0.4;

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				if (!a || a < 1) {
					a = 1;
					s = p / 4;
				} else {
					s = p * Math.asin(1 / a) / (2 * Math.PI);
				}

				if ((k *= 2) < 1) {
					return - 0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
				}

				return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;

			}

		},

		Back: {

			In: function (k) {

				var s = 1.70158;

				return k * k * ((s + 1) * k - s);

			},

			Out: function (k) {

				var s = 1.70158;

				return --k * k * ((s + 1) * k + s) + 1;

			},

			InOut: function (k) {

				var s = 1.70158 * 1.525;

				if ((k *= 2) < 1) {
					return 0.5 * (k * k * ((s + 1) * k - s));
				}

				return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);

			}

		},

		Bounce: {

			In: function (k) {

				return 1 - TWEEN.Easing.Bounce.Out(1 - k);

			},

			Out: function (k) {

				if (k < (1 / 2.75)) {
					return 7.5625 * k * k;
				} else if (k < (2 / 2.75)) {
					return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
				} else if (k < (2.5 / 2.75)) {
					return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
				} else {
					return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
				}

			},

			InOut: function (k) {

				if (k < 0.5) {
					return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
				}

				return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;

			}

		}

	};

	TWEEN.Interpolation = {

		Linear: function (v, k) {

			var m = v.length - 1;
			var f = m * k;
			var i = Math.floor(f);
			var fn = TWEEN.Interpolation.Utils.Linear;

			if (k < 0) {
				return fn(v[0], v[1], f);
			}

			if (k > 1) {
				return fn(v[m], v[m - 1], m - f);
			}

			return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);

		},

		Bezier: function (v, k) {

			var b = 0;
			var n = v.length - 1;
			var pw = Math.pow;
			var bn = TWEEN.Interpolation.Utils.Bernstein;

			for (var i = 0; i <= n; i++) {
				b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
			}

			return b;

		},

		CatmullRom: function (v, k) {

			var m = v.length - 1;
			var f = m * k;
			var i = Math.floor(f);
			var fn = TWEEN.Interpolation.Utils.CatmullRom;

			if (v[0] === v[m]) {

				if (k < 0) {
					i = Math.floor(f = m * (1 + k));
				}

				return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);

			} else {

				if (k < 0) {
					return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
				}

				if (k > 1) {
					return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
				}

				return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);

			}

		},

		Utils: {

			Linear: function (p0, p1, t) {

				return (p1 - p0) * t + p0;

			},

			Bernstein: function (n, i) {

				var fc = TWEEN.Interpolation.Utils.Factorial;

				return fc(n) / fc(i) / fc(n - i);

			},

			Factorial: (function () {

				var a = [1];

				return function (n) {

					var s = 1;

					if (a[n]) {
						return a[n];
					}

					for (var i = n; i > 1; i--) {
						s *= i;
					}

					a[n] = s;
					return s;

				};

			})(),

			CatmullRom: function (p0, p1, p2, p3, t) {

				var v0 = (p2 - p0) * 0.5;
				var v1 = (p3 - p1) * 0.5;
				var t2 = t * t;
				var t3 = t * t2;

				return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;

			}

		}

	};

	// UMD (Universal Module Definition)
	(function (root) {

		if (true) {

			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return TWEEN;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

		} else if (typeof module !== 'undefined' && typeof exports === 'object') {

			// Node.js
			module.exports = TWEEN;

		} else if (root !== undefined) {

			// Global variable
			root.TWEEN = TWEEN;

		}

	})(this);


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol?"symbol":typeof obj;};var _three=__webpack_require__(2);var _three2=_interopRequireDefault(_three);var _ImageUtils=__webpack_require__(9);var _ImageUtils2=_interopRequireDefault(_ImageUtils);var _BinaryHeap=__webpack_require__(10);var _BinaryHeap2=_interopRequireDefault(_BinaryHeap);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else {obj[key]=value;}return obj;}_three2.default.ImageUtils=_ImageUtils2.default;function Potree(){} // contains WebWorkers with base64 encoded code
	Potree.workers={};Potree.Shaders={};Potree.WorkerManager=function(code){this.code=code;this.instances=[];this.createdInstances=0;};Potree.WorkerManager.prototype.getWorker=function(){var ww=this.instances.pop();if(ww===undefined){ww=Potree.utils.createWorker(this.code);this.createdInstances++;}return ww;};Potree.WorkerManager.prototype.returnWorker=function(worker){this.instances.push(worker);}; /**
	 * urls point to WebWorker code.
	 * Code must not contain calls to importScripts, 
	 * concatenation is done by this method.
	 * 
	 */Potree.WorkerManager.fromUrls=function(urls){var code="";for(var i=0;i<urls.length;i++){var url=urls[i];var xhr=new XMLHttpRequest();xhr.open('GET',url,false);xhr.responseType='text';xhr.overrideMimeType('text/plain; charset=x-user-defined');xhr.send(null);if(xhr.status===200){code+=xhr.responseText+"\n";}}return new Potree.WorkerManager(code);};Potree.workers.binaryDecoder=new Potree.WorkerManager(atob("Ci8vIGh0dHA6Ly9qc3BlcmYuY29tL3VpbnQ4YXJyYXktdnMtZGF0YXZpZXczLzMKZnVuY3Rpb24gQ3VzdG9tVmlldyhidWZmZXIpIHsKCXRoaXMuYnVmZmVyID0gYnVmZmVyOwoJdGhpcy51OCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7CgkKCXZhciB0bXAgPSBuZXcgQXJyYXlCdWZmZXIoNCk7Cgl2YXIgdG1wZiA9IG5ldyBGbG9hdDMyQXJyYXkodG1wKTsKCXZhciB0bXB1OCA9IG5ldyBVaW50OEFycmF5KHRtcCk7CgkKCXRoaXMuZ2V0VWludDMyID0gZnVuY3Rpb24gKGkpIHsKCQlyZXR1cm4gKHRoaXMudThbaSszXSA8PCAyNCkgfCAodGhpcy51OFtpKzJdIDw8IDE2KSB8ICh0aGlzLnU4W2krMV0gPDwgOCkgfCB0aGlzLnU4W2ldOwoJfQoJCgl0aGlzLmdldFVpbnQxNiA9IGZ1bmN0aW9uIChpKSB7CgkJcmV0dXJuICh0aGlzLnU4W2krMV0gPDwgOCkgfCB0aGlzLnU4W2ldOwoJfQoJCgl0aGlzLmdldEZsb2F0ID0gZnVuY3Rpb24oaSl7CgkJdG1wdThbMF0gPSB0aGlzLnU4W2krMF07CgkJdG1wdThbMV0gPSB0aGlzLnU4W2krMV07CgkJdG1wdThbMl0gPSB0aGlzLnU4W2krMl07CgkJdG1wdThbM10gPSB0aGlzLnU4W2krM107CgkJCgkJcmV0dXJuIHRtcGZbMF07Cgl9CgkKCXRoaXMuZ2V0VWludDggPSBmdW5jdGlvbihpKXsKCQlyZXR1cm4gdGhpcy51OFtpXTsKCX0KfQoKUG90cmVlID0ge307CgoKb25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpewoJdmFyIGJ1ZmZlciA9IGV2ZW50LmRhdGEuYnVmZmVyOwoJdmFyIHBvaW50QXR0cmlidXRlcyA9IGV2ZW50LmRhdGEucG9pbnRBdHRyaWJ1dGVzOwoJdmFyIG51bVBvaW50cyA9IGJ1ZmZlci5ieXRlTGVuZ3RoIC8gcG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplOwoJdmFyIGN2ID0gbmV3IEN1c3RvbVZpZXcoYnVmZmVyKTsKCXZhciB2ZXJzaW9uID0gbmV3IFBvdHJlZS5WZXJzaW9uKGV2ZW50LmRhdGEudmVyc2lvbik7Cgl2YXIgbWluID0gZXZlbnQuZGF0YS5taW47Cgl2YXIgbm9kZU9mZnNldCA9IGV2ZW50LmRhdGEub2Zmc2V0OwoJdmFyIHNjYWxlID0gZXZlbnQuZGF0YS5zY2FsZTsKCXZhciB0aWdodEJveE1pbiA9IFsgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV07Cgl2YXIgdGlnaHRCb3hNYXggPSBbIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSAsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSAsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSBdOwoJCgl2YXIgYXR0cmlidXRlQnVmZmVycyA9IHt9OwoJCgl2YXIgb2Zmc2V0ID0gMDsKCWZvcih2YXIgaSA9IDA7IGkgPCBwb2ludEF0dHJpYnV0ZXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKyl7CgkJdmFyIHBvaW50QXR0cmlidXRlID0gcG9pbnRBdHRyaWJ1dGVzLmF0dHJpYnV0ZXNbaV07CgkKCQlpZihwb2ludEF0dHJpYnV0ZS5uYW1lID09PSBQb3RyZWUuUG9pbnRBdHRyaWJ1dGUuUE9TSVRJT05fQ0FSVEVTSUFOLm5hbWUpewoJCQkKCQkJdmFyIGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIobnVtUG9pbnRzKjQqMyk7CgkJCXZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmYpOwoJCQkKCQkJZm9yKHZhciBqID0gMDsgaiA8IG51bVBvaW50czsgaisrKXsKCQkJCWlmKHZlcnNpb24ubmV3ZXJUaGFuKCIxLjMiKSl7CgkJCQkJcG9zaXRpb25zWzMqaiswXSA9IChjdi5nZXRVaW50MzIob2Zmc2V0ICsgaipwb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUrMCkgKiBzY2FsZSkgKyBtaW5bMF07CgkJCQkJcG9zaXRpb25zWzMqaisxXSA9IChjdi5nZXRVaW50MzIob2Zmc2V0ICsgaipwb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUrNCkgKiBzY2FsZSkgKyBtaW5bMV07CgkJCQkJcG9zaXRpb25zWzMqaisyXSA9IChjdi5nZXRVaW50MzIob2Zmc2V0ICsgaipwb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUrOCkgKiBzY2FsZSkgKyBtaW5bMl07CgkJCQl9ZWxzZXsKCQkJCQlwb3NpdGlvbnNbMypqKzBdID0gY3YuZ2V0RmxvYXQoaipwb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUrMCkgKyBub2RlT2Zmc2V0WzBdOwoJCQkJCXBvc2l0aW9uc1szKmorMV0gPSBjdi5nZXRGbG9hdChqKnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSs0KSArIG5vZGVPZmZzZXRbMV07CgkJCQkJcG9zaXRpb25zWzMqaisyXSA9IGN2LmdldEZsb2F0KGoqcG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplKzgpICsgbm9kZU9mZnNldFsyXTsKCQkJCX0KCQkJCQoJCQkJdGlnaHRCb3hNaW5bMF0gPSBNYXRoLm1pbih0aWdodEJveE1pblswXSwgcG9zaXRpb25zWzMqaiswXSk7CgkJCQl0aWdodEJveE1pblsxXSA9IE1hdGgubWluKHRpZ2h0Qm94TWluWzFdLCBwb3NpdGlvbnNbMypqKzFdKTsKCQkJCXRpZ2h0Qm94TWluWzJdID0gTWF0aC5taW4odGlnaHRCb3hNaW5bMl0sIHBvc2l0aW9uc1szKmorMl0pOwoJCQkJCgkJCQl0aWdodEJveE1heFswXSA9IE1hdGgubWF4KHRpZ2h0Qm94TWF4WzBdLCBwb3NpdGlvbnNbMypqKzBdKTsKCQkJCXRpZ2h0Qm94TWF4WzFdID0gTWF0aC5tYXgodGlnaHRCb3hNYXhbMV0sIHBvc2l0aW9uc1szKmorMV0pOwoJCQkJdGlnaHRCb3hNYXhbMl0gPSBNYXRoLm1heCh0aWdodEJveE1heFsyXSwgcG9zaXRpb25zWzMqaisyXSk7CgkJCX0KCQkJCgkJCWF0dHJpYnV0ZUJ1ZmZlcnNbcG9pbnRBdHRyaWJ1dGUubmFtZV0gPSB7IGJ1ZmZlcjogYnVmZiwgYXR0cmlidXRlOiBwb2ludEF0dHJpYnV0ZX07CgkJCQoJCX1lbHNlIGlmKHBvaW50QXR0cmlidXRlLm5hbWUgPT09IFBvdHJlZS5Qb2ludEF0dHJpYnV0ZS5DT0xPUl9QQUNLRUQubmFtZSl7CgkJCQoJCQl2YXIgYnVmZiA9IG5ldyBBcnJheUJ1ZmZlcihudW1Qb2ludHMqNCozKTsKCQkJdmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZik7CgkJCQoJCQlmb3IodmFyIGogPSAwOyBqIDwgbnVtUG9pbnRzOyBqKyspewoJCQkJY29sb3JzWzMqaiswXSA9IGN2LmdldFVpbnQ4KG9mZnNldCArIGoqcG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMCkgLyAyNTU7CgkJCQljb2xvcnNbMypqKzFdID0gY3YuZ2V0VWludDgob2Zmc2V0ICsgaipwb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyAxKSAvIDI1NTsKCQkJCWNvbG9yc1szKmorMl0gPSBjdi5nZXRVaW50OChvZmZzZXQgKyBqKnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDIpIC8gMjU1OwoJCQl9CgkJCQoJCQlhdHRyaWJ1dGVCdWZmZXJzW3BvaW50QXR0cmlidXRlLm5hbWVdID0geyBidWZmZXI6IGJ1ZmYsIGF0dHJpYnV0ZTogcG9pbnRBdHRyaWJ1dGV9OwoJCQkKCQl9ZWxzZSBpZihwb2ludEF0dHJpYnV0ZS5uYW1lID09PSBQb3RyZWUuUG9pbnRBdHRyaWJ1dGUuSU5URU5TSVRZLm5hbWUpewoKCQkJdmFyIGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIobnVtUG9pbnRzKjQpOwoJCQl2YXIgaW50ZW5zaXRpZXMgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmYpOwoJCQkKCQkJZm9yKHZhciBqID0gMDsgaiA8IG51bVBvaW50czsgaisrKXsKCQkJCXZhciBpbnRlbnNpdHkgPSBjdi5nZXRVaW50MTYob2Zmc2V0ICsgaipwb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUpOwoJCQkJaW50ZW5zaXRpZXNbal0gPSBpbnRlbnNpdHk7CgkJCX0KCQkJCgkJCWF0dHJpYnV0ZUJ1ZmZlcnNbcG9pbnRBdHRyaWJ1dGUubmFtZV0gPSB7IGJ1ZmZlcjogYnVmZiwgYXR0cmlidXRlOiBwb2ludEF0dHJpYnV0ZX07CgkJCgkJfWVsc2UgaWYocG9pbnRBdHRyaWJ1dGUubmFtZSA9PT0gUG90cmVlLlBvaW50QXR0cmlidXRlLkNMQVNTSUZJQ0FUSU9OLm5hbWUpewoKCQkJdmFyIGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIobnVtUG9pbnRzKjQpOwoJCQl2YXIgY2xhc3NpZmljYXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShidWZmKTsKCQkJCgkJCWZvcih2YXIgaiA9IDA7IGogPCBudW1Qb2ludHM7IGorKyl7CgkJCQl2YXIgY2xhc3NpZmljYXRpb24gPSBjdi5nZXRVaW50OChvZmZzZXQgKyBqKnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSk7CgkJCQljbGFzc2lmaWNhdGlvbnNbal0gPSBjbGFzc2lmaWNhdGlvbjsKCQkJfQoJCQkKCQkJYXR0cmlidXRlQnVmZmVyc1twb2ludEF0dHJpYnV0ZS5uYW1lXSA9IHsgYnVmZmVyOiBidWZmLCBhdHRyaWJ1dGU6IHBvaW50QXR0cmlidXRlfTsKCQkKCQl9ZWxzZSBpZihwb2ludEF0dHJpYnV0ZS5uYW1lID09PSBQb3RyZWUuUG9pbnRBdHRyaWJ1dGUuTk9STUFMX1NQSEVSRU1BUFBFRC5uYW1lKXsKCgkJCXZhciBidWZmID0gbmV3IEFycmF5QnVmZmVyKG51bVBvaW50cyo0KjMpOwoJCQl2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZik7CgkJCQoJCQlmb3IodmFyIGogPSAwOyBqIDwgbnVtUG9pbnRzOyBqKyspewoJCQkJdmFyIGJ4ID0gY3YuZ2V0VWludDgob2Zmc2V0ICsgaiAqIHBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDApOwoJCQkJdmFyIGJ5ID0gY3YuZ2V0VWludDgob2Zmc2V0ICsgaiAqIHBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDEpOwoJCQkKCQkJCXZhciBleCA9IGJ4IC8gMjU1OwoJCQkJdmFyIGV5ID0gYnkgLyAyNTU7CgkJCQkKCQkJCXZhciBueCA9IGV4ICogMiAtIDE7CgkJCQl2YXIgbnkgPSBleSAqIDIgLSAxOwoJCQkJdmFyIG56ID0gMTsKCQkJCXZhciBudyA9IC0xOwoJCQkJCgkJCQl2YXIgbCA9IChueCAqICgtbngpKSArIChueSAqICgtbnkpKSArIChueiAqICgtbncpKTsKCQkJCW56ID0gbDsKCQkJCW54ID0gbnggKiBNYXRoLnNxcnQobCk7CgkJCQlueSA9IG55ICogTWF0aC5zcXJ0KGwpOwoJCQkJCgkJCQlueCA9IG54ICogMjsKCQkJCW55ID0gbnkgKiAyOwoJCQkJbnogPSBueiAqIDIgLSAxOwoJCQkJCgkJCQlub3JtYWxzWzMqaiArIDBdID0gbng7CgkJCQlub3JtYWxzWzMqaiArIDFdID0gbnk7CgkJCQlub3JtYWxzWzMqaiArIDJdID0gbno7CgkJCX0KCQkJCgkJCWF0dHJpYnV0ZUJ1ZmZlcnNbcG9pbnRBdHRyaWJ1dGUubmFtZV0gPSB7IGJ1ZmZlcjogYnVmZiwgYXR0cmlidXRlOiBwb2ludEF0dHJpYnV0ZX07CgkJfWVsc2UgaWYocG9pbnRBdHRyaWJ1dGUubmFtZSA9PT0gUG90cmVlLlBvaW50QXR0cmlidXRlLk5PUk1BTF9PQ1QxNi5uYW1lKXsKCQkJCgkJCXZhciBidWZmID0gbmV3IEFycmF5QnVmZmVyKG51bVBvaW50cyo0KjMpOwoJCQl2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZik7CgkJCWZvcih2YXIgaiA9IDA7IGogPCBudW1Qb2ludHM7IGorKyl7CgkJCQl2YXIgYnggPSBjdi5nZXRVaW50OChvZmZzZXQgKyBqICogcG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMCk7CgkJCQl2YXIgYnkgPSBjdi5nZXRVaW50OChvZmZzZXQgKyBqICogcG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMSk7CgkJCQkKCQkJCXZhciB1ID0gKGJ4IC8gMjU1KSAqIDIgLSAxOwoJCQkJdmFyIHYgPSAoYnkgLyAyNTUpICogMiAtIDE7CgkJCQkKCQkJCXZhciB6ID0gMSAtIE1hdGguYWJzKHUpIC0gTWF0aC5hYnModik7CgkJCQkKCQkJCWlmKHogPj0gMCl7CgkJCQkJdmFyIHggPSB1OwoJCQkJCXZhciB5ID0gdjsKCQkJCX1lbHNlewoJCQkJCXZhciB4ID0gLSAodi9NYXRoLnNpZ24odikgLSAxKSAvIE1hdGguc2lnbih1KTsKCQkJCQl2YXIgeSA9IC0gKHUvTWF0aC5zaWduKHUpIC0gMSkgLyBNYXRoLnNpZ24odik7CgkJCQl9CgkJCQkKCQkJCXZhciBsZW5ndGggPSBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTsKCQkJCXggPSB4IC8gbGVuZ3RoOwoJCQkJeSA9IHkgLyBsZW5ndGg7CgkJCQl6ID0geiAvIGxlbmd0aDsKCQkJCQoJCQkJbm9ybWFsc1szKmogKyAwXSA9IHg7CgkJCQlub3JtYWxzWzMqaiArIDFdID0geTsKCQkJCW5vcm1hbHNbMypqICsgMl0gPSB6OwoJCQl9CgkJCWF0dHJpYnV0ZUJ1ZmZlcnNbcG9pbnRBdHRyaWJ1dGUubmFtZV0gPSB7IGJ1ZmZlcjogYnVmZiwgYXR0cmlidXRlOiBwb2ludEF0dHJpYnV0ZX07CgkJfWVsc2UgaWYocG9pbnRBdHRyaWJ1dGUubmFtZSA9PT0gUG90cmVlLlBvaW50QXR0cmlidXRlLk5PUk1BTC5uYW1lKXsKCQkKCQkJdmFyIGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIobnVtUG9pbnRzKjQqMyk7CgkJCXZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShidWZmKTsKCQkJZm9yKHZhciBqID0gMDsgaiA8IG51bVBvaW50czsgaisrKXsKCQkJCXZhciB4ID0gY3YuZ2V0RmxvYXQob2Zmc2V0ICsgaiAqIHBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDApOwoJCQkJdmFyIHkgPSBjdi5nZXRGbG9hdChvZmZzZXQgKyBqICogcG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgNCk7CgkJCQl2YXIgeiA9IGN2LmdldEZsb2F0KG9mZnNldCArIGogKiBwb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyA4KTsKCQkJCQoJCQkJbm9ybWFsc1szKmogKyAwXSA9IHg7CgkJCQlub3JtYWxzWzMqaiArIDFdID0geTsKCQkJCW5vcm1hbHNbMypqICsgMl0gPSB6OwoJCQl9CgkJCWF0dHJpYnV0ZUJ1ZmZlcnNbcG9pbnRBdHRyaWJ1dGUubmFtZV0gPSB7IGJ1ZmZlcjogYnVmZiwgYXR0cmlidXRlOiBwb2ludEF0dHJpYnV0ZX07CgkJfQoJCQoJCW9mZnNldCArPSBwb2ludEF0dHJpYnV0ZS5ieXRlU2l6ZTsKCX0KCQoJdmFyIGluZGljZXMgPSBuZXcgQXJyYXlCdWZmZXIobnVtUG9pbnRzKjQpOwoJdmFyIGlJbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KGluZGljZXMpOwoJZm9yKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKXsKCQlpSW5kaWNlc1tpXSA9IGk7Cgl9CgkKCXZhciBtZXNzYWdlID0gewoJCWF0dHJpYnV0ZUJ1ZmZlcnM6IGF0dHJpYnV0ZUJ1ZmZlcnMsCgkJdGlnaHRCb3VuZGluZ0JveDogeyBtaW46IHRpZ2h0Qm94TWluLCBtYXg6IHRpZ2h0Qm94TWF4IH0sCgkJaW5kaWNlczogaW5kaWNlcwoJfTsKCQkKCXZhciB0cmFuc2ZlcmFibGVzID0gW107CgkKCWZvcih2YXIgcHJvcGVydHkgaW4gbWVzc2FnZS5hdHRyaWJ1dGVCdWZmZXJzKXsKCQlpZihtZXNzYWdlLmF0dHJpYnV0ZUJ1ZmZlcnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKXsKCQkJdHJhbnNmZXJhYmxlcy5wdXNoKG1lc3NhZ2UuYXR0cmlidXRlQnVmZmVyc1twcm9wZXJ0eV0uYnVmZmVyKTsKCQl9Cgl9CgkKCXRyYW5zZmVyYWJsZXMucHVzaChtZXNzYWdlLmluZGljZXMpOwoJCQoJcG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJhYmxlcyk7CgkKfTsKUG90cmVlLlZlcnNpb24gPSBmdW5jdGlvbih2ZXJzaW9uKXsKCXRoaXMudmVyc2lvbiA9IHZlcnNpb247Cgl2YXIgdm1MZW5ndGggPSAodmVyc2lvbi5pbmRleE9mKCIuIikgPT09IC0xKSA/IHZlcnNpb24ubGVuZ3RoIDogdmVyc2lvbi5pbmRleE9mKCIuIik7Cgl0aGlzLnZlcnNpb25NYWpvciA9IHBhcnNlSW50KHZlcnNpb24uc3Vic3RyKDAsIHZtTGVuZ3RoKSk7Cgl0aGlzLnZlcnNpb25NaW5vciA9IHBhcnNlSW50KHZlcnNpb24uc3Vic3RyKHZtTGVuZ3RoICsgMSkpOwoJaWYodGhpcy52ZXJzaW9uTWlub3IubGVuZ3RoID09PSAwKXsKCQl0aGlzLnZlcnNpb25NaW5vciA9IDA7Cgl9CgkKfTsKClBvdHJlZS5WZXJzaW9uLnByb3RvdHlwZS5uZXdlclRoYW4gPSBmdW5jdGlvbih2ZXJzaW9uKXsKCXZhciB2ID0gbmV3IFBvdHJlZS5WZXJzaW9uKHZlcnNpb24pOwoJCglpZiggdGhpcy52ZXJzaW9uTWFqb3IgPiB2LnZlcnNpb25NYWpvcil7CgkJcmV0dXJuIHRydWU7Cgl9ZWxzZSBpZiggdGhpcy52ZXJzaW9uTWFqb3IgPT09IHYudmVyc2lvbk1ham9yICYmIHRoaXMudmVyc2lvbk1pbm9yID4gdi52ZXJzaW9uTWlub3IpewoJCXJldHVybiB0cnVlOwoJfWVsc2V7CgkJcmV0dXJuIGZhbHNlOwoJfQp9OwoKUG90cmVlLlZlcnNpb24ucHJvdG90eXBlLmVxdWFsT3JIaWdoZXIgPSBmdW5jdGlvbih2ZXJzaW9uKXsKCXZhciB2ID0gbmV3IFBvdHJlZS5WZXJzaW9uKHZlcnNpb24pOwoJCglpZiggdGhpcy52ZXJzaW9uTWFqb3IgPiB2LnZlcnNpb25NYWpvcil7CgkJcmV0dXJuIHRydWU7Cgl9ZWxzZSBpZiggdGhpcy52ZXJzaW9uTWFqb3IgPT09IHYudmVyc2lvbk1ham9yICYmIHRoaXMudmVyc2lvbk1pbm9yID49IHYudmVyc2lvbk1pbm9yKXsKCQlyZXR1cm4gdHJ1ZTsKCX1lbHNlewoJCXJldHVybiBmYWxzZTsKCX0KfTsKClBvdHJlZS5WZXJzaW9uLnByb3RvdHlwZS51cFRvID0gZnVuY3Rpb24odmVyc2lvbil7CglyZXR1cm4gIXRoaXMubmV3ZXJUaGFuKHZlcnNpb24pOwp9ClBvdHJlZS5Qb2ludEF0dHJpYnV0ZU5hbWVzID0ge307CgpQb3RyZWUuUG9pbnRBdHRyaWJ1dGVOYW1lcy5QT1NJVElPTl9DQVJURVNJQU4gCT0gMDsJLy8gZmxvYXQgeCwgeSwgejsKUG90cmVlLlBvaW50QXR0cmlidXRlTmFtZXMuQ09MT1JfUEFDS0VECQk9IDE7CS8vIGJ5dGUgciwgZywgYiwgYTsgCUkgPSBbMCwxXQpQb3RyZWUuUG9pbnRBdHRyaWJ1dGVOYW1lcy5DT0xPUl9GTE9BVFNfMQkJPSAyOwkvLyBmbG9hdCByLCBnLCBiOyAJCUkgPSBbMCwxXQpQb3RyZWUuUG9pbnRBdHRyaWJ1dGVOYW1lcy5DT0xPUl9GTE9BVFNfMjU1CT0gMzsJLy8gZmxvYXQgciwgZywgYjsgCQlJID0gWzAsMjU1XQpQb3RyZWUuUG9pbnRBdHRyaWJ1dGVOYW1lcy5OT1JNQUxfRkxPQVRTCQk9IDQ7ICAJLy8gZmxvYXQgeCwgeSwgejsKUG90cmVlLlBvaW50QXR0cmlidXRlTmFtZXMuRklMTEVSCQkJCT0gNTsKUG90cmVlLlBvaW50QXR0cmlidXRlTmFtZXMuSU5URU5TSVRZCQkJPSA2OwpQb3RyZWUuUG9pbnRBdHRyaWJ1dGVOYW1lcy5DTEFTU0lGSUNBVElPTgkJPSA3OwpQb3RyZWUuUG9pbnRBdHRyaWJ1dGVOYW1lcy5OT1JNQUxfU1BIRVJFTUFQUEVECT0gODsKUG90cmVlLlBvaW50QXR0cmlidXRlTmFtZXMuTk9STUFMX09DVDE2CQk9IDk7ClBvdHJlZS5Qb2ludEF0dHJpYnV0ZU5hbWVzLk5PUk1BTAkJCQk9IDEwOwoKLyoqCiAqIFNvbWUgdHlwZXMgb2YgcG9zc2libGUgcG9pbnQgYXR0cmlidXRlIGRhdGEgZm9ybWF0cwogKiAKICogQGNsYXNzCiAqLwpQb3RyZWUuUG9pbnRBdHRyaWJ1dGVUeXBlcyA9IHsKCURBVEFfVFlQRV9ET1VCTEUJOiB7b3JkaW5hbCA6IDAsIHNpemU6IDh9LAoJREFUQV9UWVBFX0ZMT0FUCQk6IHtvcmRpbmFsIDogMSwgc2l6ZTogNH0sCglEQVRBX1RZUEVfSU5UOAkJOiB7b3JkaW5hbCA6IDIsIHNpemU6IDF9LAoJREFUQV9UWVBFX1VJTlQ4CQk6IHtvcmRpbmFsIDogMywgc2l6ZTogMX0sCglEQVRBX1RZUEVfSU5UMTYJCToge29yZGluYWwgOiA0LCBzaXplOiAyfSwKCURBVEFfVFlQRV9VSU5UMTYJOiB7b3JkaW5hbCA6IDUsIHNpemU6IDJ9LAoJREFUQV9UWVBFX0lOVDMyCQk6IHtvcmRpbmFsIDogNiwgc2l6ZTogNH0sCglEQVRBX1RZUEVfVUlOVDMyCToge29yZGluYWwgOiA3LCBzaXplOiA0fSwKCURBVEFfVFlQRV9JTlQ2NAkJOiB7b3JkaW5hbCA6IDgsIHNpemU6IDh9LAoJREFUQV9UWVBFX1VJTlQ2NAk6IHtvcmRpbmFsIDogOSwgc2l6ZTogOH0KfTsKCnZhciBpID0gMDsKZm9yKHZhciBvYmogaW4gUG90cmVlLlBvaW50QXR0cmlidXRlVHlwZXMpewoJUG90cmVlLlBvaW50QXR0cmlidXRlVHlwZXNbaV0gPSBQb3RyZWUuUG9pbnRBdHRyaWJ1dGVUeXBlc1tvYmpdOwoJaSsrOwp9CgovKioKICogQSBzaW5nbGUgcG9pbnQgYXR0cmlidXRlIHN1Y2ggYXMgY29sb3Ivbm9ybWFsLy4uIGFuZCBpdHMgZGF0YSBmb3JtYXQvbnVtYmVyIG9mIGVsZW1lbnRzLy4uLiAKICogCiAqIEBjbGFzcwogKiBAcGFyYW0gbmFtZSAKICogQHBhcmFtIHR5cGUKICogQHBhcmFtIHNpemUKICogQHJldHVybnMKICovClBvdHJlZS5Qb2ludEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUsIG51bUVsZW1lbnRzKXsKCXRoaXMubmFtZSA9IG5hbWU7Cgl0aGlzLnR5cGUgPSB0eXBlOyAKCXRoaXMubnVtRWxlbWVudHMgPSBudW1FbGVtZW50czsKCXRoaXMuYnl0ZVNpemUgPSB0aGlzLm51bUVsZW1lbnRzICogdGhpcy50eXBlLnNpemU7Cn0KClBvdHJlZS5Qb2ludEF0dHJpYnV0ZS5QT1NJVElPTl9DQVJURVNJQU4gPSBuZXcgUG90cmVlLlBvaW50QXR0cmlidXRlKAoJCVBvdHJlZS5Qb2ludEF0dHJpYnV0ZU5hbWVzLlBPU0lUSU9OX0NBUlRFU0lBTiwKCQlQb3RyZWUuUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfRkxPQVQsIDMpOwoKUG90cmVlLlBvaW50QXR0cmlidXRlLlJHQkFfUEFDS0VEID0gbmV3IFBvdHJlZS5Qb2ludEF0dHJpYnV0ZSgKCQlQb3RyZWUuUG9pbnRBdHRyaWJ1dGVOYW1lcy5DT0xPUl9QQUNLRUQsCgkJUG90cmVlLlBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0lOVDgsIDQpOwoKUG90cmVlLlBvaW50QXR0cmlidXRlLkNPTE9SX1BBQ0tFRCA9IFBvdHJlZS5Qb2ludEF0dHJpYnV0ZS5SR0JBX1BBQ0tFRDsKClBvdHJlZS5Qb2ludEF0dHJpYnV0ZS5SR0JfUEFDS0VEID0gbmV3IFBvdHJlZS5Qb2ludEF0dHJpYnV0ZSgKCQlQb3RyZWUuUG9pbnRBdHRyaWJ1dGVOYW1lcy5DT0xPUl9QQUNLRUQsCgkJUG90cmVlLlBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0lOVDgsIDMpOwoKUG90cmVlLlBvaW50QXR0cmlidXRlLk5PUk1BTF9GTE9BVFMgPSBuZXcgUG90cmVlLlBvaW50QXR0cmlidXRlKAoJCVBvdHJlZS5Qb2ludEF0dHJpYnV0ZU5hbWVzLk5PUk1BTF9GTE9BVFMsCgkJUG90cmVlLlBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKTsKClBvdHJlZS5Qb2ludEF0dHJpYnV0ZS5GSUxMRVJfMUIgPSBuZXcgUG90cmVlLlBvaW50QXR0cmlidXRlKAoJCVBvdHJlZS5Qb2ludEF0dHJpYnV0ZU5hbWVzLkZJTExFUiwKCQlQb3RyZWUuUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDgsIDEpOwoJCQpQb3RyZWUuUG9pbnRBdHRyaWJ1dGUuSU5URU5TSVRZID0gbmV3IFBvdHJlZS5Qb2ludEF0dHJpYnV0ZSgKCQlQb3RyZWUuUG9pbnRBdHRyaWJ1dGVOYW1lcy5JTlRFTlNJVFksCgkJUG90cmVlLlBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQxNiwgMSk7CQkKCQkKUG90cmVlLlBvaW50QXR0cmlidXRlLkNMQVNTSUZJQ0FUSU9OID0gbmV3IFBvdHJlZS5Qb2ludEF0dHJpYnV0ZSgKCQlQb3RyZWUuUG9pbnRBdHRyaWJ1dGVOYW1lcy5DTEFTU0lGSUNBVElPTiwKCQlQb3RyZWUuUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDgsIDEpOwkKCQkKUG90cmVlLlBvaW50QXR0cmlidXRlLk5PUk1BTF9TUEhFUkVNQVBQRUQgPSBuZXcgUG90cmVlLlBvaW50QXR0cmlidXRlKAoJCVBvdHJlZS5Qb2ludEF0dHJpYnV0ZU5hbWVzLk5PUk1BTF9TUEhFUkVNQVBQRUQsCgkJUG90cmVlLlBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQ4LCAyKTsJCQoJCQpQb3RyZWUuUG9pbnRBdHRyaWJ1dGUuTk9STUFMX09DVDE2ID0gbmV3IFBvdHJlZS5Qb2ludEF0dHJpYnV0ZSgKCQlQb3RyZWUuUG9pbnRBdHRyaWJ1dGVOYW1lcy5OT1JNQUxfT0NUMTYsCgkJUG90cmVlLlBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQ4LCAyKTsJCgkJClBvdHJlZS5Qb2ludEF0dHJpYnV0ZS5OT1JNQUwgPSBuZXcgUG90cmVlLlBvaW50QXR0cmlidXRlKAoJCVBvdHJlZS5Qb2ludEF0dHJpYnV0ZU5hbWVzLk5PUk1BTCwKCQlQb3RyZWUuUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfRkxPQVQsIDMpOwoKLyoqCiAqIE9yZGVyZWQgbGlzdCBvZiBQb2ludEF0dHJpYnV0ZXMgdXNlZCB0byBpZGVudGlmeSBob3cgcG9pbnRzIGFyZSBhbGlnbmVkIGluIGEgYnVmZmVyLgogKiAKICogQGNsYXNzCiAqIAogKi8KUG90cmVlLlBvaW50QXR0cmlidXRlcyA9IGZ1bmN0aW9uKHBvaW50QXR0cmlidXRlcyl7Cgl0aGlzLmF0dHJpYnV0ZXMgPSBuZXcgQXJyYXkoKTsKCXRoaXMuYnl0ZVNpemUgPSAwOwoJdGhpcy5zaXplID0gMDsKCQoJaWYocG9pbnRBdHRyaWJ1dGVzICE9IG51bGwpewkKCQlmb3IodmFyIGkgPSAwOyBpIDwgcG9pbnRBdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKXsKCQkJdmFyIHBvaW50QXR0cmlidXRlTmFtZSA9IHBvaW50QXR0cmlidXRlc1tpXTsKCQkJdmFyIHBvaW50QXR0cmlidXRlID0gUG90cmVlLlBvaW50QXR0cmlidXRlW3BvaW50QXR0cmlidXRlTmFtZV07CgkJCXRoaXMuYXR0cmlidXRlcy5wdXNoKHBvaW50QXR0cmlidXRlKTsKCQkJdGhpcy5ieXRlU2l6ZSArPSBwb2ludEF0dHJpYnV0ZS5ieXRlU2l6ZTsKCQkJdGhpcy5zaXplKys7CgkJfQoJfQp9CgpQb3RyZWUuUG9pbnRBdHRyaWJ1dGVzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihwb2ludEF0dHJpYnV0ZSl7Cgl0aGlzLmF0dHJpYnV0ZXMucHVzaChwb2ludEF0dHJpYnV0ZSk7Cgl0aGlzLmJ5dGVTaXplICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplOwoJdGhpcy5zaXplKys7Cn07CgpQb3RyZWUuUG9pbnRBdHRyaWJ1dGVzLnByb3RvdHlwZS5oYXNDb2xvcnMgPSBmdW5jdGlvbigpewoJZm9yKHZhciBuYW1lIGluIHRoaXMuYXR0cmlidXRlcyl7CgkJdmFyIHBvaW50QXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzW25hbWVdOwoJCWlmKHBvaW50QXR0cmlidXRlLm5hbWUgPT09IFBvdHJlZS5Qb2ludEF0dHJpYnV0ZU5hbWVzLkNPTE9SX1BBQ0tFRCl7CgkJCXJldHVybiB0cnVlOwoJCX0KCX0KCQoJcmV0dXJuIGZhbHNlOwp9OwoKUG90cmVlLlBvaW50QXR0cmlidXRlcy5wcm90b3R5cGUuaGFzTm9ybWFscyA9IGZ1bmN0aW9uKCl7Cglmb3IodmFyIG5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKXsKCQl2YXIgcG9pbnRBdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07CgkJaWYoCgkJCXBvaW50QXR0cmlidXRlID09PSBQb3RyZWUuUG9pbnRBdHRyaWJ1dGUuTk9STUFMX1NQSEVSRU1BUFBFRCB8fCAKCQkJcG9pbnRBdHRyaWJ1dGUgPT09IFBvdHJlZS5Qb2ludEF0dHJpYnV0ZS5OT1JNQUxfRkxPQVRTIHx8CgkJCXBvaW50QXR0cmlidXRlID09PSBQb3RyZWUuUG9pbnRBdHRyaWJ1dGUuTk9STUFMIHx8CgkJCXBvaW50QXR0cmlidXRlID09PSBQb3RyZWUuUG9pbnRBdHRyaWJ1dGUuTk9STUFMX09DVDE2KXsKCQkJcmV0dXJuIHRydWU7CgkJfQoJfQoJCglyZXR1cm4gZmFsc2U7Cn07CgoK"));Potree.Shaders["pointcloud.vs"]=["","// the following is an incomplete list of attributes, uniforms and defines","// which are automatically added through the THREE.ShaderMaterial","","//attribute vec3 position;","//attribute vec3 color;","//attribute vec3 normal;","","//uniform mat4 modelMatrix;","//uniform mat4 modelViewMatrix;","//uniform mat4 projectionMatrix;","//uniform mat4 viewMatrix;","//uniform mat3 normalMatrix;","//uniform vec3 cameraPosition;","","//#define MAX_DIR_LIGHTS 0","//#define MAX_POINT_LIGHTS 1","//#define MAX_SPOT_LIGHTS 0","//#define MAX_HEMI_LIGHTS 0","//#define MAX_SHADOWS 0","//#define MAX_BONES 58","","#define max_clip_boxes 30","","attribute float intensity;","attribute float classification;","attribute float returnNumber;","attribute float numberOfReturns;","attribute float pointSourceID;","attribute vec4 indices;","","uniform float screenWidth;","uniform float screenHeight;","uniform float fov;","uniform float spacing;","uniform float near;","uniform float far;","","#if defined use_clip_box","  uniform mat4 clipBoxes[max_clip_boxes];","#endif","","","uniform float heightMin;","uniform float heightMax;","uniform float intensityMin;","uniform float intensityMax;","uniform float size;       // pixel size factor","uniform float minSize;      // minimum pixel size","uniform float maxSize;      // maximum pixel size","uniform float octreeSize;","uniform vec3 bbSize;","uniform vec3 uColor;","uniform float opacity;","uniform float clipBoxCount;","","","uniform sampler2D visibleNodes;","uniform sampler2D gradient;","uniform sampler2D classificationLUT;","uniform sampler2D depthMap;","","varying float vOpacity;","varying vec3  vColor;","varying float vLinearDepth;","varying float vLogDepth;","varying vec3  vViewPosition;","varying float   vRadius;","varying vec3  vWorldPosition;","varying vec3  vNormal;","","","// ---------------------","// OCTREE","// ---------------------","","#if (defined(adaptive_point_size) || defined(color_type_tree_depth)) && defined(tree_type_octree)","/**"," * number of 1-bits up to inclusive index position"," * number is treated as if it were an integer in the range 0-255"," *"," */","float numberOfOnes(float number, float index){","  float tmp = mod(number, pow(2.0, index + 1.0));","  float numOnes = 0.0;","  for(float i = 0.0; i < 8.0; i++){","    if(mod(tmp, 2.0) != 0.0){","      numOnes++;","    }","    tmp = floor(tmp / 2.0);","  }","  return numOnes;","}","","","/**"," * checks whether the bit at index is 1"," * number is treated as if it were an integer in the range 0-255"," *"," */","bool isBitSet(float number, float index){","  return mod(floor(number / pow(2.0, index)), 2.0) != 0.0;","}","","","/**"," * find the tree depth at the point position"," */","float getLocalTreeDepth(){","  vec3 offset = vec3(0.0, 0.0, 0.0);","  float iOffset = 0.0;","  float depth = 0.0;","  for(float i = 0.0; i <= 1000.0; i++){","    float nodeSizeAtLevel = octreeSize  / pow(2.0, i);","    vec3 index3d = (position - offset) / nodeSizeAtLevel;","    index3d = floor(index3d + 0.5);","    float index = 4.0*index3d.x + 2.0*index3d.y + index3d.z;","    ","    vec4 value = texture2D(visibleNodes, vec2(iOffset / 2048.0, 0.0));","    float mask = value.r * 255.0;","    if(isBitSet(mask, index)){","      // there are more visible child nodes at this position","      iOffset = iOffset + value.g * 255.0 + numberOfOnes(mask, index - 1.0);","      depth++;","    }else{","      // no more visible child nodes at this position","      return depth;","    }","    offset = offset + (vec3(1.0, 1.0, 1.0) * nodeSizeAtLevel * 0.5) * index3d;","  }","    ","  return depth;","}","","float getPointSizeAttenuation(){","  return pow(1.9, getLocalTreeDepth());","}","","","#endif","","","// ---------------------","// KD-TREE","// ---------------------","","#if (defined(adaptive_point_size) || defined(color_type_tree_depth)) && defined(tree_type_kdtree)","","float getLocalTreeDepth(){","  vec3 offset = vec3(0.0, 0.0, 0.0);","  float iOffset = 0.0;","  float depth = 0.0;","    ","    ","  vec3 size = bbSize; ","  vec3 pos = position;","    ","  for(float i = 0.0; i <= 1000.0; i++){","    ","    vec4 value = texture2D(visibleNodes, vec2(iOffset / 2048.0, 0.0));","    ","    int children = int(value.r * 255.0);","    float next = value.g * 255.0;","    int split = int(value.b * 255.0);","    ","    if(next == 0.0){","      return depth;","    }","    ","    vec3 splitv = vec3(0.0, 0.0, 0.0);","    if(split == 1){","      splitv.x = 1.0;","    }else if(split == 2){","      splitv.y = 1.0;","    }else if(split == 4){","      splitv.z = 1.0;","    }","    ","    iOffset = iOffset + next;","    ","    float factor = length(pos * splitv / size);","    if(factor < 0.5){","      // left","        if(children == 0 || children == 2){","          return depth;","        }","    }else{","        // right","        pos = pos - size * splitv * 0.5;","        if(children == 0 || children == 1){","          return depth;","        }","        if(children == 3){","          iOffset = iOffset + 1.0;","        }","    }","    size = size * ((1.0 - (splitv + 1.0) / 2.0) + 0.5);","    ","    depth++;","  }","    ","    ","  return depth; ","}","","float getPointSizeAttenuation(){","  return pow(1.3, getLocalTreeDepth());","}","","#endif","","void main() {","  vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );","  vViewPosition = -mvPosition.xyz;","  vWorldPosition = worldPosition.xyz;","  gl_Position = projectionMatrix * mvPosition;","  vOpacity = opacity;","  vLinearDepth = -mvPosition.z;","  vNormal = normalize(normalMatrix * normal);","  ","  #if defined(use_edl)","    vLogDepth = log2(gl_Position.w + 1.0) / log2(far + 1.0);","  #endif","  ","  //#if defined(use_logarithmic_depth_buffer)","  //  float logarithmicZ = (2.0 * log2(gl_Position.w + 1.0) / log2(far + 1.0) - 1.0) * gl_Position.w;","  //  gl_Position.z = logarithmicZ;","  //#endif","","  // ---------------------","  // POINT COLOR","  // ---------------------","  ","  #ifdef color_type_rgb","    vColor = color;","  #elif defined color_type_height","    vec4 world = modelMatrix * vec4( position, 1.0 );","    float w = (world.y - heightMin) / (heightMax-heightMin);","    vColor = texture2D(gradient, vec2(w,1.0-w)).rgb;","  #elif defined color_type_depth","    float linearDepth = -mvPosition.z ;","    float expDepth = (gl_Position.z / gl_Position.w) * 0.5 + 0.5;","    vColor = vec3(linearDepth, expDepth, 0.0);","  #elif defined color_type_intensity","    float w = (intensity - intensityMin) / (intensityMax - intensityMin);","    vColor = vec3(w, w, w);","  #elif defined color_type_intensity_gradient","    float w = (intensity - intensityMin) / intensityMax;","    vColor = texture2D(gradient, vec2(w,1.0-w)).rgb;","  #elif defined color_type_color","    vColor = uColor;","  #elif defined color_type_tree_depth","    float depth = getLocalTreeDepth();","    float w = depth / 30.0;","    vColor = texture2D(gradient, vec2(w,1.0-w)).rgb;","  #elif defined color_type_point_index","    vColor = indices.rgb;","  #elif defined color_type_classification","    float c = mod(classification, 16.0);","    vec2 uv = vec2(c / 255.0, 0.5);","    vColor = texture2D(classificationLUT, uv).rgb;","    ","    // TODO only for testing - removing points with class 7","    if(classification == 7.0){","      gl_Position = vec4(100.0, 100.0, 100.0, 0.0);","    }","  #elif defined color_type_return_number","    //float w = (returnNumber - 1.0) / 4.0 + 0.1;","    //vColor = texture2D(gradient, vec2(w, 1.0 - w)).rgb;","    ","    if(numberOfReturns == 1.0){","      vColor = vec3(1.0, 1.0, 0.0);","    }else{","      if(returnNumber == 1.0){","        vColor = vec3(1.0, 0.0, 0.0);","      }else if(returnNumber == numberOfReturns){","        vColor = vec3(0.0, 0.0, 1.0);","      }else{","        vColor = vec3(0.0, 1.0, 0.0);","      }","    }","    ","  #elif defined color_type_source","    float w = mod(pointSourceID, 10.0) / 10.0;","    vColor = texture2D(gradient, vec2(w,1.0 - w)).rgb;","  #elif defined color_type_normal","    vColor = (modelMatrix * vec4(normal, 0.0)).xyz;","  #elif defined color_type_phong","    vColor = color;","  #endif","  ","  //if(vNormal.z < 0.0){","  //  gl_Position = vec4(1000.0, 1000.0, 1000.0, 1.0);","  //}","  ","  // ---------------------","  // POINT SIZE","  // ---------------------","  float pointSize = 1.0;","  ","  float projFactor = 1.0 / tan(fov / 2.0);","  projFactor /= vViewPosition.z;","  projFactor *= screenHeight / 2.0;","  float r = spacing * 1.5;","  vRadius = r;","  #if defined fixed_point_size","    pointSize = size;","  #elif defined attenuated_point_size","    pointSize = size * projFactor;","  #elif defined adaptive_point_size","    float worldSpaceSize = size * r / getPointSizeAttenuation();","    pointSize = worldSpaceSize * projFactor;","  #endif","","  pointSize = max(minSize, pointSize);","  pointSize = min(maxSize, pointSize);","  ","  vRadius = pointSize / projFactor;","  ","  gl_PointSize = pointSize;","  ","  ","  // ---------------------","  // CLIPPING","  // ---------------------","  ","  #if defined use_clip_box","    bool insideAny = false;","    for(int i = 0; i < max_clip_boxes; i++){","      if(i == int(clipBoxCount)){","        break;","      }","    ","      vec4 clipPosition = clipBoxes[i] * modelMatrix * vec4( position, 1.0 );","      bool inside = -0.5 <= clipPosition.x && clipPosition.x <= 0.5;","      inside = inside && -0.5 <= clipPosition.y && clipPosition.y <= 0.5;","      inside = inside && -0.5 <= clipPosition.z && clipPosition.z <= 0.5;","      insideAny = insideAny || inside;","    }","    if(!insideAny){","  ","      #if defined clip_outside","        gl_Position = vec4(1000.0, 1000.0, 1000.0, 1.0);","      #elif defined clip_highlight_inside && !defined(color_type_depth)","        float c = (vColor.r + vColor.g + vColor.b) / 6.0;","      #endif","    }else{","      #if defined clip_highlight_inside","      vColor.r += 0.5;","      #endif","    }","  ","  #endif","  ","}",""].join("\n");Potree.Shaders["pointcloud.fs"]=["","#if defined use_interpolation","  #extension GL_EXT_frag_depth : enable","#endif","","","// the following is an incomplete list of attributes, uniforms and defines","// which are automatically added through the THREE.ShaderMaterial","","// #define USE_COLOR","// ","// uniform mat4 viewMatrix;","// uniform vec3 cameraPosition;","","","uniform mat4 projectionMatrix;","uniform float opacity;","","","#if defined(color_type_phong)","","  uniform vec3 diffuse;","  uniform vec3 ambient;","  uniform vec3 emissive;","  uniform vec3 specular;","  uniform float shininess;","  uniform vec3 ambientLightColor;","","  #if MAX_POINT_LIGHTS > 0","","    uniform vec3  pointLightColor[ MAX_POINT_LIGHTS ];","    uniform vec3  pointLightPosition[ MAX_POINT_LIGHTS ];","    uniform float   pointLightDistance[ MAX_POINT_LIGHTS ];","    uniform float   pointLightDecay[ MAX_POINT_LIGHTS ];","","  #endif","","  #if MAX_DIR_LIGHTS > 0","","    uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];","    uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];","","  #endif","","#endif","","//#if MAX_SPOT_LIGHTS > 0","//","//  uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];","//  uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];","//  uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];","//  uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];","//  uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];","//","//  uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];","//","//#endif","","uniform float fov;","uniform float spacing;","uniform float near;","uniform float far;","uniform float pcIndex;","uniform float screenWidth;","uniform float screenHeight;","","uniform sampler2D depthMap;","","varying vec3  vColor;","varying float vOpacity;","varying float vLinearDepth;","varying float vLogDepth;","varying vec3  vViewPosition;","varying float vRadius;","varying vec3  vWorldPosition;","varying vec3  vNormal;","","float specularStrength = 1.0;","","void main() {","","  vec3 color = vColor;","  float depth = gl_FragCoord.z;","","  #if defined(circle_point_shape) || defined(use_interpolation) || defined (weighted_splats)","    float u = 2.0 * gl_PointCoord.x - 1.0;","    float v = 2.0 * gl_PointCoord.y - 1.0;","  #endif","  ","  #if defined(circle_point_shape) || defined (weighted_splats)","    float cc = u*u + v*v;","    if(cc > 1.0){","      discard;","    }","  #endif","  ","  #if defined weighted_splats","    vec2 uv = gl_FragCoord.xy / vec2(screenWidth, screenHeight);","    float sDepth = texture2D(depthMap, uv).r;","    if(vLinearDepth > sDepth + vRadius){","      discard;","    }","  #endif","  ","  #if defined use_interpolation","    float wi = 0.0 - ( u*u + v*v);","    vec4 pos = vec4(-vViewPosition, 1.0);","    pos.z += wi * vRadius;","    float linearDepth = pos.z;","    pos = projectionMatrix * pos;","    pos = pos / pos.w;","    float expDepth = pos.z;","    depth = (pos.z + 1.0) / 2.0;","    gl_FragDepthEXT = depth;","    ","    #if defined(color_type_depth)","      color.r = linearDepth;","      color.g = expDepth;","    #endif","    ","  #endif","  ","  #if defined color_type_point_index","    gl_FragColor = vec4(color, pcIndex / 255.0);","  #else","    gl_FragColor = vec4(color, vOpacity);","  #endif","  ","  #if defined weighted_splats","      float w = pow(1.0 - (u*u + v*v), 2.0);","    gl_FragColor.rgb = gl_FragColor.rgb * w;","    gl_FragColor.a = w;","  #endif","  ","  vec3 normal = normalize( vNormal );","  normal.z = abs(normal.z);","  vec3 viewPosition = normalize( vViewPosition );","  ","  #if defined(color_type_phong)","","  // code taken from three.js phong light fragment shader","  ","    #if MAX_POINT_LIGHTS > 0","","      vec3 pointDiffuse = vec3( 0.0 );","      vec3 pointSpecular = vec3( 0.0 );","","      for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {","","        vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );","        vec3 lVector = lPosition.xyz + vViewPosition.xyz;","","        float lDistance = 1.0;","        if ( pointLightDistance[ i ] > 0.0 )","          lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );","","        lVector = normalize( lVector );","","            // diffuse","","        float dotProduct = dot( normal, lVector );","","        #ifdef WRAP_AROUND","","          float pointDiffuseWeightFull = max( dotProduct, 0.0 );","          float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );","","          vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );","","        #else","","          float pointDiffuseWeight = max( dotProduct, 0.0 );","","        #endif","","        pointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;","","            // specular","","        vec3 pointHalfVector = normalize( lVector + viewPosition );","        float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );","        float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );","","        float specularNormalization = ( shininess + 2.0 ) / 8.0;","","        vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );","        pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;","        pointSpecular = vec3(0.0, 0.0, 0.0);","      }","    ","    #endif","    ","    #if MAX_DIR_LIGHTS > 0","","      vec3 dirDiffuse = vec3( 0.0 );","      vec3 dirSpecular = vec3( 0.0 );","","      for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {","","        vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );","        vec3 dirVector = normalize( lDirection.xyz );","","            // diffuse","","        float dotProduct = dot( normal, dirVector );","","        #ifdef WRAP_AROUND","","          float dirDiffuseWeightFull = max( dotProduct, 0.0 );","          float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );","","          vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );","","        #else","","          float dirDiffuseWeight = max( dotProduct, 0.0 );","","        #endif","","        dirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;","","        // specular","","        vec3 dirHalfVector = normalize( dirVector + viewPosition );","        float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );","        float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );","","        float specularNormalization = ( shininess + 2.0 ) / 8.0;","","        vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );","        dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;","      }","","    #endif","    ","    vec3 totalDiffuse = vec3( 0.0 );","    vec3 totalSpecular = vec3( 0.0 );","    ","    #if MAX_POINT_LIGHTS > 0","","      totalDiffuse += pointDiffuse;","      totalSpecular += pointSpecular;","","    #endif","    ","    #if MAX_DIR_LIGHTS > 0","","      totalDiffuse += dirDiffuse;","      totalSpecular += dirSpecular;","","    #endif","    ","    gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;","","  #endif","  ","  ","  #if defined(use_edl)","    gl_FragColor.a = vLogDepth;","  #endif","  ","}","","",""].join("\n");Potree.Shaders["normalize.vs"]=["","varying vec2 vUv;","","void main() {","    vUv = uv;","","    gl_Position =   projectionMatrix * modelViewMatrix * vec4(position,1.0);","}"].join("\n");Potree.Shaders["normalize.fs"]=["","#extension GL_EXT_frag_depth : enable","","uniform sampler2D depthMap;","uniform sampler2D texture;","","varying vec2 vUv;","","void main() {","    float depth = texture2D(depthMap, vUv).g; ","  ","  if(depth <= 0.0){","    discard;","  }","  ","    vec4 color = texture2D(texture, vUv); ","  color = color / color.w;","    ","  gl_FragColor = vec4(color.xyz, 1.0); ","  ","  gl_FragDepthEXT = depth;","}"].join("\n");Potree.Shaders["edl.vs"]=["","","varying vec2 vUv;","","void main() {","    vUv = uv;","  ","  vec4 mvPosition = modelViewMatrix * vec4(position,1.0);","","    gl_Position = projectionMatrix * mvPosition;","}"].join("\n");Potree.Shaders["edl.fs"]=["","// ","// adapted from the EDL shader code from Christian Boucheny in cloud compare:","// https://github.com/cloudcompare/trunk/tree/master/plugins/qEDL/shaders/EDL","//","","#define NEIGHBOUR_COUNT 8","","uniform mat4 projectionMatrix;","","uniform float screenWidth;","uniform float screenHeight;","uniform float near;","uniform float far;","uniform vec2 neighbours[NEIGHBOUR_COUNT];","uniform vec3 lightDir;","uniform float expScale;","uniform float radius;","","//uniform sampler2D depthMap;","uniform sampler2D colorMap;","","varying vec2 vUv;","","/**"," * transform linear depth to [0,1] interval with 1 beeing closest to the camera."," */","float ztransform(float linearDepth){","  return 1.0 - (linearDepth - near) / (far - near);","}","","float expToLinear(float z){","    z = 2.0 * z - 1.0;","  float linear = (2.0 * near * far) / (far + near - z * (far - near));","","  return linear;","}","","// this actually only returns linear depth values if LOG_BIAS is 1.0","// lower values work out more nicely, though.","#define LOG_BIAS 0.01","float logToLinear(float z){","  return (pow((1.0 + LOG_BIAS * far), z) - 1.0) / LOG_BIAS;","}","","float obscurance(float z, float dist){","  return max(0.0, z) / dist;","}","","float computeObscurance(float linearDepth){","  vec4 P = vec4(0, 0, 1, -ztransform(linearDepth));","  vec2 uvRadius = radius / vec2(screenWidth, screenHeight);","  ","  float sum = 0.0;","  ","  for(int c = 0; c < NEIGHBOUR_COUNT; c++){","    vec2 N_rel_pos = uvRadius * neighbours[c];","    vec2 N_abs_pos = vUv + N_rel_pos;","    ","    float neighbourDepth = logToLinear(texture2D(colorMap, N_abs_pos).a);","    ","    if(neighbourDepth != 0.0){","      float Zn = ztransform(neighbourDepth);","      float Znp = dot( vec4( N_rel_pos, Zn, 1.0), P );","      ","      sum += obscurance( Znp, 0.05 * linearDepth );","    }","  }","  ","  return sum;","}","","void main(){","  float linearDepth = logToLinear(texture2D(colorMap, vUv).a);","  ","  float f = computeObscurance(linearDepth);","  f = exp(-expScale * f);","  ","  vec4 color = texture2D(colorMap, vUv);","  if(color.a == 0.0 && f >= 1.0){","    discard;","  }","  ","  gl_FragColor = vec4(color.rgb * f, 1.0);","}",""].join("\n");Potree.Shaders["blur.vs"]=["","varying vec2 vUv;","","void main() {","    vUv = uv;","","    gl_Position =   projectionMatrix * modelViewMatrix * vec4(position,1.0);","}"].join("\n");Potree.Shaders["blur.fs"]=["","uniform mat4 projectionMatrix;","","uniform float screenWidth;","uniform float screenHeight;","uniform float near;","uniform float far;","","uniform sampler2D map;","","varying vec2 vUv;","","void main() {","","  float dx = 1.0 / screenWidth;","  float dy = 1.0 / screenHeight;","","  vec3 color = vec3(0.0, 0.0, 0.0);","  color += texture2D(map, vUv + vec2(-dx, -dy)).rgb;","  color += texture2D(map, vUv + vec2(  0, -dy)).rgb;","  color += texture2D(map, vUv + vec2(+dx, -dy)).rgb;","  color += texture2D(map, vUv + vec2(-dx,   0)).rgb;","  color += texture2D(map, vUv + vec2(  0,   0)).rgb;","  color += texture2D(map, vUv + vec2(+dx,   0)).rgb;","  color += texture2D(map, vUv + vec2(-dx,  dy)).rgb;","  color += texture2D(map, vUv + vec2(  0,  dy)).rgb;","  color += texture2D(map, vUv + vec2(+dx,  dy)).rgb;","    ","  color = color / 9.0;","  ","  gl_FragColor = vec4(color, 1.0);","  ","  ","}"].join("\n");_three2.default.PerspectiveCamera.prototype.zoomTo=function(node,factor){if(!node.geometry&&!node.boundingSphere){return;}if(node.geometry&&node.geometry.boundingSphere===null){node.geometry.computeBoundingSphere();}node.updateMatrixWorld();var _factor=factor||1;var bs=node.boundingSphere||node.geometry.boundingSphere;bs=bs.clone().applyMatrix4(node.matrixWorld);var radius=bs.radius;var fovr=this.fov*Math.PI/180;if(this.aspect<1){fovr=fovr*this.aspect;}var distanceFactor=Math.abs(radius/Math.sin(fovr/2))*_factor;var dir=new _three2.default.Vector3(0,0,-1).applyQuaternion(this.quaternion);var offset=dir.multiplyScalar(-distanceFactor);this.position.copy(bs.center.clone().add(offset));}; //THREE.PerspectiveCamera.prototype.zoomTo = function(node, factor){
	//  if(factor === undefined){
	//    factor = 1;
	//  }
	//
	//  node.updateMatrixWorld();
	//  this.updateMatrix();
	//  this.updateMatrixWorld();
	//  
	//  var box = Potree.utils.computeTransformedBoundingBox(node.boundingBox, node.matrixWorld);
	//  var dir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.quaternion);
	//  var pos = box.center().sub(dir);
	//  
	//  var ps = [
	//    new THREE.Vector3(box.min.x, box.min.y, box.min.z),
	//    new THREE.Vector3(box.min.x, box.min.y, box.min.z),
	//    new THREE.Vector3(box.max.x, box.min.y, box.min.z),
	//    new THREE.Vector3(box.min.x, box.max.y, box.min.z),
	//    new THREE.Vector3(box.min.x, box.min.y, box.max.z),
	//    new THREE.Vector3(box.min.x, box.max.y, box.max.z),
	//    new THREE.Vector3(box.max.x, box.max.y, box.min.z),
	//    new THREE.Vector3(box.max.x, box.min.y, box.max.z),
	//    new THREE.Vector3(box.max.x, box.max.y, box.max.z)
	//  ];
	//  
	//  var frustum = new THREE.Frustum();
	//  frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(this.projectionMatrix, this.matrixWorldInverse));
	//  
	//  var max = Number.MIN_VALUE;
	//  for(var i = 0; i < ps.length; i++){
	//    var p  = ps[i];
	//    
	//    var distance = Number.MIN_VALUE;
	//    // iterate through left, right, top and bottom planes
	//    for(var j = 0; j < frustum.planes.length-2; j++){
	//      var plane = frustum.planes[j];
	//      var ray = new THREE.Ray(p, dir);
	//      var dI = ray.distanceToPlaneWithNegative(plane);
	//      distance = Math.max(distance, dI);
	//    }
	//    max = Math.max(max, distance);
	//  }
	//  var offset = dir.clone().multiplyScalar(-max);
	//  offset.multiplyScalar(factor);
	//  pos.add(offset);
	//  this.position.copy(pos);
	//  
	//}
	_three2.default.Ray.prototype.distanceToPlaneWithNegative=function(plane){var denominator=plane.normal.dot(this.direction);if(denominator==0){ // line is coplanar, return origin
	if(plane.distanceToPoint(this.origin)==0){return 0;} // Null is preferable to undefined since undefined means.... it is undefined
	return null;}var t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;return t;}; /**
	 * @class Loads mno files and returns a PointcloudOctree
	 * for a description of the mno binary file format, read mnoFileFormat.txt
	 * 
	 * @author Markus Schuetz
	 */Potree.POCLoader=function(){}; /**
	 * @return a point cloud octree with the root node data loaded. 
	 * loading of descendants happens asynchronously when they're needed
	 * 
	 * @param url
	 * @param loadingFinishedListener executed after loading the binary has been finished
	 */Potree.POCLoader.load=function load(url,callback){try{var pco=new Potree.PointCloudOctreeGeometry();pco.url=url;var xhr=new XMLHttpRequest();xhr.open('GET',url,true);xhr.onreadystatechange=function(){if(xhr.readyState===4&&(xhr.status===200||xhr.status===0)){var fMno=JSON.parse(xhr.responseText);var version=new Potree.Version(fMno.version); // assume octreeDir is absolute if it starts with http
	if(fMno.octreeDir.indexOf("http")===0){pco.octreeDir=fMno.octreeDir;}else {pco.octreeDir=url+"/../"+fMno.octreeDir;}pco.spacing=fMno.spacing;pco.hierarchyStepSize=fMno.hierarchyStepSize;pco.pointAttributes=fMno.pointAttributes;var min=new _three2.default.Vector3(fMno.boundingBox.lx,fMno.boundingBox.ly,fMno.boundingBox.lz);var max=new _three2.default.Vector3(fMno.boundingBox.ux,fMno.boundingBox.uy,fMno.boundingBox.uz);var boundingBox=new _three2.default.Box3(min,max);var tightBoundingBox=boundingBox.clone();if(fMno.tightBoundingBox){tightBoundingBox.min.copy(new _three2.default.Vector3(fMno.tightBoundingBox.lx,fMno.tightBoundingBox.ly,fMno.tightBoundingBox.lz));tightBoundingBox.max.copy(new _three2.default.Vector3(fMno.tightBoundingBox.ux,fMno.tightBoundingBox.uy,fMno.tightBoundingBox.uz));}var offset=new _three2.default.Vector3(0,0,0);offset.set(-min.x,-min.y,-min.z);boundingBox.min.add(offset);boundingBox.max.add(offset);tightBoundingBox.min.add(offset);tightBoundingBox.max.add(offset);pco.boundingBox=boundingBox;pco.tightBoundingBox=tightBoundingBox;pco.boundingSphere=boundingBox.getBoundingSphere();pco.tightBoundingSphere=tightBoundingBox.getBoundingSphere();pco.offset=offset;if(fMno.pointAttributes==="LAS"){pco.loader=new Potree.LasLazLoader(fMno.version);}else if(fMno.pointAttributes==="LAZ"){pco.loader=new Potree.LasLazLoader(fMno.version);}else {pco.loader=new Potree.BinaryLoader(fMno.version,boundingBox,fMno.scale);pco.pointAttributes=new Potree.PointAttributes(pco.pointAttributes);}var nodes={};{ // load root
	var name="r";var root=new Potree.PointCloudOctreeGeometryNode(name,pco,boundingBox);root.level=0;root.hasChildren=true;if(version.upTo("1.5")){root.numPoints=fMno.hierarchy[0][1];}else {root.numPoints=0;}pco.root=root;pco.root.load();nodes[name]=root;} // load remaining hierarchy
	if(version.upTo("1.4")){for(var i=1;i<fMno.hierarchy.length;i++){var name=fMno.hierarchy[i][0];var numPoints=fMno.hierarchy[i][1];var index=parseInt(name.charAt(name.length-1));var parentName=name.substring(0,name.length-1);var parentNode=nodes[parentName];var level=name.length-1;var boundingBox=Potree.POCLoader.createChildAABB(parentNode.boundingBox,index);var node=new Potree.PointCloudOctreeGeometryNode(name,pco,boundingBox);node.level=level;node.numPoints=numPoints;parentNode.addChild(node);nodes[name]=node;}}pco.nodes=nodes;callback(pco);}};xhr.send(null);}catch(e){console.log("loading failed: '"+url+"'");console.log(e);}};Potree.POCLoader.loadPointAttributes=function(mno){var fpa=mno.pointAttributes;var pa=new Potree.PointAttributes();for(var i=0;i<fpa.length;i++){var pointAttribute=Potree.PointAttribute[fpa[i]];pa.add(pointAttribute);}return pa;};Potree.POCLoader.createChildAABB=function(aabb,childIndex){var V3=_three2.default.Vector3;var min=aabb.min;var max=aabb.max;var dHalfLength=new _three2.default.Vector3().copy(max).sub(min).multiplyScalar(0.5);var xHalfLength=new _three2.default.Vector3(dHalfLength.x,0,0);var yHalfLength=new _three2.default.Vector3(0,dHalfLength.y,0);var zHalfLength=new _three2.default.Vector3(0,0,dHalfLength.z);var cmin=min;var cmax=new _three2.default.Vector3().add(min).add(dHalfLength);var min,max;if(childIndex===1){min=new _three2.default.Vector3().copy(cmin).add(zHalfLength);max=new _three2.default.Vector3().copy(cmax).add(zHalfLength);}else if(childIndex===3){min=new _three2.default.Vector3().copy(cmin).add(zHalfLength).add(yHalfLength);max=new _three2.default.Vector3().copy(cmax).add(zHalfLength).add(yHalfLength);}else if(childIndex===0){min=cmin;max=cmax;}else if(childIndex===2){min=new _three2.default.Vector3().copy(cmin).add(yHalfLength);max=new _three2.default.Vector3().copy(cmax).add(yHalfLength);}else if(childIndex===5){min=new _three2.default.Vector3().copy(cmin).add(zHalfLength).add(xHalfLength);max=new _three2.default.Vector3().copy(cmax).add(zHalfLength).add(xHalfLength);}else if(childIndex===7){min=new _three2.default.Vector3().copy(cmin).add(dHalfLength);max=new _three2.default.Vector3().copy(cmax).add(dHalfLength);}else if(childIndex===4){min=new _three2.default.Vector3().copy(cmin).add(xHalfLength);max=new _three2.default.Vector3().copy(cmax).add(xHalfLength);}else if(childIndex===6){min=new _three2.default.Vector3().copy(cmin).add(xHalfLength).add(yHalfLength);max=new _three2.default.Vector3().copy(cmax).add(xHalfLength).add(yHalfLength);}return new _three2.default.Box3(min,max);};Potree.PointAttributeNames={};Potree.PointAttributeNames.POSITION_CARTESIAN=0; // float x, y, z;
	Potree.PointAttributeNames.COLOR_PACKED=1; // byte r, g, b, a;   I = [0,1]
	Potree.PointAttributeNames.COLOR_FLOATS_1=2; // float r, g, b;     I = [0,1]
	Potree.PointAttributeNames.COLOR_FLOATS_255=3; // float r, g, b;     I = [0,255]
	Potree.PointAttributeNames.NORMAL_FLOATS=4; // float x, y, z;
	Potree.PointAttributeNames.FILLER=5;Potree.PointAttributeNames.INTENSITY=6;Potree.PointAttributeNames.CLASSIFICATION=7;Potree.PointAttributeNames.NORMAL_SPHEREMAPPED=8;Potree.PointAttributeNames.NORMAL_OCT16=9;Potree.PointAttributeNames.NORMAL=10; /**
	 * Some types of possible point attribute data formats
	 * 
	 * @class
	 */Potree.PointAttributeTypes={DATA_TYPE_DOUBLE:{ordinal:0,size:8},DATA_TYPE_FLOAT:{ordinal:1,size:4},DATA_TYPE_INT8:{ordinal:2,size:1},DATA_TYPE_UINT8:{ordinal:3,size:1},DATA_TYPE_INT16:{ordinal:4,size:2},DATA_TYPE_UINT16:{ordinal:5,size:2},DATA_TYPE_INT32:{ordinal:6,size:4},DATA_TYPE_UINT32:{ordinal:7,size:4},DATA_TYPE_INT64:{ordinal:8,size:8},DATA_TYPE_UINT64:{ordinal:9,size:8}};var i=0;for(var obj in Potree.PointAttributeTypes){Potree.PointAttributeTypes[i]=Potree.PointAttributeTypes[obj];i++;} /**
	 * A single point attribute such as color/normal/.. and its data format/number of elements/... 
	 * 
	 * @class
	 * @param name 
	 * @param type
	 * @param size
	 * @returns
	 */Potree.PointAttribute=function(name,type,numElements){this.name=name;this.type=type;this.numElements=numElements;this.byteSize=this.numElements*this.type.size;};Potree.PointAttribute.POSITION_CARTESIAN=new Potree.PointAttribute(Potree.PointAttributeNames.POSITION_CARTESIAN,Potree.PointAttributeTypes.DATA_TYPE_FLOAT,3);Potree.PointAttribute.RGBA_PACKED=new Potree.PointAttribute(Potree.PointAttributeNames.COLOR_PACKED,Potree.PointAttributeTypes.DATA_TYPE_INT8,4);Potree.PointAttribute.COLOR_PACKED=Potree.PointAttribute.RGBA_PACKED;Potree.PointAttribute.RGB_PACKED=new Potree.PointAttribute(Potree.PointAttributeNames.COLOR_PACKED,Potree.PointAttributeTypes.DATA_TYPE_INT8,3);Potree.PointAttribute.NORMAL_FLOATS=new Potree.PointAttribute(Potree.PointAttributeNames.NORMAL_FLOATS,Potree.PointAttributeTypes.DATA_TYPE_FLOAT,3);Potree.PointAttribute.FILLER_1B=new Potree.PointAttribute(Potree.PointAttributeNames.FILLER,Potree.PointAttributeTypes.DATA_TYPE_UINT8,1);Potree.PointAttribute.INTENSITY=new Potree.PointAttribute(Potree.PointAttributeNames.INTENSITY,Potree.PointAttributeTypes.DATA_TYPE_UINT16,1);Potree.PointAttribute.CLASSIFICATION=new Potree.PointAttribute(Potree.PointAttributeNames.CLASSIFICATION,Potree.PointAttributeTypes.DATA_TYPE_UINT8,1);Potree.PointAttribute.NORMAL_SPHEREMAPPED=new Potree.PointAttribute(Potree.PointAttributeNames.NORMAL_SPHEREMAPPED,Potree.PointAttributeTypes.DATA_TYPE_UINT8,2);Potree.PointAttribute.NORMAL_OCT16=new Potree.PointAttribute(Potree.PointAttributeNames.NORMAL_OCT16,Potree.PointAttributeTypes.DATA_TYPE_UINT8,2);Potree.PointAttribute.NORMAL=new Potree.PointAttribute(Potree.PointAttributeNames.NORMAL,Potree.PointAttributeTypes.DATA_TYPE_FLOAT,3); /**
	 * Ordered list of PointAttributes used to identify how points are aligned in a buffer.
	 * 
	 * @class
	 * 
	 */Potree.PointAttributes=function(pointAttributes){this.attributes=new Array();this.byteSize=0;this.size=0;if(pointAttributes!=null){for(var i=0;i<pointAttributes.length;i++){var pointAttributeName=pointAttributes[i];var pointAttribute=Potree.PointAttribute[pointAttributeName];this.attributes.push(pointAttribute);this.byteSize+=pointAttribute.byteSize;this.size++;}}};Potree.PointAttributes.prototype.add=function(pointAttribute){this.attributes.push(pointAttribute);this.byteSize+=pointAttribute.byteSize;this.size++;};Potree.PointAttributes.prototype.hasColors=function(){for(var name in this.attributes){var pointAttribute=this.attributes[name];if(pointAttribute.name===Potree.PointAttributeNames.COLOR_PACKED){return true;}}return false;};Potree.PointAttributes.prototype.hasNormals=function(){for(var name in this.attributes){var pointAttribute=this.attributes[name];if(pointAttribute===Potree.PointAttribute.NORMAL_SPHEREMAPPED||pointAttribute===Potree.PointAttribute.NORMAL_FLOATS||pointAttribute===Potree.PointAttribute.NORMAL||pointAttribute===Potree.PointAttribute.NORMAL_OCT16){return true;}}return false;};Potree.BinaryLoader=function(version,boundingBox,scale){if(typeof version==="string"){this.version=new Potree.Version(version);}else {this.version=version;}this.boundingBox=boundingBox;this.scale=scale;};Potree.BinaryLoader.prototype.load=function(node){if(node.loaded){return;}var scope=this;var url=node.getURL();if(this.version.equalOrHigher("1.4")){url+=".bin";}var xhr=new XMLHttpRequest();xhr.open('GET',url,true);xhr.responseType='arraybuffer';xhr.overrideMimeType('text/plain; charset=x-user-defined');xhr.onreadystatechange=function(){if(xhr.readyState===4){if(xhr.status===200||xhr.status===0){var buffer=xhr.response;scope.parse(node,buffer);}else {console.log('Failed to load file! HTTP status: '+xhr.status+", file: "+url);}}};try{xhr.send(null);}catch(e){console.log("fehler beim laden der punktwolke: "+e);}};Potree.BinaryLoader.prototype.parse=function(node,buffer){var numPoints=buffer.byteLength/node.pcoGeometry.pointAttributes.byteSize;var pointAttributes=node.pcoGeometry.pointAttributes;if(this.version.upTo("1.5")){node.numPoints=numPoints;}var ww=Potree.workers.binaryDecoder.getWorker();ww.onmessage=function(e){var data=e.data;var buffers=data.attributeBuffers;var tightBoundingBox=new _three2.default.Box3(new _three2.default.Vector3().fromArray(data.tightBoundingBox.min),new _three2.default.Vector3().fromArray(data.tightBoundingBox.max));Potree.workers.binaryDecoder.returnWorker(ww);var geometry=new _three2.default.BufferGeometry();for(var property in buffers){if(buffers.hasOwnProperty(property)){var buffer=buffers[property].buffer;var attribute=buffers[property].attribute;var numElements=attribute.numElements;if(parseInt(property)===Potree.PointAttributeNames.POSITION_CARTESIAN){geometry.addAttribute("position",new _three2.default.BufferAttribute(new Float32Array(buffer),3));}else if(parseInt(property)===Potree.PointAttributeNames.COLOR_PACKED){geometry.addAttribute("color",new _three2.default.BufferAttribute(new Float32Array(buffer),3));}else if(parseInt(property)===Potree.PointAttributeNames.INTENSITY){geometry.addAttribute("intensity",new _three2.default.BufferAttribute(new Float32Array(buffer),1));}else if(parseInt(property)===Potree.PointAttributeNames.CLASSIFICATION){geometry.addAttribute("classification",new _three2.default.BufferAttribute(new Float32Array(buffer),1));}else if(parseInt(property)===Potree.PointAttributeNames.NORMAL_SPHEREMAPPED){geometry.addAttribute("normal",new _three2.default.BufferAttribute(new Float32Array(buffer),3));}else if(parseInt(property)===Potree.PointAttributeNames.NORMAL_OCT16){geometry.addAttribute("normal",new _three2.default.BufferAttribute(new Float32Array(buffer),3));}else if(parseInt(property)===Potree.PointAttributeNames.NORMAL){geometry.addAttribute("normal",new _three2.default.BufferAttribute(new Float32Array(buffer),3));}}}geometry.addAttribute("indices",new _three2.default.BufferAttribute(new Float32Array(data.indices),1));if(!geometry.attributes.normal){var buffer=new Float32Array(numPoints*3);geometry.addAttribute("normal",new _three2.default.BufferAttribute(new Float32Array(buffer),3));}geometry.boundingBox=node.boundingBox; //geometry.boundingBox = tightBoundingBox;
	node.geometry=geometry; //node.boundingBox = tightBoundingBox;
	node.tightBoundingBox=tightBoundingBox;node.loaded=true;node.loading=false;node.pcoGeometry.numNodesLoading--;};var message={buffer:buffer,pointAttributes:pointAttributes,version:this.version.version,min:[node.boundingBox.min.x,node.boundingBox.min.y,node.boundingBox.min.z],offset:[node.pcoGeometry.offset.x,node.pcoGeometry.offset.y,node.pcoGeometry.offset.z],scale:this.scale};ww.postMessage(message,[message.buffer]);}; /**
	 * laslaz code taken and adapted from plas.io js-laslaz
	 *  http://plas.io/
	 *  https://github.com/verma/plasio
	 *
	 * Thanks to Uday Verma and Howard Butler
	 *
	 */Potree.LasLazLoader=function(version){if(typeof version==="string"){this.version=new Potree.Version(version);}else {this.version=version;}};Potree.LasLazLoader.prototype.load=function(node){if(node.loaded){return;} //var url = node.pcoGeometry.octreeDir + "/" + node.name;
	var pointAttributes=node.pcoGeometry.pointAttributes; //var url = node.pcoGeometry.octreeDir + "/" + node.name + "." + pointAttributes.toLowerCase()
	var url=node.getURL();if(this.version.equalOrHigher("1.4")){url+="."+pointAttributes.toLowerCase();}var scope=this;var xhr=new XMLHttpRequest();xhr.open('GET',url,true);xhr.responseType='arraybuffer';xhr.overrideMimeType('text/plain; charset=x-user-defined');xhr.onreadystatechange=function(){if(xhr.readyState===4){if(xhr.status===200){var buffer=xhr.response; //LasLazLoader.loadData(buffer, handler);
	scope.parse(node,buffer);}else {console.log('Failed to load file! HTTP status: '+xhr.status+", file: "+url);}}};xhr.send(null);};Potree.LasLazLoader.progressCB=function(arg){};Potree.LasLazLoader.prototype.parse=function loadData(node,buffer){var lf=new LASFile(buffer);var handler=new Potree.LasLazBatcher(node);return Promise.resolve(lf).cancellable().then(function(lf){return lf.open().then(function(){lf.isOpen=true;return lf;}).catch(Promise.CancellationError,function(e){ // open message was sent at this point, but then handler was not called
	// because the operation was cancelled, explicitly close the file
	return lf.close().then(function(){throw e;});});}).then(function(lf){return lf.getHeader().then(function(h){return [lf,h];});}).then(function(v){var lf=v[0];var header=v[1];var skip=1;var totalRead=0;var totalToRead=skip<=1?header.pointsCount:header.pointsCount/skip;var reader=function reader(){var p=lf.readData(1000000,0,skip);return p.then(function(data){handler.push(new LASDecoder(data.buffer,header.pointsFormatId,header.pointsStructSize,data.count,header.scale,header.offset,header.mins,header.maxs));totalRead+=data.count;Potree.LasLazLoader.progressCB(totalRead/totalToRead);if(data.hasMoreData)return reader();else {header.totalRead=totalRead;header.versionAsString=lf.versionAsString;header.isCompressed=lf.isCompressed;return [lf,header,handler];}});};return reader();}).then(function(v){var lf=v[0]; // we're done loading this file
	//
	Potree.LasLazLoader.progressCB(1); // Close it
	return lf.close().then(function(){lf.isOpen=false; // Delay this a bit so that the user sees 100% completion
	//
	return Promise.delay(200).cancellable();}).then(function(){ // trim off the first element (our LASFile which we don't really want to pass to the user)
	//
	return v.slice(1);});}).catch(Promise.CancellationError,function(e){ // If there was a cancellation, make sure the file is closed, if the file is open
	// close and then fail
	if(lf.isOpen)return lf.close().then(function(){lf.isOpen=false;throw e;});throw e;});};Potree.LasLazLoader.prototype.handle=function(node,url){};Potree.LasLazBatcher=function(node){this.push=function(lasBuffer){var ww=Potree.workers.lasdecoder.getWorker();var mins=new _three2.default.Vector3(lasBuffer.mins[0],lasBuffer.mins[1],lasBuffer.mins[2]);var maxs=new _three2.default.Vector3(lasBuffer.maxs[0],lasBuffer.maxs[1],lasBuffer.maxs[2]);mins.add(node.pcoGeometry.offset);maxs.add(node.pcoGeometry.offset);ww.onmessage=function(e){var geometry=new _three2.default.BufferGeometry();var numPoints=lasBuffer.pointsCount;var endsWith=function endsWith(str,suffix){return str.indexOf(suffix,str.length-suffix.length)!==-1;};var positions=e.data.position;var colors=e.data.color;var intensities=e.data.intensity;var classifications=new Uint8Array(e.data.classification);var classifications_f=new Float32Array(classifications.byteLength);var returnNumbers=new Uint8Array(e.data.returnNumber);var numberOfReturns=new Uint8Array(e.data.numberOfReturns);var returnNumbers_f=new Float32Array(returnNumbers.byteLength);var numberOfReturns_f=new Float32Array(numberOfReturns.byteLength);var pointSourceIDs=new Uint16Array(e.data.pointSourceID);var pointSourceIDs_f=new Float32Array(pointSourceIDs.length);var indices=new ArrayBuffer(numPoints*4);var iIndices=new Uint32Array(indices);var box=new _three2.default.Box3();var fPositions=new Float32Array(positions);for(var i=0;i<numPoints;i++){classifications_f[i]=classifications[i];returnNumbers_f[i]=returnNumbers[i];numberOfReturns_f[i]=numberOfReturns[i];pointSourceIDs_f[i]=pointSourceIDs[i];iIndices[i]=i;box.expandByPoint(new _three2.default.Vector3(fPositions[3*i+0],fPositions[3*i+1],fPositions[3*i+2]));}geometry.addAttribute('position',new _three2.default.BufferAttribute(new Float32Array(positions),3));geometry.addAttribute('color',new _three2.default.BufferAttribute(new Float32Array(colors),3));geometry.addAttribute('intensity',new _three2.default.BufferAttribute(new Float32Array(intensities),1));geometry.addAttribute('classification',new _three2.default.BufferAttribute(new Float32Array(classifications_f),1));geometry.addAttribute('returnNumber',new _three2.default.BufferAttribute(new Float32Array(returnNumbers_f),1));geometry.addAttribute('numberOfReturns',new _three2.default.BufferAttribute(new Float32Array(numberOfReturns_f),1));geometry.addAttribute('pointSourceID',new _three2.default.BufferAttribute(new Float32Array(pointSourceIDs_f),1));geometry.addAttribute('indices',new _three2.default.BufferAttribute(indices,1));geometry.addAttribute("normal",new _three2.default.BufferAttribute(new Float32Array(numPoints*3),3));var tightBoundingBox=new _three2.default.Box3(new _three2.default.Vector3().fromArray(e.data.tightBoundingBox.min),new _three2.default.Vector3().fromArray(e.data.tightBoundingBox.max));geometry.boundingBox=new _three2.default.Box3(mins,maxs); //geometry.boundingBox = tightBoundingBox;
	//node.boundingBox = geometry.boundingBox;
	node.tightBoundingBox=tightBoundingBox;node.geometry=geometry;node.loaded=true;node.loading=false;node.pcoGeometry.numNodesLoading--;Potree.workers.lasdecoder.returnWorker(ww);};var message={buffer:lasBuffer.arrayb,numPoints:lasBuffer.pointsCount,pointSize:lasBuffer.pointSize,pointFormatID:2,scale:lasBuffer.scale,offset:lasBuffer.offset,mins:[node.pcoGeometry.boundingBox.min.x,node.pcoGeometry.boundingBox.min.y,node.pcoGeometry.boundingBox.min.z],maxs:[node.pcoGeometry.boundingBox.max.x,node.pcoGeometry.boundingBox.max.y,node.pcoGeometry.boundingBox.max.z],bbOffset:[node.pcoGeometry.offset.x,node.pcoGeometry.offset.y,node.pcoGeometry.offset.z]};ww.postMessage(message,[message.buffer]);};}; //
	//
	//
	// how to calculate the radius of a projected sphere in screen space
	// http://stackoverflow.com/questions/21648630/radius-of-projected-sphere-in-screen-space
	// http://stackoverflow.com/questions/3717226/radius-of-projected-sphere
	//
	Potree.Gradients={RAINBOW:[[0,new _three2.default.Color(0.278,0,0.714)],[1/6,new _three2.default.Color(0,0,1)],[2/6,new _three2.default.Color(0,1,1)],[3/6,new _three2.default.Color(0,1,0)],[4/6,new _three2.default.Color(1,1,0)],[5/6,new _three2.default.Color(1,0.64,0)],[1,new _three2.default.Color(1,0,0)]],GRAYSCALE:[[0,new _three2.default.Color(0,0,0)],[1,new _three2.default.Color(1,1,1)]]};Potree.Classification={"DEFAULT":{0:new _three2.default.Color(0.5,0.5,0.5),1:new _three2.default.Color(0.5,0.5,0.5),2:new _three2.default.Color(0.63,0.32,0.18),3:new _three2.default.Color(0.0,1.0,0.0),4:new _three2.default.Color(0.0,0.8,0.0),5:new _three2.default.Color(0.0,0.6,0.0),6:new _three2.default.Color(1.0,0.66,0.0),7:new _three2.default.Color(1.0,0,1.0),8:new _three2.default.Color(1.0,0,0.0),9:new _three2.default.Color(0.0,0.0,1.0),12:new _three2.default.Color(1.0,1.0,0.0),"DEFAULT":new _three2.default.Color(0.3,0.6,0.6)}};Potree.PointSizeType={FIXED:0,ATTENUATED:1,ADAPTIVE:2};Potree.PointShape={SQUARE:0,CIRCLE:1};Potree.PointColorType=_defineProperty({RGB:0,COLOR:1,DEPTH:2,HEIGHT:3,INTENSITY:4,INTENSITY_GRADIENT:5,TREE_DEPTH:6,POINT_INDEX:7,CLASSIFICATION:8,RETURN_NUMBER:9,SOURCE:10,NORMAL:11,PHONG:12},'TREE_DEPTH',13);Potree.ClipMode={DISABLED:0,CLIP_OUTSIDE:1,HIGHLIGHT_INSIDE:2};Potree.TreeType={OCTREE:0,KDTREE:1};Potree.PointCloudMaterial=function(parameters){_three2.default.Material.call(this);parameters=parameters||{};var color=new _three2.default.Color(0xffffff);var map=_three2.default.ImageUtils.generateDataTexture(2048,1,color);map.magFilter=_three2.default.NearestFilter;this.visibleNodesTexture=map;var pointSize=parameters.size||1.0;var minSize=parameters.minSize||1.0;var maxSize=parameters.maxSize||50.0;var treeType=parameters.treeType||Potree.TreeType.OCTREE;var nodeSize=1.0;this._pointSizeType=Potree.PointSizeType.ATTENUATED;this._pointShape=Potree.PointShape.SQUARE;this._interpolate=false;this._pointColorType=Potree.PointColorType.RGB;this._useClipBox=false;this.numClipBoxes=0;this._clipMode=Potree.ClipMode.DISABLED;this._weighted=false;this._depthMap;this._gradient=Potree.Gradients.RAINBOW;this._classification=Potree.Classification.DEFAULT;this.gradientTexture=Potree.PointCloudMaterial.generateGradientTexture(this._gradient);this.classificationTexture=Potree.PointCloudMaterial.generateClassificationTexture(this._classification);this.lights=true;this._treeType=treeType;this._useLogarithmicDepthBuffer=false;this._useEDL=false;var attributes={};var uniforms={spacing:{type:"f",value:1.0},fov:{type:"f",value:1.0},screenWidth:{type:"f",value:1.0},screenHeight:{type:"f",value:1.0},near:{type:"f",value:0.1},far:{type:"f",value:1.0},uColor:{type:"c",value:new _three2.default.Color(0xffffff)},opacity:{type:"f",value:1.0},size:{type:"f",value:10},minSize:{type:"f",value:2},maxSize:{type:"f",value:2},octreeSize:{type:"f",value:0},bbSize:{type:"fv",value:[0,0,0]},heightMin:{type:"f",value:0.0},heightMax:{type:"f",value:1.0},intensityMin:{type:"f",value:0.0},intensityMax:{type:"f",value:1.0},clipBoxCount:{type:"f",value:0},visibleNodes:{type:"t",value:this.visibleNodesTexture},pcIndex:{type:"f",value:0},gradient:{type:"t",value:this.gradientTexture},classificationLUT:{type:"t",value:this.classificationTexture},clipBoxes:{type:"Matrix4fv",value:[]},depthMap:{type:"t",value:null},diffuse:{type:"fv",value:[1,1,1]},ambient:{type:"fv",value:[0.1,0.1,0.1]},ambientLightColor:{type:"fv",value:[1,1,1]},directionalLightColor:{type:"fv",value:null},directionalLightDirection:{type:"fv",value:null},pointLightColor:{type:"fv",value:null},pointLightPosition:{type:"fv",value:null},pointLightDistance:{type:"fv1",value:null},pointLightDecay:{type:"fv1",value:null},spotLightColor:{type:"fv",value:null},spotLightPosition:{type:"fv",value:null},spotLightDistance:{type:"fv1",value:null},spotLightDecay:{type:"fv1",value:null},spotLightDirection:{type:"fv",value:null},spotLightAngleCos:{type:"fv1",value:null},spotLightExponent:{type:"fv1",value:null},hemisphereLightSkyColor:{type:"fv",value:null},hemisphereLightGroundColor:{type:"fv",value:null},hemisphereLightDirection:{type:"fv",value:null}};this.defaultAttributeValues.normal=[0,0,0];this.setValues({uniforms:uniforms,attributes:attributes,vertexShader:this.getDefines()+Potree.Shaders["pointcloud.vs"],fragmentShader:this.getDefines()+Potree.Shaders["pointcloud.fs"],vertexColors:_three2.default.VertexColors,size:pointSize,minSize:minSize,maxSize:maxSize,nodeSize:nodeSize,pcIndex:0,alphaTest:0.9});};Potree.PointCloudMaterial.prototype=new _three2.default.ShaderMaterial();Potree.PointCloudMaterial.prototype.updateShaderSource=function(){var attributes={};if(this.pointColorType===Potree.PointColorType.INTENSITY||this.pointColorType===Potree.PointColorType.INTENSITY_GRADIENT){attributes.intensity={type:"f",value:[]};}else if(this.pointColorType===Potree.PointColorType.CLASSIFICATION){attributes.classification={type:"f",value:[]};}else if(this.pointColorType===Potree.PointColorType.RETURN_NUMBER){attributes.returnNumber={type:"f",value:[]};attributes.numberOfReturns={type:"f",value:[]};}else if(this.pointColorType===Potree.PointColorType.SOURCE){attributes.pointSourceID={type:"f",value:[]};}else if(this.pointColorType===Potree.PointColorType.NORMAL||this.pointColorType===Potree.PointColorType.PHONG){attributes.normal={type:"f",value:[]};}var vs=this.getDefines()+Potree.Shaders["pointcloud.vs"];var fs=this.getDefines()+Potree.Shaders["pointcloud.fs"];this.setValues({attributes:attributes,vertexShader:vs,fragmentShader:fs});if(this.depthMap){this.uniforms.depthMap.value=this.depthMap;this.setValues({depthMap:this.depthMap});}if(this.opacity===1.0){this.setValues({blending:_three2.default.NoBlending,transparent:false,depthTest:true,depthWrite:true});}else {this.setValues({blending:_three2.default.AdditiveBlending,transparent:true,depthTest:false,depthWrite:true});}if(this.weighted){this.setValues({blending:_three2.default.AdditiveBlending,transparent:true,depthTest:true,depthWrite:false});}this.needsUpdate=true;};Potree.PointCloudMaterial.prototype.getDefines=function(){var defines="";if(this.pointSizeType===Potree.PointSizeType.FIXED){defines+="#define fixed_point_size\n";}else if(this.pointSizeType===Potree.PointSizeType.ATTENUATED){defines+="#define attenuated_point_size\n";}else if(this.pointSizeType===Potree.PointSizeType.ADAPTIVE){defines+="#define adaptive_point_size\n";}if(this.pointShape===Potree.PointShape.SQUARE){defines+="#define square_point_shape\n";}else if(this.pointShape===Potree.PointShape.CIRCLE){defines+="#define circle_point_shape\n";}if(this._interpolate){defines+="#define use_interpolation\n";}if(this._useLogarithmicDepthBuffer){defines+="#define use_logarithmic_depth_buffer\n";}if(this._useEDL){defines+="#define use_edl\n";}if(this._pointColorType===Potree.PointColorType.RGB){defines+="#define color_type_rgb\n";}else if(this._pointColorType===Potree.PointColorType.COLOR){defines+="#define color_type_color\n";}else if(this._pointColorType===Potree.PointColorType.DEPTH){defines+="#define color_type_depth\n";}else if(this._pointColorType===Potree.PointColorType.HEIGHT){defines+="#define color_type_height\n";}else if(this._pointColorType===Potree.PointColorType.INTENSITY){defines+="#define color_type_intensity\n";}else if(this._pointColorType===Potree.PointColorType.INTENSITY_GRADIENT){defines+="#define color_type_intensity_gradient\n";}else if(this._pointColorType===Potree.PointColorType.TREE_DEPTH){defines+="#define color_type_tree_depth\n";}else if(this._pointColorType===Potree.PointColorType.POINT_INDEX){defines+="#define color_type_point_index\n";}else if(this._pointColorType===Potree.PointColorType.CLASSIFICATION){defines+="#define color_type_classification\n";}else if(this._pointColorType===Potree.PointColorType.RETURN_NUMBER){defines+="#define color_type_return_number\n";}else if(this._pointColorType===Potree.PointColorType.SOURCE){defines+="#define color_type_source\n";}else if(this._pointColorType===Potree.PointColorType.NORMAL){defines+="#define color_type_normal\n";}else if(this._pointColorType===Potree.PointColorType.PHONG){defines+="#define color_type_phong\n";}if(this.clipMode===Potree.ClipMode.DISABLED){defines+="#define clip_disabled\n";}else if(this.clipMode===Potree.ClipMode.CLIP_OUTSIDE){defines+="#define clip_outside\n";}else if(this.clipMode===Potree.ClipMode.HIGHLIGHT_INSIDE){defines+="#define clip_highlight_inside\n";}if(this._treeType===Potree.TreeType.OCTREE){defines+="#define tree_type_octree\n";}else if(this._treeType===Potree.TreeType.KDTREE){defines+="#define tree_type_kdtree\n";}if(this.weighted){defines+="#define weighted_splats\n";}if(this.numClipBoxes>0){defines+="#define use_clip_box\n";}return defines;};Potree.PointCloudMaterial.prototype.setClipBoxes=function(clipBoxes){if(!clipBoxes){return;}this.clipBoxes=clipBoxes;var doUpdate=this.numClipBoxes!=clipBoxes.length&&(clipBoxes.length===0||this.numClipBoxes===0);this.numClipBoxes=clipBoxes.length;this.uniforms.clipBoxCount.value=this.numClipBoxes;if(doUpdate){this.updateShaderSource();}this.uniforms.clipBoxes.value=new Float32Array(this.numClipBoxes*16);for(var i=0;i<this.numClipBoxes;i++){var box=clipBoxes[i];this.uniforms.clipBoxes.value.set(box.elements,16*i);}};Object.defineProperty(Potree.PointCloudMaterial.prototype,"gradient",{get:function get(){return this._gradient;},set:function set(value){if(this._gradient!==value){this._gradient=value;this.gradientTexture=Potree.PointCloudMaterial.generateGradientTexture(this._gradient);this.uniforms.gradient.value=this.gradientTexture;}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"classification",{get:function get(){return this._classification;},set:function set(value){if(this._classification!==value){this._classification=value;this.classificationTexture=Potree.PointCloudMaterial.generateClassificationTexture(this._classification);this.uniforms.classificationLUT.value=this.classificationTexture;}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"spacing",{get:function get(){return this.uniforms.spacing.value;},set:function set(value){if(this.uniforms.spacing.value!==value){this.uniforms.spacing.value=value; //this.updateShaderSource();
	}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"useClipBox",{get:function get(){return this._useClipBox;},set:function set(value){if(this._useClipBox!==value){this._useClipBox=value;this.updateShaderSource();}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"weighted",{get:function get(){return this._weighted;},set:function set(value){if(this._weighted!==value){this._weighted=value;this.updateShaderSource();}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"fov",{get:function get(){return this.uniforms.fov.value;},set:function set(value){if(this.uniforms.fov.value!==value){this.uniforms.fov.value=value; //this.updateShaderSource();
	}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"screenWidth",{get:function get(){return this.uniforms.screenWidth.value;},set:function set(value){if(this.uniforms.screenWidth.value!==value){this.uniforms.screenWidth.value=value; //this.updateShaderSource();
	}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"screenHeight",{get:function get(){return this.uniforms.screenHeight.value;},set:function set(value){if(this.uniforms.screenHeight.value!==value){this.uniforms.screenHeight.value=value; //this.updateShaderSource();
	}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"near",{get:function get(){return this.uniforms.near.value;},set:function set(value){if(this.uniforms.near.value!==value){this.uniforms.near.value=value;}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"far",{get:function get(){return this.uniforms.far.value;},set:function set(value){if(this.uniforms.far.value!==value){this.uniforms.far.value=value;}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"opacity",{get:function get(){return this.uniforms.opacity.value;},set:function set(value){if(this.uniforms.opacity){if(this.uniforms.opacity.value!==value){this.uniforms.opacity.value=value;this.updateShaderSource();}}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"pointColorType",{get:function get(){return this._pointColorType;},set:function set(value){if(this._pointColorType!==value){this._pointColorType=value;this.updateShaderSource();}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"depthMap",{get:function get(){return this._depthMap;},set:function set(value){if(this._depthMap!==value){this._depthMap=value;this.updateShaderSource();}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"pointSizeType",{get:function get(){return this._pointSizeType;},set:function set(value){if(this._pointSizeType!==value){this._pointSizeType=value;this.updateShaderSource();}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"clipMode",{get:function get(){return this._clipMode;},set:function set(value){if(this._clipMode!==value){this._clipMode=value;this.updateShaderSource();}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"interpolate",{get:function get(){return this._interpolate;},set:function set(value){if(this._interpolate!==value){this._interpolate=value;this.updateShaderSource();}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"useEDL",{get:function get(){return this._useEDL;},set:function set(value){if(this._useEDL!==value){this._useEDL=value;this.updateShaderSource();}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"useLogarithmicDepthBuffer",{get:function get(){return this._useLogarithmicDepthBuffer;},set:function set(value){if(this._useLogarithmicDepthBuffer!==value){this._useLogarithmicDepthBuffer=value;this.updateShaderSource();}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"color",{get:function get(){return this.uniforms.uColor.value;},set:function set(value){if(this.uniforms.uColor.value!==value){this.uniforms.uColor.value.copy(value);this.updateShaderSource();}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"pointShape",{get:function get(){return this._pointShape;},set:function set(value){if(this._pointShape!==value){this._pointShape=value;this.updateShaderSource();}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"size",{get:function get(){return this.uniforms.size.value;},set:function set(value){this.uniforms.size.value=value;}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"minSize",{get:function get(){return this.uniforms.minSize.value;},set:function set(value){this.uniforms.minSize.value=value;}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"maxSize",{get:function get(){return this.uniforms.maxSize.value;},set:function set(value){this.uniforms.maxSize.value=value;}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"heightMin",{get:function get(){return this.uniforms.heightMin.value;},set:function set(value){this.uniforms.heightMin.value=value;}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"heightMax",{get:function get(){return this.uniforms.heightMax.value;},set:function set(value){this.uniforms.heightMax.value=value;}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"intensityMin",{get:function get(){return this.uniforms.intensityMin.value;},set:function set(value){this.uniforms.intensityMin.value=value;}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"intensityMax",{get:function get(){return this.uniforms.intensityMax.value;},set:function set(value){this.uniforms.intensityMax.value=value;}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"pcIndex",{get:function get(){return this.uniforms.pcIndex.value;},set:function set(value){this.uniforms.pcIndex.value=value;}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"treeType",{get:function get(){return this._treeType;},set:function set(value){if(this._treeType!=value){this._treeType=value;this.updateShaderSource();}}});Object.defineProperty(Potree.PointCloudMaterial.prototype,"bbSize",{get:function get(){return this.uniforms.bbSize.value;},set:function set(value){this.uniforms.bbSize.value=value;}}); /**
	 * Generates a look-up texture for gradient values (height, intensity, ...)
	 *
	 */Potree.PointCloudMaterial.generateGradientTexture=function(gradient){var size=64; // create canvas
	var canvas=document.createElement('canvas');canvas.width=size;canvas.height=size; // get context
	var context=canvas.getContext('2d'); // draw gradient
	context.rect(0,0,size,size);var ctxGradient=context.createLinearGradient(0,0,size,size);for(var i=0;i<gradient.length;i++){var step=gradient[i];ctxGradient.addColorStop(step[0],"#"+step[1].getHexString());}context.fillStyle=ctxGradient;context.fill();var texture=new _three2.default.Texture(canvas);texture.needsUpdate=true;var textureImage=texture.image;return texture;}; /**
	 * Generates a look up texture for classification colors
	 *
	 */Potree.PointCloudMaterial.generateClassificationTexture=function(classification){var width=256;var height=256;var map=_three2.default.ImageUtils.generateDataTexture(width,height,new _three2.default.Color());map.magFilter=_three2.default.NearestFilter;var data=map.image.data;for(var x=0;x<width;x++){for(var y=0;y<height;y++){var u=2*(x/width)-1;var v=2*(y/height)-1;var i=x+width*y;var color;if(classification[x]){color=classification[x];}else {color=classification.DEFAULT;}data[3*i+0]=255*color.r;data[3*i+1]=255*color.g;data[3*i+2]=255*color.b;}}return map;}; //
	// Algorithm by Christian Boucheny
	// shader code taken and adapted from CloudCompare
	//
	// see
	// https://github.com/cloudcompare/trunk/tree/master/plugins/qEDL/shaders/EDL
	// http://www.kitware.com/source/home/post/9
	// https://tel.archives-ouvertes.fr/tel-00438464/document p. 115+ (french)
	Potree.EyeDomeLightingMaterial=function(parameters){_three2.default.Material.call(this);parameters=parameters||{};var neighbourCount=8;var neighbours=new Float32Array(neighbourCount*2);for(var c=0;c<neighbourCount;c++){neighbours[2*c+0]=Math.cos(2*c*Math.PI/neighbourCount);neighbours[2*c+1]=Math.sin(2*c*Math.PI/neighbourCount);} //var neighbourCount = 32;
	//var neighbours = new Float32Array(neighbourCount*2);
	//for(var c = 0; c < neighbourCount; c++){
	//  var r = (c / neighbourCount) * 4 + 0.1;
	//  neighbours[2*c+0] = Math.cos(2 * c * Math.PI / neighbourCount) * r;
	//  neighbours[2*c+1] = Math.sin(2 * c * Math.PI / neighbourCount) * r;
	//}
	var lightDir=new _three2.default.Vector3(0.0,0.0,1.0).normalize();var uniforms={screenWidth:{type:"f",value:0},screenHeight:{type:"f",value:0},near:{type:"f",value:0},far:{type:"f",value:0},expScale:{type:"f",value:100.0},radius:{type:"f",value:3.0},lightDir:{type:"v3",value:lightDir},neighbours:{type:"2fv",value:neighbours},depthMap:{type:"t",value:null},colorMap:{type:"t",value:null}};this.setValues({uniforms:uniforms,vertexShader:Potree.Shaders["edl.vs"],fragmentShader:Potree.Shaders["edl.fs"]});};Potree.EyeDomeLightingMaterial.prototype=new _three2.default.ShaderMaterial(); // see http://john-chapman-graphics.blogspot.co.at/2013/01/ssao-tutorial.html
	Potree.BlurMaterial=function(parameters){_three2.default.Material.call(this);parameters=parameters||{};var uniforms={near:{type:"f",value:0},far:{type:"f",value:0},screenWidth:{type:"f",value:0},screenHeight:{type:"f",value:0},map:{type:"t",value:null}};this.setValues({uniforms:uniforms,vertexShader:Potree.Shaders["blur.vs"],fragmentShader:Potree.Shaders["blur.fs"]});};Potree.BlurMaterial.prototype=new _three2.default.ShaderMaterial(); /**
	 * @author mschuetz / http://mschuetz.at/
	 * @author qiao / https://github.com/qiao
	 * @author mrdoob / http://mrdoob.com
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author erich666 / http://erichaines.com
	 */ /*global THREE, console */ // 
	// Adapted from THREE.OrbitControls
	// - Smooth movements
	// - creates "proposeTransform" events
	// 
	// 
	// This set of controls performs orbiting, dollying (zooming), and panning. It maintains
	// the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
	// supported.
	//
	//    Orbit - left mouse / touch: one finger move
	//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
	//    Pan - right mouse, or arrow keys / touch: three finter swipe
	//
	// This is a drop-in replacement for (most) TrackballControls used in examples.
	// That is, include this js file and wherever you see:
	//      controls = new THREE.TrackballControls( camera );
	//      controls.target.z = 150;
	// Simple substitute "OrbitControls" and the control should work as-is.
	Potree.OrbitControls=function(object,domElement){this.object=object;this.domElement=domElement!==undefined?domElement:document; // API
	// Set to false to disable this control
	this.enabled=true; // "target" sets the location of focus, where the control orbits around
	// and where it pans with respect to.
	this.target=new _three2.default.Vector3(); // center is old, deprecated; use "target" instead
	this.center=this.target; // This option actually enables dollying in and out; left as "zoom" for
	// backwards compatibility
	this.noZoom=false;this.zoomSpeed=1.0; // Limits to how far you can dolly in and out
	this.minDistance=0;this.maxDistance=Infinity; // Set to true to disable this control
	this.noRotate=false;this.rotateSpeed=1.0; // Set to true to disable this control
	this.noPan=false;this.keyPanSpeed=7.0; // pixels moved per arrow key push
	// Set to true to automatically rotate around the target
	this.autoRotate=false;this.autoRotateSpeed=2.0; // 30 seconds per round when fps is 60
	this.fadeFactor=10; // How far you can orbit vertically, upper and lower limits.
	// Range is 0 to Math.PI radians.
	this.minPolarAngle=0; // radians
	this.maxPolarAngle=Math.PI; // radians
	// Set to true to disable use of the keys
	this.noKeys=false; // The four arrow keys
	this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40}; ////////////
	// internals
	var scope=this;var EPS=0.000001;var rotateStart=new _three2.default.Vector2();var rotateEnd=new _three2.default.Vector2();var rotateDelta=new _three2.default.Vector2();var panStart=new _three2.default.Vector2();var panEnd=new _three2.default.Vector2();var panDelta=new _three2.default.Vector2();var panOffset=new _three2.default.Vector3();var offset=new _three2.default.Vector3();var dollyStart=new _three2.default.Vector2();var dollyEnd=new _three2.default.Vector2();var dollyDelta=new _three2.default.Vector2();var phiDelta=0;var thetaDelta=0;var scale=1;var pan=new _three2.default.Vector3();var lastPosition=new _three2.default.Vector3();var STATE={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY:4,TOUCH_PAN:5};var state=STATE.NONE; // for reset
	this.target0=this.target.clone();this.position0=this.object.position.clone(); // events
	var changeEvent={type:'change'};var startEvent={type:'start'};var endEvent={type:'end'};this.rotateLeft=function(angle){if(angle===undefined){angle=getAutoRotationAngle();}thetaDelta-=angle;};this.rotateUp=function(angle){if(angle===undefined){angle=getAutoRotationAngle();}phiDelta-=angle;}; // pass in distance in world space to move left
	this.panLeft=function(distance){var te=this.object.matrix.elements; // get X column of matrix
	panOffset.set(te[0],te[1],te[2]);panOffset.multiplyScalar(-distance);pan.add(panOffset);}; // pass in distance in world space to move up
	this.panUp=function(distance){var te=this.object.matrix.elements; // get Y column of matrix
	panOffset.set(te[4],te[5],te[6]);panOffset.multiplyScalar(distance);pan.add(panOffset);}; // pass in x,y of change desired in pixel space,
	// right and down are positive
	this.pan=function(deltaX,deltaY){var element=scope.domElement===document?scope.domElement.body:scope.domElement;if(scope.object.fov!==undefined){ // perspective
	var position=scope.object.position;var offset=position.clone().sub(scope.target);var targetDistance=offset.length(); // half of the fov is center to top of screen
	targetDistance*=Math.tan(scope.object.fov/2*Math.PI/180.0); // we actually don't use screenWidth, since perspective camera is fixed to screen height
	scope.panLeft(2*deltaX*targetDistance/element.clientHeight);scope.panUp(2*deltaY*targetDistance/element.clientHeight);}else if(scope.object.top!==undefined){ // orthographic
	scope.panLeft(deltaX*(scope.object.right-scope.object.left)/element.clientWidth);scope.panUp(deltaY*(scope.object.top-scope.object.bottom)/element.clientHeight);}else { // camera neither orthographic or perspective
	console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');}};this.dollyIn=function(dollyScale){if(dollyScale===undefined){dollyScale=getZoomScale();}scale/=dollyScale;};this.dollyOut=function(dollyScale){if(dollyScale===undefined){dollyScale=getZoomScale();}scale*=dollyScale;};this.update=function(delta){var position=this.object.position.clone();offset.copy(position).sub(this.target); // angle from z-axis around y-axis
	var theta=Math.atan2(offset.x,offset.z); // angle from y-axis
	var phi=Math.atan2(Math.sqrt(offset.x*offset.x+offset.z*offset.z),offset.y);if(this.autoRotate){this.rotateLeft(getAutoRotationAngle());}var progression=Math.min(1,this.fadeFactor*delta);theta+=progression*thetaDelta;phi+=progression*phiDelta; // restrict phi to be between desired limits
	phi=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,phi)); // restrict phi to be betwee EPS and PI-EPS
	phi=Math.max(EPS,Math.min(Math.PI-EPS,phi)); //var radius = offset.length() * scale;
	var radius=offset.length();radius+=(scale-1)*radius*progression; // restrict radius to be between desired limits
	radius=Math.max(this.minDistance,Math.min(this.maxDistance,radius)); // move target to panned location
	this.target.add(pan.clone().multiplyScalar(progression));offset.x=radius*Math.sin(phi)*Math.sin(theta);offset.y=radius*Math.cos(phi);offset.z=radius*Math.sin(phi)*Math.cos(theta);position.copy(this.target).add(offset); // send transformation proposal to listeners
	var proposeTransformEvent={type:"proposeTransform",oldPosition:this.object.position,newPosition:position,objections:0,counterProposals:[]};this.dispatchEvent(proposeTransformEvent); // check some counter proposals if transformation wasn't accepted
	if(proposeTransformEvent.objections>0){if(proposeTransformEvent.counterProposals.length>0){var cp=proposeTransformEvent.counterProposals;position.copy(cp[0]);proposeTransformEvent.objections=0;proposeTransformEvent.counterProposals=[];}} // apply transformation, if accepted
	if(proposeTransformEvent.objections>0){thetaDelta=0;phiDelta=0;scale=1;pan.set(0,0,0);}else {this.object.position.copy(position);this.object.lookAt(this.target);var attenuation=Math.max(0,1-this.fadeFactor*delta);thetaDelta*=attenuation;phiDelta*=attenuation;scale=1+(scale-1)*attenuation;pan.multiplyScalar(attenuation);}if(lastPosition.distanceTo(this.object.position)>0){this.dispatchEvent(changeEvent);lastPosition.copy(this.object.position);}};this.reset=function(){state=STATE.NONE;this.target.copy(this.target0);this.object.position.copy(this.position0);this.update();};function getAutoRotationAngle(){return 2*Math.PI/60/60*scope.autoRotateSpeed;}function getZoomScale(){return Math.pow(0.95,scope.zoomSpeed);}function onMouseDown(event){if(scope.enabled===false)return;event.preventDefault();if(event.button===0){if(scope.noRotate===true)return;state=STATE.ROTATE;rotateStart.set(event.clientX,event.clientY);}else if(event.button===1){if(scope.noZoom===true)return;state=STATE.DOLLY;dollyStart.set(event.clientX,event.clientY);}else if(event.button===2){if(scope.noPan===true)return;state=STATE.PAN;panStart.set(event.clientX,event.clientY);}scope.domElement.addEventListener('mousemove',onMouseMove,false);scope.domElement.addEventListener('mouseup',onMouseUp,false);scope.dispatchEvent(startEvent);}function onMouseMove(event){if(scope.enabled===false)return;event.preventDefault();var element=scope.domElement===document?scope.domElement.body:scope.domElement;if(state===STATE.ROTATE){if(scope.noRotate===true)return;rotateEnd.set(event.clientX,event.clientY);rotateDelta.subVectors(rotateEnd,rotateStart); // rotating across whole screen goes 360 degrees around
	scope.rotateLeft(2*Math.PI*rotateDelta.x/element.clientWidth*scope.rotateSpeed); // rotating up and down along whole screen attempts to go 360, but limited to 180
	scope.rotateUp(2*Math.PI*rotateDelta.y/element.clientHeight*scope.rotateSpeed);rotateStart.copy(rotateEnd);}else if(state===STATE.DOLLY){if(scope.noZoom===true)return;dollyEnd.set(event.clientX,event.clientY);dollyDelta.subVectors(dollyEnd,dollyStart);if(dollyDelta.y>0){scope.dollyIn();}else {scope.dollyOut();}dollyStart.copy(dollyEnd);}else if(state===STATE.PAN){if(scope.noPan===true)return;panEnd.set(event.clientX,event.clientY);panDelta.subVectors(panEnd,panStart);scope.pan(panDelta.x,panDelta.y);panStart.copy(panEnd);} //scope.update();
	}function onMouseUp() /* event */{if(scope.enabled===false)return;scope.domElement.removeEventListener('mousemove',onMouseMove,false);scope.domElement.removeEventListener('mouseup',onMouseUp,false);scope.dispatchEvent(endEvent);state=STATE.NONE;}function onMouseWheel(event){if(scope.enabled===false||scope.noZoom===true)return;event.preventDefault();var delta=0;if(event.wheelDelta!==undefined){ // WebKit / Opera / Explorer 9
	delta=event.wheelDelta;}else if(event.detail!==undefined){ // Firefox
	delta=-event.detail;}if(delta>0){scope.dollyOut();}else {scope.dollyIn();} //scope.update();
	scope.dispatchEvent(startEvent);scope.dispatchEvent(endEvent);}function onKeyDown(event){if(scope.enabled===false||scope.noKeys===true||scope.noPan===true)return;switch(event.keyCode){case scope.keys.UP:scope.pan(0,scope.keyPanSpeed); //scope.update();
	break;case scope.keys.BOTTOM:scope.pan(0,-scope.keyPanSpeed); //scope.update();
	break;case scope.keys.LEFT:scope.pan(scope.keyPanSpeed,0); //scope.update();
	break;case scope.keys.RIGHT:scope.pan(-scope.keyPanSpeed,0); //scope.update();
	break;}}function touchstart(event){if(scope.enabled===false)return;switch(event.touches.length){case 1: // one-fingered touch: rotate
	if(scope.noRotate===true)return;state=STATE.TOUCH_ROTATE;rotateStart.set(event.touches[0].pageX,event.touches[0].pageY);break;case 2: // two-fingered touch: dolly
	if(scope.noZoom===true)return;state=STATE.TOUCH_DOLLY;var dx=event.touches[0].pageX-event.touches[1].pageX;var dy=event.touches[0].pageY-event.touches[1].pageY;var distance=Math.sqrt(dx*dx+dy*dy);dollyStart.set(0,distance);break;case 3: // three-fingered touch: pan
	if(scope.noPan===true)return;state=STATE.TOUCH_PAN;panStart.set(event.touches[0].pageX,event.touches[0].pageY);break;default:state=STATE.NONE;}scope.dispatchEvent(startEvent);}function touchmove(event){if(scope.enabled===false)return;event.preventDefault();event.stopPropagation();var element=scope.domElement===document?scope.domElement.body:scope.domElement;switch(event.touches.length){case 1: // one-fingered touch: rotate
	if(scope.noRotate===true)return;if(state!==STATE.TOUCH_ROTATE)return;rotateEnd.set(event.touches[0].pageX,event.touches[0].pageY);rotateDelta.subVectors(rotateEnd,rotateStart); // rotating across whole screen goes 360 degrees around
	scope.rotateLeft(2*Math.PI*rotateDelta.x/element.clientWidth*scope.rotateSpeed); // rotating up and down along whole screen attempts to go 360, but limited to 180
	scope.rotateUp(2*Math.PI*rotateDelta.y/element.clientHeight*scope.rotateSpeed);rotateStart.copy(rotateEnd); //scope.update();
	break;case 2: // two-fingered touch: dolly
	if(scope.noZoom===true)return;if(state!==STATE.TOUCH_DOLLY)return;var dx=event.touches[0].pageX-event.touches[1].pageX;var dy=event.touches[0].pageY-event.touches[1].pageY;var distance=Math.sqrt(dx*dx+dy*dy);dollyEnd.set(0,distance);dollyDelta.subVectors(dollyEnd,dollyStart);var ew=element.clientWidth;var eh=element.clientHeight;var diagonal=Math.sqrt(ew*ew+eh*eh);var delta=dollyDelta.y/diagonal;if(dollyDelta.y>0){scope.dollyOut(1-delta);}else {scope.dollyIn(1+delta);}dollyStart.copy(dollyEnd); //scope.update();
	break;case 3: // three-fingered touch: pan
	if(scope.noPan===true)return;if(state!==STATE.TOUCH_PAN)return;panEnd.set(event.touches[0].pageX,event.touches[0].pageY);panDelta.subVectors(panEnd,panStart);scope.pan(panDelta.x,panDelta.y);panStart.copy(panEnd); //scope.update();
	break;default:state=STATE.NONE;}}function touchend() /* event */{if(scope.enabled===false)return;scope.dispatchEvent(endEvent);state=STATE.NONE;}this.domElement.addEventListener('contextmenu',function(event){event.preventDefault();},false);this.domElement.addEventListener('mousedown',onMouseDown,false);this.domElement.addEventListener('mousewheel',onMouseWheel,false);this.domElement.addEventListener('DOMMouseScroll',onMouseWheel,false); // firefox
	this.domElement.addEventListener('touchstart',touchstart,false);this.domElement.addEventListener('touchend',touchend,false);this.domElement.addEventListener('touchmove',touchmove,false);window.addEventListener('keydown',onKeyDown,false);};Potree.OrbitControls.prototype=Object.create(_three2.default.EventDispatcher.prototype); /**
	 * 
	 * @param node
	 * @class an item in the lru list. 
	 */function LRUItem(node){this.previous=null;this.next=null;this.node=node;} /**
	 * 
	 * @class A doubly-linked-list of the least recently used elements.
	 */function LRU(){ // the least recently used item
	this.first=null; // the most recently used item
	this.last=null; // a list of all items in the lru list
	this.items={};this.elements=0;this.numPoints=0;} /**
	 * number of elements in the list
	 * 
	 * @returns {Number}
	 */LRU.prototype.size=function(){return this.elements;};LRU.prototype.contains=function(node){return this.items[node.id]==null;}; /**
	 * makes node the most recently used item. if the list does not contain node, it will be added.
	 * 
	 * @param node
	 */LRU.prototype.touch=function(node){if(!node.loaded){return;}var item;if(this.items[node.id]==null){ // add to list
	item=new LRUItem(node);item.previous=this.last;this.last=item;if(item.previous!==null){item.previous.next=item;}this.items[node.id]=item;this.elements++;if(this.first===null){this.first=item;}this.numPoints+=node.numPoints;}else { // update in list
	item=this.items[node.id];if(item.previous===null){ // handle touch on first element
	if(item.next!==null){this.first=item.next;this.first.previous=null;item.previous=this.last;item.next=null;this.last=item;item.previous.next=item;}}else if(item.next===null){ // handle touch on last element
	}else { // handle touch on any other element
	item.previous.next=item.next;item.next.previous=item.previous;item.previous=this.last;item.next=null;this.last=item;item.previous.next=item;}}}; ///**
	// * removes the least recently used item from the list and returns it. 
	// * if the list was empty, null will be returned.
	// */
	//LRU.prototype.remove = function remove(){
	//  if(this.first === null){
	//    return null;
	//  }
	//  var lru = this.first;
	//
	//  // if the lru list contains at least 2 items, the item after the least recently used elemnt will be the new lru item. 
	//  if(lru.next !== null){
	//    this.first = lru.next;
	//    this.first.previous = null;
	//  }else{
	//    this.first = null;
	//    this.last = null;
	//  }
	//  
	//  delete this.items[lru.node.id];
	//  this.elements--;
	//  this.numPoints -= lru.node.numPoints;
	//  
	////  Logger.info("removed node: " + lru.node.id);
	//  return lru.node;
	//};
	LRU.prototype.remove=function remove(node){var lruItem=this.items[node.id];if(lruItem){if(this.elements===1){this.first=null;this.last=null;}else {if(!lruItem.previous){this.first=lruItem.next;this.first.previous=null;}if(!lruItem.next){this.last=lruItem.previous;this.last.next=null;}if(lruItem.previous&&lruItem.next){lruItem.previous.next=lruItem.next;lruItem.next.previous=lruItem.previous;}}delete this.items[node.id];this.elements--;this.numPoints-=node.numPoints;}};LRU.prototype.getLRUItem=function(){if(this.first===null){return null;}var lru=this.first;return lru.node;};LRU.prototype.toString=function(){var string="{ ";var curr=this.first;while(curr!==null){string+=curr.node.id;if(curr.next!==null){string+=", ";}curr=curr.next;}string+="}";string+="("+this.size()+")";return string;};LRU.prototype.freeMemory=function(){if(this.elements<=1){return;}while(this.numPoints>Potree.pointLoadLimit){var element=this.first;var node=element.node;this.disposeDescendants(node);};};LRU.prototype.disposeDescendants=function(node){var stack=[];stack.push(node);while(stack.length>0){var current=stack.pop();current.dispose();this.remove(current);for(var key in current.children){if(current.children.hasOwnProperty(key)){var child=current.children[key];if(child.loaded){stack.push(current.children[key]);}}}}};Potree.PointCloudOctreeNode=function(){this.children={};this.sceneNode=null;};Potree.PointCloudOctree=function(geometry,material){_three2.default.Object3D.call(this);Potree.PointCloudOctree.lru=Potree.PointCloudOctree.lru||new LRU();this.pcoGeometry=geometry;this.boundingBox=this.pcoGeometry.tightBoundingBox;this.boundingSphere=this.boundingBox.getBoundingSphere();this.material=material||new Potree.PointCloudMaterial();this.visiblePointsTarget=2*1000*1000;this.minimumNodePixelSize=150;this.level=0;this.position.sub(geometry.offset);this.updateMatrix();this.showBoundingBox=false;this.boundingBoxNodes=[];this.loadQueue=[];this.visibleBounds=new _three2.default.Box3();this.visibleNodes=[];this.visibleGeometry=[];this.pickTarget;this.generateDEM=false;this.root=this.pcoGeometry.root;};Potree.PointCloudOctree.prototype=Object.create(_three2.default.Object3D.prototype);Potree.PointCloudOctree.prototype.updateVisibility=function(camera,renderer){this.numVisibleNodes=0;this.numVisiblePoints=0; // frustum in object space
	camera.updateMatrixWorld();var frustum=new _three2.default.Frustum();var viewI=camera.matrixWorldInverse;var world=this.matrixWorld;var proj=camera.projectionMatrix;var fm=new _three2.default.Matrix4().multiply(proj).multiply(viewI).multiply(world);frustum.setFromMatrix(fm); // camera position in object space
	var view=camera.matrixWorld;var worldI=new _three2.default.Matrix4().getInverse(world);var camMatrixObject=new _three2.default.Matrix4().multiply(worldI).multiply(view);var camObjPos=new _three2.default.Vector3().setFromMatrixPosition(camMatrixObject); // traverse nodes with highest weight(depends on node size and distance to camera) first
	var priorityQueue=new _BinaryHeap2.default(function(x){return 1/x.weight;});priorityQueue.push({node:this.root,weight:1});var visibleNodes=[];var visibleGeometry=[];var unloadedGeometry=[];var pointCount=0; // first, hide all visible nodes
	if(this.root instanceof Potree.PointCloudOctreeNode){this.hideDescendants(this.root.sceneNode);}for(var i=0;i<this.boundingBoxNodes.length;i++){this.boundingBoxNodes[i].visible=false;}while(priorityQueue.size()>0){var element=priorityQueue.pop();var node=element.node;var parent=element.parent;var box=node.boundingBox;var insideFrustum=frustum.intersectsBox(box);var visible=insideFrustum;visible=visible&&!(this.numVisiblePoints+node.numPoints>this.visiblePointsTarget);if(!visible){continue;}this.numVisibleNodes++;this.numVisiblePoints+=node.numPoints; // if geometry is loaded, create a scene node
	if(node instanceof Potree.PointCloudOctreeGeometryNode){var geometryNode=node;var geometry=geometryNode.geometry;if((typeof parent==="undefined"||parent instanceof Potree.PointCloudOctreeNode)&&geometryNode.loaded){var pcoNode=new Potree.PointCloudOctreeNode();var sceneNode=new _three2.default.PointCloud(geometry,this.material);sceneNode.visible=false;pcoNode.name=geometryNode.name;pcoNode.level=geometryNode.level;pcoNode.numPoints=geometryNode.numPoints;pcoNode.boundingBox=geometry.boundingBox;pcoNode.tightBoundingBox=geometry.tightBoundingBox;pcoNode.boundingSphere=pcoNode.boundingBox.getBoundingSphere();pcoNode.geometryNode=geometryNode;pcoNode.parent=parent;pcoNode.children=geometryNode.children;sceneNode.boundingBox=pcoNode.boundingBox;sceneNode.boundingSphere=pcoNode.boundingSphere;sceneNode.numPoints=pcoNode.numPoints;sceneNode.level=pcoNode.level;pcoNode.sceneNode=sceneNode;if(typeof node.parent==="undefined"){this.root=pcoNode;this.add(pcoNode.sceneNode);sceneNode.matrixWorld.multiplyMatrices(this.matrixWorld,sceneNode.matrix);}else {var childIndex=parseInt(pcoNode.name[pcoNode.name.length-1]);parent.sceneNode.add(sceneNode);parent.children[childIndex]=pcoNode;sceneNode.matrixWorld.multiplyMatrices(parent.sceneNode.matrixWorld,sceneNode.matrix);}node=pcoNode;}if(!geometryNode.loaded){unloadedGeometry.push(node);visibleGeometry.push(node);}}if(node instanceof Potree.PointCloudOctreeNode){Potree.PointCloudOctree.lru.touch(node.geometryNode);node.sceneNode.visible=true;node.sceneNode.material=this.material;visibleNodes.push(node);visibleGeometry.push(node.geometryNode);if(node.parent){node.sceneNode.matrixWorld.multiplyMatrices(node.parent.sceneNode.matrixWorld,node.sceneNode.matrix);}else {node.sceneNode.matrixWorld.multiplyMatrices(this.matrixWorld,node.sceneNode.matrix);}if(this.showBoundingBox&&!node.boundingBoxNode){var boxHelper=new _three2.default.BoxHelper(node.sceneNode);this.add(boxHelper);this.boundingBoxNodes.push(boxHelper);node.boundingBoxNode=boxHelper;node.boundingBoxNode.matrixWorld.copy(node.sceneNode.matrixWorld);}else if(this.showBoundingBox){node.boundingBoxNode.visible=true;node.boundingBoxNode.matrixWorld.copy(node.sceneNode.matrixWorld);}else if(!this.showBoundingBox&&node.boundingBoxNode){node.boundingBoxNode.visible=false;}if(this.generateDEM&&node.level<=2){if(!node.dem){node.dem=this.createDEM(node);}}} // add child nodes to priorityQueue
	for(var i=0;i<8;i++){if(!node.children[i]){continue;}var child=node.children[i];var sphere=child.boundingSphere;var distance=sphere.center.distanceTo(camObjPos);var radius=sphere.radius;var fov=camera.fov/2*Math.PI/180.0;var pr=1/Math.tan(fov)*radius/Math.sqrt(distance*distance-radius*radius);var screenPixelRadius=renderer.domElement.clientHeight*pr;if(screenPixelRadius<this.minimumNodePixelSize){continue;}var weight=pr;if(distance-radius<0){weight=Number.MAX_VALUE;}priorityQueue.push({node:child,parent:node,weight:weight});}}this.visibleNodes=visibleNodes;this.visibleGeometry=visibleGeometry; // load next few unloaded geometries
	for(var i=0;i<Math.min(5,unloadedGeometry.length);i++){unloadedGeometry[i].load();}};Potree.PointCloudOctree.prototype.updateVisibleBounds=function(){var leafNodes=[];for(var i=0;i<this.visibleNodes.length;i++){var node=this.visibleNodes[i];var isLeaf=true;for(var j=0;j<node.children.length;j++){var child=node.children[j];if(child instanceof Potree.PointCloudOctreeNode){isLeaf=isLeaf&&!child.sceneNode.visible;}else if(child instanceof Potree.PointCloudOctreeGeometryNode){isLeaf=true;}}if(isLeaf){leafNodes.push(node);}}this.visibleBounds.min=new _three2.default.Vector3(Infinity,Infinity,Infinity);this.visibleBounds.max=new _three2.default.Vector3(-Infinity,-Infinity,-Infinity);for(var i=0;i<leafNodes.length;i++){var node=leafNodes[i];this.visibleBounds.expandByPoint(node.boundingBox.min);this.visibleBounds.expandByPoint(node.boundingBox.max);}};Potree.PointCloudOctree.prototype.updateMaterial=function(material,visibleNodes,camera,renderer){material.fov=camera.fov*(Math.PI/180);material.screenWidth=renderer.domElement.clientWidth;material.screenHeight=renderer.domElement.clientHeight;material.spacing=this.pcoGeometry.spacing;material.near=camera.near;material.far=camera.far;material.uniforms.octreeSize.value=this.pcoGeometry.boundingBox.size().x; // update visibility texture
	if(material.pointSizeType){if(material.pointSizeType===Potree.PointSizeType.ADAPTIVE||material.pointColorType===Potree.PointColorType.OCTREE_DEPTH){this.updateVisibilityTexture(material,visibleNodes);}}};Potree.PointCloudOctree.prototype.update=function(camera,renderer){this.updateVisibility(camera,renderer);this.updateMaterial(this.material,this.visibleNodes,camera,renderer);this.updateVisibleBounds();Potree.PointCloudOctree.lru.freeMemory(); // TODO bounds
	// TODO free memory
	};Potree.PointCloudOctree.prototype.updateVisibilityTexture=function(material,visibleNodes){if(!material){return;}var texture=material.visibleNodesTexture;var data=texture.image.data; // copy array
	visibleNodes=visibleNodes.slice(); // sort by level and index, e.g. r, r0, r3, r4, r01, r07, r30, ...
	var sort=function sort(a,b){var na=a.name;var nb=b.name;if(na.length!=nb.length)return na.length-nb.length;if(na<nb)return -1;if(na>nb)return 1;return 0;};visibleNodes.sort(sort);for(var i=0;i<visibleNodes.length;i++){var node=visibleNodes[i];var children=[];for(var j=0;j<8;j++){var child=node.children[j];if(child instanceof Potree.PointCloudOctreeNode&&child.sceneNode.visible){children.push(child);}}children.sort(function(a,b){if(a.name<b.name)return -1;if(a.name>b.name)return 1;return 0;});data[i*3+0]=0;data[i*3+1]=0;data[i*3+2]=0;for(var j=0;j<children.length;j++){var child=children[j];var index=parseInt(child.name.substr(-1));data[i*3+0]+=Math.pow(2,index);if(j===0){var vArrayIndex=visibleNodes.indexOf(child);data[i*3+1]=vArrayIndex-i;}}}texture.needsUpdate=true;};Potree.PointCloudOctree.prototype.nodesOnRay=function(nodes,ray){var nodesOnRay=[];var _ray=ray.clone();for(var i=0;i<nodes.length;i++){var node=nodes[i]; //var inverseWorld = new THREE.Matrix4().getInverse(node.matrixWorld);
	var sphere=node.boundingSphere.clone().applyMatrix4(node.sceneNode.matrixWorld);if(_ray.isIntersectionSphere(sphere)){nodesOnRay.push(node);}}return nodesOnRay;};Potree.PointCloudOctree.prototype.updateMatrixWorld=function(force){ //node.matrixWorld.multiplyMatrices( node.parent.matrixWorld, node.matrix );
	if(this.matrixAutoUpdate===true)this.updateMatrix();if(this.matrixWorldNeedsUpdate===true||force===true){if(this.parent===undefined){this.matrixWorld.copy(this.matrix);}else {this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}this.matrixWorldNeedsUpdate=false;force=true;}};Potree.PointCloudOctree.prototype.hideDescendants=function(object){var stack=[];for(var i=0;i<object.children.length;i++){var child=object.children[i];if(child.visible){stack.push(child);}}while(stack.length>0){var object=stack.shift();object.visible=false;for(var i=0;i<object.children.length;i++){var child=object.children[i];if(child.visible){stack.push(child);}}}};Potree.PointCloudOctree.prototype.moveToOrigin=function(){this.position.set(0,0,0);this.updateMatrixWorld(true);var box=this.boundingBox;var transform=this.matrixWorld;var tBox=Potree.utils.computeTransformedBoundingBox(box,transform);this.position.set(0,0,0).sub(tBox.center());};Potree.PointCloudOctree.prototype.moveToGroundPlane=function(){this.updateMatrixWorld(true);var box=this.boundingBox;var transform=this.matrixWorld;var tBox=Potree.utils.computeTransformedBoundingBox(box,transform);this.position.y+=-tBox.min.y;};Potree.PointCloudOctree.prototype.getBoundingBoxWorld=function(){this.updateMatrixWorld(true);var box=this.boundingBox;var transform=this.matrixWorld;var tBox=Potree.utils.computeTransformedBoundingBox(box,transform);return tBox;}; /**
	 * returns points inside the profile points
	 *
	 * maxDepth:    search points up to the given octree depth
	 *
	 *
	 * The return value is an array with all segments of the profile path
	 *  var segment = {
	 *    start:  THREE.Vector3,
	 *    end:  THREE.Vector3,
	 *    points: {}
	 *    project: function()
	 *  };
	 *
	 * The project() function inside each segment can be used to transform
	 * that segments point coordinates to line up along the x-axis.
	 *
	 *
	 */Potree.PointCloudOctree.prototype.getPointsInProfile=function(profile,maxDepth){var points={segments:[],boundingBox:new _three2.default.Box3(),projectedBoundingBox:new _three2.default.Box2()}; // evaluate segments
	for(var i=0;i<profile.points.length-1;i++){var start=profile.points[i];var end=profile.points[i+1];var ps=this.getProfile(start,end,profile.width,maxDepth);var segment={start:start,end:end,points:ps,project:null};points.segments.push(segment);points.boundingBox.expandByPoint(ps.boundingBox.min);points.boundingBox.expandByPoint(ps.boundingBox.max);} // add projection functions to the segments
	var mileage=new _three2.default.Vector3();for(var i=0;i<points.segments.length;i++){var segment=points.segments[i];var start=segment.start;var end=segment.end;var project=function(_start,_end,_mileage,_boundingBox){var start=_start;var end=_end;var mileage=_mileage;var boundingBox=_boundingBox;var xAxis=new _three2.default.Vector3(1,0,0);var dir=new _three2.default.Vector3().subVectors(end,start);dir.y=0;dir.normalize();var alpha=Math.acos(xAxis.dot(dir));if(dir.z>0){alpha=-alpha;}return function(position){var toOrigin=new _three2.default.Matrix4().makeTranslation(-start.x,-boundingBox.min.y,-start.z);var alignWithX=new _three2.default.Matrix4().makeRotationY(-alpha);var applyMileage=new _three2.default.Matrix4().makeTranslation(mileage.x,0,0);var pos=position.clone();pos.applyMatrix4(toOrigin);pos.applyMatrix4(alignWithX);pos.applyMatrix4(applyMileage);return pos;};}(start,end,mileage.clone(),points.boundingBox.clone());segment.project=project;mileage.x+=new _three2.default.Vector3(start.x,0,start.z).distanceTo(new _three2.default.Vector3(end.x,0,end.z));mileage.y+=end.y-start.y;}points.projectedBoundingBox.min.x=0;points.projectedBoundingBox.min.y=points.boundingBox.min.y;points.projectedBoundingBox.max.x=mileage.x;points.projectedBoundingBox.max.y=points.boundingBox.max.y;return points;}; /**
	 * returns points inside the given profile bounds.
	 *
	 * start:   
	 * end:   
	 * width: 
	 * depth:   search points up to the given octree depth
	 * callback:  if specified, points are loaded before searching
	 *        
	 *
	 */Potree.PointCloudOctree.prototype.getProfile=function(start,end,width,depth,callback){if(callback!==undefined){this.profileRequests.push(new Potree.ProfileRequest(start,end,width,depth,callback));}else {var stack=[];stack.push(this);var center=new _three2.default.Vector3().addVectors(end,start).multiplyScalar(0.5);var length=new _three2.default.Vector3().subVectors(end,start).length();var side=new _three2.default.Vector3().subVectors(end,start).normalize();var up=new _three2.default.Vector3(0,1,0);var forward=new _three2.default.Vector3().crossVectors(side,up).normalize();var N=forward;var cutPlane=new _three2.default.Plane().setFromNormalAndCoplanarPoint(N,start);var halfPlane=new _three2.default.Plane().setFromNormalAndCoplanarPoint(side,center);var inside=null;var boundingBox=new _three2.default.Box3();while(stack.length>0){var object=stack.shift();var pointsFound=0;if(object instanceof _three2.default.PointCloud){var geometry=object.geometry;var positions=geometry.attributes.position;var p=positions.array;var numPoints=object.numPoints;if(!inside){inside={};for(var property in geometry.attributes){if(geometry.attributes.hasOwnProperty(property)){if(property==="indices"){}else {inside[property]=[];}}}}for(var i=0;i<numPoints;i++){var pos=new _three2.default.Vector3(p[3*i],p[3*i+1],p[3*i+2]);pos.applyMatrix4(this.matrixWorld);var distance=Math.abs(cutPlane.distanceToPoint(pos));var centerDistance=Math.abs(halfPlane.distanceToPoint(pos));if(distance<width/2&&centerDistance<length/2){boundingBox.expandByPoint(pos);for(var property in geometry.attributes){if(geometry.attributes.hasOwnProperty(property)){if(property==="position"){inside[property].push(pos);}else if(property==="indices"){ // skip indices
	}else {var values=geometry.attributes[property];if(values.itemSize===1){inside[property].push(values.array[i+j]);}else {var value=[];for(var j=0;j<values.itemSize;j++){value.push(values.array[i*values.itemSize+j]);}inside[property].push(value);}}}}pointsFound++;}}} //console.log("traversing: " + object.name + ", #points found: " + pointsFound);
	if(object==this||object.level<depth){for(var i=0;i<object.children.length;i++){var child=object.children[i];if(child instanceof _three2.default.PointCloud){var sphere=child.boundingSphere.clone().applyMatrix4(child.matrixWorld);if(cutPlane.distanceToSphere(sphere)<sphere.radius){stack.push(child);}}}}}inside.numPoints=inside.position.length;var project=function(_start,_end){var start=_start;var end=_end;var xAxis=new _three2.default.Vector3(1,0,0);var dir=new _three2.default.Vector3().subVectors(end,start);dir.y=0;dir.normalize();var alpha=Math.acos(xAxis.dot(dir));if(dir.z>0){alpha=-alpha;}return function(position){var toOrigin=new _three2.default.Matrix4().makeTranslation(-start.x,-start.y,-start.z);var alignWithX=new _three2.default.Matrix4().makeRotationY(-alpha);var pos=position.clone();pos.applyMatrix4(toOrigin);pos.applyMatrix4(alignWithX);return pos;};}(start,end);inside.project=project;inside.boundingBox=boundingBox;return inside;}};Potree.PointCloudOctree.prototype.getVisibleExtent=function(){return this.visibleBounds.applyMatrix4(this.matrixWorld);}; /**
	 *
	 *
	 *
	 * params.pickWindowSize: Look for points inside a pixel window of this size.
	 *              Use odd values: 1, 3, 5, ...
	 * 
	 * 
	 * TODO: only draw pixels that are actually read with readPixels(). 
	 * 
	 */Potree.PointCloudOctree.prototype.pick=function(renderer,camera,ray,params){ // this function finds intersections by rendering point indices and then checking the point index at the mouse location.
	// point indices are 3 byte and rendered to the RGB component.
	// point cloud node indices are 1 byte and stored in the ALPHA component.
	// this limits picking capabilities to 256 nodes and 2^24 points per node. 
	var params=params||{};var pickWindowSize=params.pickWindowSize||17;var nodes=this.nodesOnRay(this.visibleNodes,ray);if(nodes.length===0){return null;}var width=Math.ceil(renderer.domElement.clientWidth);var height=Math.ceil(renderer.domElement.clientHeight);var pixelPos=new _three2.default.Vector3().addVectors(camera.position,ray.direction).project(camera);pixelPos.addScalar(1).multiplyScalar(0.5);pixelPos.x*=width;pixelPos.y*=height;if(!this.pickTarget){this.pickTarget=new _three2.default.WebGLRenderTarget(1,1,{minFilter:_three2.default.LinearFilter,magFilter:_three2.default.NearestFilter,format:_three2.default.RGBAFormat});}else if(this.pickTarget.width!=width||this.pickTarget.height!=height){this.pickTarget.dispose();this.pickTarget=new _three2.default.WebGLRenderTarget(1,1,{minFilter:_three2.default.LinearFilter,magFilter:_three2.default.NearestFilter,format:_three2.default.RGBAFormat});}this.pickTarget.setSize(width,height); // setup pick material.
	// use the same point size functions as the main material to get the same point sizes.
	if(!this.pickMaterial){this.pickMaterial=new Potree.PointCloudMaterial();this.pickMaterial.pointColorType=Potree.PointColorType.POINT_INDEX;}this.pickMaterial.pointSizeType=this.material.pointSizeType;this.pickMaterial.size=this.material.size;this.pickMaterial.pointShape=this.material.pointShape;this.pickMaterial.interpolate=this.material.interpolate;this.pickMaterial.minSize=this.material.minSize;this.pickMaterial.maxSize=this.material.maxSize;this.updateMaterial(this.pickMaterial,nodes,camera,renderer);var _gl=renderer.context;_gl.enable(_gl.SCISSOR_TEST);_gl.scissor(pixelPos.x-(pickWindowSize-1)/2,pixelPos.y-(pickWindowSize-1)/2,pickWindowSize,pickWindowSize);_gl.disable(_gl.SCISSOR_TEST);var material=this.pickMaterial;renderer.setRenderTarget(this.pickTarget);renderer.state.setDepthTest(material.depthTest);renderer.state.setDepthWrite(material.depthWrite);renderer.state.setBlending(_three2.default.NoBlending);renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil); //TODO: UGLY HACK CHAMPIONSHIP SUBMISSION!! drawing first node does not work properly so we draw it twice.
	if(nodes.length>0){nodes.push(nodes[0]);}for(var i=0;i<nodes.length;i++){var object=nodes[i].sceneNode;var geometry=object.geometry;if(!geometry.attributes.indices.buffer){continue;}material.pcIndex=i;if(material.program){var program=material.program.program;_gl.useProgram(program); //_gl.disable( _gl.BLEND );
	var attributePointer=_gl.getAttribLocation(program,"indices");var attributeSize=4;_gl.bindBuffer(_gl.ARRAY_BUFFER,geometry.attributes.indices.buffer); //if(!bufferSubmitted){
	//  _gl.bufferData( _gl.ARRAY_BUFFER, new Uint8Array(geometry.attributes.indices.array), _gl.STATIC_DRAW );
	//  bufferSubmitted = true;
	//}
	_gl.enableVertexAttribArray(attributePointer);_gl.vertexAttribPointer(attributePointer,attributeSize,_gl.UNSIGNED_BYTE,true,0,0);_gl.uniform1f(material.program.uniforms.pcIndex,material.pcIndex);}renderer.renderBufferDirect(camera,[],null,material,geometry,object);var program=material.program.program;_gl.useProgram(program);var attributePointer=_gl.getAttribLocation(program,"indices");_gl.disableVertexAttribArray(attributePointer);}var pixelCount=pickWindowSize*pickWindowSize;var buffer=new ArrayBuffer(pixelCount*4);var pixels=new Uint8Array(buffer);var ibuffer=new Uint32Array(buffer);renderer.context.readPixels(pixelPos.x-(pickWindowSize-1)/2,pixelPos.y-(pickWindowSize-1)/2,pickWindowSize,pickWindowSize,renderer.context.RGBA,renderer.context.UNSIGNED_BYTE,pixels); // find closest hit inside pixelWindow boundaries
	var min=Number.MAX_VALUE;var hit=null; //console.log("finding closest hit");
	for(var u=0;u<pickWindowSize;u++){for(var v=0;v<pickWindowSize;v++){var offset=u+v*pickWindowSize;var distance=Math.pow(u-(pickWindowSize-1)/2,2)+Math.pow(v-(pickWindowSize-1)/2,2);var pcIndex=pixels[4*offset+3];pixels[4*offset+3]=0;var pIndex=ibuffer[offset];if((pIndex!==0||pcIndex!==0)&&distance<min){hit={pIndex:pIndex,pcIndex:pcIndex};min=distance;}}}if(hit){var point={};var pc=nodes[hit.pcIndex].sceneNode;var attributes=pc.geometry.attributes;for(var property in attributes){if(attributes.hasOwnProperty(property)){var values=geometry.attributes[property];if(property==="position"){var positionArray=pc.geometry.attributes.position.array;var x=positionArray[3*hit.pIndex+0];var y=positionArray[3*hit.pIndex+1];var z=positionArray[3*hit.pIndex+2];var position=new _three2.default.Vector3(x,y,z);position.applyMatrix4(this.matrixWorld);point[property]=position;}else if(property==="indices"){}else {if(values.itemSize===1){point[property]=values.array[i+j];}else {var value=[];for(var j=0;j<values.itemSize;j++){value.push(values.array[i*values.itemSize+j]);}point[property]=value;}}}}return point;}else {return null;}};var demTime=0;Potree.PointCloudOctree.prototype.createDEM=function(node){var start=new Date().getTime();var sceneNode=node.sceneNode;var world=sceneNode.matrixWorld;var boundingBox=sceneNode.boundingBox.clone().applyMatrix4(world);var bbSize=boundingBox.size();var positions=sceneNode.geometry.attributes.position.array;var demSize=64;var demMArray=new Array(demSize*demSize);var dem=new Float32Array(demSize*demSize);var n=positions.length/3;var toWorld=function toWorld(dx,dy){var x=dx*bbSize.x/(demSize-1)+boundingBox.min.x;var y=dem[dx+dy*demSize];var z=dy*bbSize.z/(demSize-1)+boundingBox.min.z;return [x,y,z];};var toDem=function toDem(x,y){var dx=parseInt(demSize*(x-boundingBox.min.x)/bbSize.x);var dy=parseInt(demSize*(z-boundingBox.min.z)/bbSize.z);dx=Math.min(dx,demSize-1);dy=Math.min(dy,demSize-1);return [dx,dy];};for(var i=0;i<n;i++){var x=positions[3*i+0];var y=positions[3*i+1];var z=positions[3*i+2];var worldPos=new _three2.default.Vector3(x,y,z).applyMatrix4(world);var dx=parseInt(demSize*(worldPos.x-boundingBox.min.x)/bbSize.x);var dy=parseInt(demSize*(worldPos.z-boundingBox.min.z)/bbSize.z);dx=Math.min(dx,demSize-1);dy=Math.min(dy,demSize-1);var index=dx+dy*demSize;if(!demMArray[index]){demMArray[index]=[];}demMArray[index].push(worldPos.y); //if(dem[dx + dy * demSize] === 0){
	//  dem[dx + dy * demSize] = worldPos.y;
	//}else{
	//  dem[dx + dy * demSize] = Math.max(dem[dx + dy * demSize], worldPos.y);
	//}
	}for(var i=0;i<demMArray.length;i++){var values=demMArray[i];if(!values){dem[i]=0;}else if(values.length===0){dem[i]=0;}else {var medianIndex=parseInt((values.length-1)/2);dem[i]=values[medianIndex];}}var box2=new _three2.default.Box2();box2.expandByPoint(new _three2.default.Vector3(boundingBox.min.x,boundingBox.min.z));box2.expandByPoint(new _three2.default.Vector3(boundingBox.max.x,boundingBox.max.z));var result={boundingBox:boundingBox,boundingBox2D:box2,dem:dem,demSize:demSize}; //if(node.level == 2){
	//  var geometry = new THREE.BufferGeometry();
	//  var vertices = new Float32Array((demSize-1)*(demSize-1)*2*3*3);
	//  var offset = 0;
	//  for(var i = 0; i < demSize-1; i++){
	//    for(var j = 0; j < demSize-1; j++){
	//      //var offset = 18*i + 18*j*demSize;
	//      
	//      var dx = i;
	//      var dy = j;
	//      
	//      var v1 = toWorld(dx, dy);
	//      var v2 = toWorld(dx+1, dy);
	//      var v3 = toWorld(dx+1, dy+1);
	//      var v4 = toWorld(dx, dy+1);
	//      
	//      vertices[offset+0] = v3[0];
	//      vertices[offset+1] = v3[1];
	//      vertices[offset+2] = v3[2];
	//      
	//      vertices[offset+3] = v2[0];
	//      vertices[offset+4] = v2[1];
	//      vertices[offset+5] = v2[2];
	//      
	//      vertices[offset+6] = v1[0];
	//      vertices[offset+7] = v1[1];
	//      vertices[offset+8] = v1[2];
	//      
	//      
	//      vertices[offset+9 ] = v3[0];
	//      vertices[offset+10] = v3[1];
	//      vertices[offset+11] = v3[2];
	//      
	//      vertices[offset+12] = v1[0];
	//      vertices[offset+13] = v1[1];
	//      vertices[offset+14] = v1[2];
	//      
	//      vertices[offset+15] = v4[0];
	//      vertices[offset+16] = v4[1];
	//      vertices[offset+17] = v4[2];
	//           
	//          
	//      
	//      //var x = (dx * bbSize.min.x) / demSize + boundingBox.min.x;
	//      //var y = (dy * bbSize.min.y) / demSize + boundingBox.min.y;
	//      //var z = dem[dx + dy * demSize];
	//      
	//      offset += 18;
	//      
	//    }
	//  }
	//  
	//  geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	//  geometry.computeFaceNormals();
	//  geometry.computeVertexNormals();
	//  
	//  var material = new THREE.MeshNormalMaterial( { color: 0xff0000, shading: THREE.SmoothShading } );
	//  var mesh = new THREE.Mesh( geometry, material );
	//  scene.add(mesh);
	//}
	//
	//
	//if(node.level == 0){
	//  scene.add(mesh);
	//  
	//  var demb = new Uint8Array(demSize*demSize*4);
	//  for(var i = 0; i < demSize*demSize; i++){
	//    demb[4*i + 0] = 255 * dem[i] / 300;
	//    demb[4*i + 1] = 255 * dem[i] / 300;
	//    demb[4*i + 2] = 255 * dem[i] / 300;
	//    demb[4*i + 3] = 255;
	//  }
	//
	//  var img = pixelsArrayToImage(demb, demSize, demSize);
	//  img.style.boder = "2px solid red";
	//  img.style.position = "absolute";
	//  img.style.top  = "0px";
	//  img.style.width = "400px";
	//  img.style.height = "200px";
	//  var txt = document.createElement("div");
	//  txt.innerHTML = node.name;
	//  //document.body.appendChild(txt);
	//  document.body.appendChild(img);
	//}
	var end=new Date().getTime();var duration=end-start;demTime+=duration;return result;};Potree.PointCloudOctree.prototype.getDEMHeight=function(position){var pos2=new _three2.default.Vector2(position.x,position.z);var demHeight=function demHeight(dem){var demSize=dem.demSize;var box=dem.boundingBox2D;var insideBox=box.containsPoint(pos2);if(box.containsPoint(pos2)){var uv=pos2.clone().sub(box.min).divide(box.size());var xy=uv.clone().multiplyScalar(demSize);var demHeight=0;if(xy.x>0.5&&xy.x<demSize-0.5&&xy.y>0.5&&xy.y<demSize-0.5){var i=Math.floor(xy.x-0.5);var j=Math.floor(xy.y-0.5);i=i===demSize-1?demSize-2:i;j=j===demSize-1?demSize-2:j;var u=xy.x-i-0.5;var v=xy.y-j-0.5;var index00=i+j*demSize;var index10=i+1+j*demSize;var index01=i+(j+1)*demSize;var index11=i+1+(j+1)*demSize;var height00=dem.dem[index00];var height10=dem.dem[index10];var height01=dem.dem[index01];var height11=dem.dem[index11];if(height00===0||height10===0||height01===0||height11===0){demHeight=null;}else {var hx1=height00*(1-u)+height10*u;var hx2=height01*(1-u)+height11*u;demHeight=hx1*(1-v)+hx2*v;}var bla;}else {xy.x=Math.min(parseInt(Math.min(xy.x,demSize)),demSize-1);xy.y=Math.min(parseInt(Math.min(xy.y,demSize)),demSize-1);var index=xy.x+xy.y*demSize;demHeight=dem.dem[index];}return demHeight;}return null;};var height=null;var stack=[];var chosenNode=null;if(this.root.dem){stack.push(this.root);}while(stack.length>0){var node=stack.shift();var dem=node.dem;var demSize=dem.demSize;var box=dem.boundingBox2D;var insideBox=box.containsPoint(pos2);if(!box.containsPoint(pos2)){continue;}var dh=demHeight(dem);if(!height){height=dh;}else if(dh!=null&&dh>0){height=dh;}if(node.level<=2){for(var i=0;i<node.children.length;i++){var child=node.children[i];if(child.dem){stack.push(child);}}}}return height;};Potree.PointCloudOctree.prototype.generateTerain=function(){var bb=this.boundingBox.clone().applyMatrix4(this.matrixWorld);var width=300;var height=300;var geometry=new _three2.default.BufferGeometry();var vertices=new Float32Array(width*height*3);var offset=0;for(var i=0;i<width;i++){for(var j=0;j<height;j++){var u=i/width;var v=j/height;var x=u*bb.size().x+bb.min.x;var z=v*bb.size().z+bb.min.z;var y=this.getDEMHeight(new _three2.default.Vector3(x,0,z));if(!y){y=0;}vertices[offset+0]=x;vertices[offset+1]=y;vertices[offset+2]=z; //var sm = new THREE.Mesh(sg);
	//sm.position.set(x,y,z);
	//scene.add(sm);
	offset+=3;}}geometry.addAttribute('position',new _three2.default.BufferAttribute(vertices,3));var material=new _three2.default.PointCloudMaterial({size:20,color:0x00ff00});var pc=new _three2.default.PointCloud(geometry,material);scene.add(pc);};Object.defineProperty(Potree.PointCloudOctree.prototype,"progress",{get:function get(){return this.visibleNodes.length/this.visibleGeometry.length;}});var nodesLoadTimes={};Potree.PointCloudOctreeGeometry=function(){Potree.PointCloudOctree.lru=Potree.PointCloudOctree.lru||new LRU();this.url=null;this.octreeDir=null;this.spacing=0;this.boundingBox=null;this.root=null;this.numNodesLoading=0;this.nodes=null;this.pointAttributes=null;this.hierarchyStepSize=-1;this.loader=null;};Potree.PointCloudOctreeGeometryNode=function(name,pcoGeometry,boundingBox){this.id=Potree.PointCloudOctreeGeometryNode.IDCount++;this.name=name;this.index=parseInt(name.charAt(name.length-1));this.pcoGeometry=pcoGeometry;this.geometry=null;this.boundingBox=boundingBox;this.boundingSphere=boundingBox.getBoundingSphere();this.children={};this.numPoints=0;this.level=null;};Potree.PointCloudOctreeGeometryNode.IDCount=0;Potree.PointCloudOctreeGeometryNode.prototype.getURL=function(){var url="";var version=this.pcoGeometry.loader.version;if(version.equalOrHigher("1.5")){url=this.pcoGeometry.octreeDir+"/"+this.getHierarchyPath()+"/"+this.name;}else if(version.equalOrHigher("1.4")){url=this.pcoGeometry.octreeDir+"/"+this.name;}else if(version.upTo("1.3")){url=this.pcoGeometry.octreeDir+"/"+this.name;}return url;};Potree.PointCloudOctreeGeometryNode.prototype.getHierarchyPath=function(){var path="r/";var hierarchyStepSize=this.pcoGeometry.hierarchyStepSize;var indices=this.name.substr(1);var numParts=Math.floor(indices.length/hierarchyStepSize);for(var i=0;i<numParts;i++){path+=indices.substr(i*hierarchyStepSize,hierarchyStepSize)+"/";}path=path.slice(0,-1);return path;};Potree.PointCloudOctreeGeometryNode.prototype.addChild=function(child){this.children[child.index]=child;child.parent=this;};Potree.PointCloudOctreeGeometryNode.prototype.load=function(){if(this.loading===true||this.pcoGeometry.numNodesLoading>3){return;}this.loading=true; //if(Potree.PointCloudOctree.lru.numPoints + this.numPoints >= Potree.pointLoadLimit){
	//  Potree.PointCloudOctree.disposeLeastRecentlyUsed(this.numPoints);
	//}
	this.pcoGeometry.numNodesLoading++;if(this.pcoGeometry.loader.version.equalOrHigher("1.5")){if(this.level%this.pcoGeometry.hierarchyStepSize===0&&this.hasChildren){this.loadHierachyThenPoints();}else {this.loadPoints();}}else {this.loadPoints();}};Potree.PointCloudOctreeGeometryNode.prototype.loadPoints=function(){this.pcoGeometry.loader.load(this);};Potree.PointCloudOctreeGeometryNode.prototype.loadHierachyThenPoints=function(){var node=this; // load hierarchy
	var callback=function callback(node,hbuffer){var count=hbuffer.byteLength/5;var view=new DataView(hbuffer);var stack=[];var children=view.getUint8(0);var numPoints=view.getUint32(1,true);node.numPoints=numPoints;stack.push({children:children,numPoints:numPoints,name:node.name});var decoded=[];var offset=5;while(stack.length>0){var snode=stack.shift();var mask=1;for(var i=0;i<8;i++){if((snode.children&mask)!==0){var childIndex=i;var childName=snode.name+i;var childChildren=view.getUint8(offset);var childNumPoints=view.getUint32(offset+1,true);stack.push({children:childChildren,numPoints:childNumPoints,name:childName});decoded.push({children:childChildren,numPoints:childNumPoints,name:childName});offset+=5;}mask=mask*2;}if(offset===hbuffer.byteLength){break;}} //console.log(decoded);
	var nodes={};nodes[node.name]=node;var pco=node.pcoGeometry;for(var i=0;i<decoded.length;i++){var name=decoded[i].name;var numPoints=decoded[i].numPoints;var index=parseInt(name.charAt(name.length-1));var parentName=name.substring(0,name.length-1);var parentNode=nodes[parentName];var level=name.length-1;var boundingBox=Potree.POCLoader.createChildAABB(parentNode.boundingBox,index);var currentNode=new Potree.PointCloudOctreeGeometryNode(name,pco,boundingBox);currentNode.level=level;currentNode.numPoints=numPoints;currentNode.hasChildren=decoded[i].children>0;parentNode.addChild(currentNode);nodes[name]=currentNode;}node.loadPoints();};if(node.level%node.pcoGeometry.hierarchyStepSize===0){ //var hurl = node.pcoGeometry.octreeDir + "/../hierarchy/" + node.name + ".hrc";
	var hurl=node.pcoGeometry.octreeDir+"/"+node.getHierarchyPath()+"/"+node.name+".hrc";var xhr=new XMLHttpRequest();xhr.open('GET',hurl,true);xhr.responseType='arraybuffer';xhr.overrideMimeType('text/plain; charset=x-user-defined');xhr.onreadystatechange=function(){if(xhr.readyState===4){if(xhr.status===200||xhr.status===0){var hbuffer=xhr.response;callback(node,hbuffer);}else {console.log('Failed to load file! HTTP status: '+xhr.status+", file: "+url);}}};try{xhr.send(null);}catch(e){console.log("fehler beim laden der punktwolke: "+e);}}};Potree.PointCloudOctreeGeometryNode.prototype.dispose=function(){if(this.geometry){this.geometry.dispose();this.geometry=null;this.loaded=false;}};Potree.utils=function(){};Potree.utils.pathExists=function(url){var req=new XMLHttpRequest();req.open('GET',url,false);req.send(null);if(req.status!==200){return false;}return true;}; /**
	 * adapted from mhluska at https://github.com/mrdoob/three.js/issues/1561
	 */Potree.utils.computeTransformedBoundingBox=function(box,transform){var vertices=[new _three2.default.Vector3(box.min.x,box.min.y,box.min.z).applyMatrix4(transform),new _three2.default.Vector3(box.min.x,box.min.y,box.min.z).applyMatrix4(transform),new _three2.default.Vector3(box.max.x,box.min.y,box.min.z).applyMatrix4(transform),new _three2.default.Vector3(box.min.x,box.max.y,box.min.z).applyMatrix4(transform),new _three2.default.Vector3(box.min.x,box.min.y,box.max.z).applyMatrix4(transform),new _three2.default.Vector3(box.min.x,box.max.y,box.max.z).applyMatrix4(transform),new _three2.default.Vector3(box.max.x,box.max.y,box.min.z).applyMatrix4(transform),new _three2.default.Vector3(box.max.x,box.min.y,box.max.z).applyMatrix4(transform),new _three2.default.Vector3(box.max.x,box.max.y,box.max.z).applyMatrix4(transform)];var boundingBox=new _three2.default.Box3();boundingBox.setFromPoints(vertices);return boundingBox;}; /**
	 * add separators to large numbers
	 * 
	 * @param nStr
	 * @returns
	 */Potree.utils.addCommas=function(nStr){nStr+='';x=nStr.split('.');x1=x[0];x2=x.length>1?'.'+x[1]:'';var rgx=/(\d+)(\d{3})/;while(rgx.test(x1)){x1=x1.replace(rgx,'$1'+','+'$2');}return x1+x2;}; /**
	 * create worker from a string
	 *
	 * code from http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string
	 */Potree.utils.createWorker=function(code){var blob=new Blob([code],{type:'application/javascript'});var worker=new Worker(URL.createObjectURL(blob));return worker;};Potree.utils.loadSkybox=function(path){var camera=new _three2.default.PerspectiveCamera(75,window.innerWidth/window.innerHeight,1,100000);var scene=new _three2.default.Scene();var format=".jpg";var urls=[path+'px'+format,path+'nx'+format,path+'py'+format,path+'ny'+format,path+'pz'+format,path+'nz'+format];var textureCube=_three2.default.ImageUtils.loadTextureCube(urls,_three2.default.CubeRefractionMapping);var shader={uniforms:{"tCube":{type:"t",value:textureCube},"tFlip":{type:"f",value:-1}},vertexShader:_three2.default.ShaderLib["cube"].vertexShader,fragmentShader:_three2.default.ShaderLib["cube"].fragmentShader};var material=new _three2.default.ShaderMaterial({fragmentShader:shader.fragmentShader,vertexShader:shader.vertexShader,uniforms:shader.uniforms,depthWrite:false,side:_three2.default.BackSide});var mesh=new _three2.default.Mesh(new _three2.default.BoxGeometry(100,100,100),material);scene.add(mesh);return {"camera":camera,"scene":scene};};Potree.utils.createGrid=function createGrid(width,length,spacing,color){var material=new _three2.default.LineBasicMaterial({color:color||0x888888});var geometry=new _three2.default.Geometry();for(var i=0;i<=length;i++){geometry.vertices.push(new _three2.default.Vector3(-(spacing*width)/2,0,i*spacing-spacing*length/2));geometry.vertices.push(new _three2.default.Vector3(+(spacing*width)/2,0,i*spacing-spacing*length/2));}for(var i=0;i<=width;i++){geometry.vertices.push(new _three2.default.Vector3(i*spacing-spacing*width/2,0,-(spacing*length)/2));geometry.vertices.push(new _three2.default.Vector3(i*spacing-spacing*width/2,0,+(spacing*length)/2));}var line=new _three2.default.Line(geometry,material,_three2.default.LinePieces);line.receiveShadow=true;return line;};Potree.utils.createBackgroundTexture=function(width,height){function gauss(x,y){return 1/(2*Math.PI)*Math.exp(-(x*x+y*y)/2);};var map=_three2.default.ImageUtils.generateDataTexture(width,height,new _three2.default.Color());map.magFilter=_three2.default.NearestFilter;var data=map.image.data; //var data = new Uint8Array(width*height*4);
	var chroma=[1,1.5,1.7];var max=gauss(0,0);for(var x=0;x<width;x++){for(var y=0;y<height;y++){var u=2*(x/width)-1;var v=2*(y/height)-1;var i=x+width*y;var d=gauss(2*u,2*v)/max;var r=(Math.random()+Math.random()+Math.random())/3;r=(d*0.5+0.5)*r*0.03;r=r*0.4; //d = Math.pow(d, 0.6);
	data[3*i+0]=255*(d/15+0.05+r)*chroma[0];data[3*i+1]=255*(d/15+0.05+r)*chroma[1];data[3*i+2]=255*(d/15+0.05+r)*chroma[2]; //data[4*i+3] = 255;
	}}return map;};function getMousePointCloudIntersection(mouse,camera,renderer,pointclouds){var vector=new _three2.default.Vector3(mouse.x,mouse.y,0.5);vector.unproject(camera);var direction=vector.sub(camera.position).normalize();var ray=new _three2.default.Ray(camera.position,direction);var closestPoint=null;var closestPointDistance=null;for(var i=0;i<pointclouds.length;i++){var pointcloud=pointclouds[i];var point=pointcloud.pick(renderer,camera,ray);if(!point){continue;}var distance=camera.position.distanceTo(point.position);if(!closestPoint||distance<closestPointDistance){closestPoint=point;closestPointDistance=distance;}}return closestPoint?closestPoint.position:null;}function pixelsArrayToImage(pixels,width,height){var canvas=document.createElement('canvas');canvas.width=width;canvas.height=height;var context=canvas.getContext('2d');pixels=new pixels.constructor(pixels);for(var i=0;i<pixels.length;i++){pixels[i*4+3]=255;}var imageData=context.createImageData(width,height);imageData.data.set(pixels);context.putImageData(imageData,0,0);var img=new Image();img.src=canvas.toDataURL();img.style.transform="scaleY(-1)";return img;}function projectedRadius(radius,fov,distance,screenHeight){var projFactor=1/Math.tan(fov/2)/distance;projFactor=projFactor*screenHeight/2;return radius*projFactor;};Potree.utils.topView=function(camera,controls,pointcloud){camera.position.set(0,1,0);camera.rotation.set(-Math.PI/2,0,0);camera.zoomTo(pointcloud,1);if(controls.target){var sg=pointcloud.boundingSphere.clone().applyMatrix4(pointcloud.matrixWorld);var target=new _three2.default.Vector3(camera.position.x,sg.center.y,camera.position.z);controls.target.copy(target);}};Potree.utils.frontView=function(camera,controls,pointcloud){camera.position.set(0,0,1);camera.rotation.set(0,0,0);camera.zoomTo(pointcloud,1);if(controls.target){var sg=pointcloud.boundingSphere.clone().applyMatrix4(pointcloud.matrixWorld);var target=new _three2.default.Vector3(camera.position.x,camera.position.y,sg.center.z);controls.target.copy(target);}};Potree.utils.leftView=function(camera,controls,pointcloud){camera.position.set(-1,0,0);camera.rotation.set(0,-Math.PI/2,0);camera.zoomTo(pointcloud,1);if(controls.target){var sg=pointcloud.boundingSphere.clone().applyMatrix4(pointcloud.matrixWorld);var target=new _three2.default.Vector3(sg.center.x,camera.position.y,camera.position.z);controls.target.copy(target);}};Potree.utils.rightView=function(camera,controls,pointcloud){camera.position.set(1,0,0);camera.rotation.set(0,Math.PI/2,0);camera.zoomTo(pointcloud,1);if(controls.target){var sg=pointcloud.boundingSphere.clone().applyMatrix4(pointcloud.matrixWorld);var target=new _three2.default.Vector3(sg.center.x,camera.position.y,camera.position.z);controls.target.copy(target);}}; /**
	 *  
	 * 0: no intersection
	 * 1: intersection
	 * 2: fully inside
	 */Potree.utils.frustumSphereIntersection=function(frustum,sphere){var planes=frustum.planes;var center=sphere.center;var negRadius=-sphere.radius;var minDistance=Number.MAX_VALUE;for(var i=0;i<6;i++){var distance=planes[i].distanceToPoint(center);if(distance<negRadius){return 0;}minDistance=Math.min(minDistance,distance);}return minDistance>=sphere.radius?2:1;};Potree.utils.screenPass=new function(){this.screenScene=new _three2.default.Scene();this.screenQuad=new _three2.default.Mesh(new _three2.default.PlaneBufferGeometry(2,2,0));this.screenQuad.material.depthTest=true;this.screenQuad.material.depthWrite=true;this.screenQuad.material.transparent=true;this.screenScene.add(this.screenQuad);this.camera=new _three2.default.Camera();this.render=function(renderer,material,target){this.screenQuad.material=material;if((typeof target==='undefined'?'undefined':_typeof(target))===undefined){renderer.render(this.screenScene,this.camera);}else {renderer.render(this.screenScene,this.camera,target);}};}();Potree.Features=function(){var ftCanvas=document.createElement("canvas");var gl=ftCanvas.getContext("webgl")||ftCanvas.getContext("experimental-webgl");if(gl===null)return null; // -- code taken from THREE.WebGLRenderer --
	var _vertexShaderPrecisionHighpFloat=gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.HIGH_FLOAT);var _vertexShaderPrecisionMediumpFloat=gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.MEDIUM_FLOAT);var _vertexShaderPrecisionLowpFloat=gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.LOW_FLOAT);var _fragmentShaderPrecisionHighpFloat=gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT);var _fragmentShaderPrecisionMediumpFloat=gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.MEDIUM_FLOAT);var _fragmentShaderPrecisionLowpFloat=gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.LOW_FLOAT);var highpAvailable=_vertexShaderPrecisionHighpFloat.precision>0&&_fragmentShaderPrecisionHighpFloat.precision>0;var mediumpAvailable=_vertexShaderPrecisionMediumpFloat.precision>0&&_fragmentShaderPrecisionMediumpFloat.precision>0; // -----------------------------------------
	var precision;if(highpAvailable){precision="highp";}else if(mediumpAvailable){precision="mediump";}else {precision="lowp";}return {SHADER_INTERPOLATION:{isSupported:function isSupported(){ //if(typeof this.shaderInterpolationSupported === "undefined"){
	//  var material = new Potree.PointCloudMaterial();
	//  material.interpolate = true;
	//
	//  var vs = gl.createShader(gl.VERTEX_SHADER);
	//  var fs = gl.createShader(gl.FRAGMENT_SHADER);
	//  gl.shaderSource(vs, material.vertexShader);
	//  gl.shaderSource(fs, material.fragmentShader);
	//
	//  gl.compileShader(vs);
	//  gl.compileShader(fs);
	//
	//  var successVS = gl.getShaderParameter(vs, gl.COMPILE_STATUS);
	//  var successFS = gl.getShaderParameter(fs, gl.COMPILE_STATUS);
	//  this.shaderInterpolationSupported = successVS && successFS;
	//}
	//
	//return this.shaderInterpolationSupported;
	var supported=true;supported=supported&&gl.getExtension("EXT_frag_depth");supported=supported&&gl.getParameter(gl.MAX_VARYING_VECTORS)>=8;return supported;}},SHADER_SPLATS:{isSupported:function isSupported(){var supported=true;supported=supported&&gl.getExtension("EXT_frag_depth");supported=supported&&gl.getExtension("OES_texture_float");supported=supported&&gl.getParameter(gl.MAX_VARYING_VECTORS)>=8;return supported;}},SHADER_EDL:{isSupported:function isSupported(){var supported=true;supported=supported&&gl.getExtension("EXT_frag_depth");supported=supported&&gl.getExtension("OES_texture_float");supported=supported&&gl.getParameter(gl.MAX_VARYING_VECTORS)>=8;return supported;}},precision:precision};}(); /**
	 * adapted from http://stemkoski.github.io/Three.js/Sprite-Text-Labels.html
	 */Potree.TextSprite=function(text){_three2.default.Object3D.call(this);var texture=new _three2.default.Texture();texture.minFilter=_three2.default.LinearFilter;texture.magFilter=_three2.default.LinearFilter;var spriteMaterial=new _three2.default.SpriteMaterial({map:texture,useScreenCoordinates:false});this.material=spriteMaterial;this.sprite=new _three2.default.Sprite(spriteMaterial);this.add(this.sprite); //THREE.Sprite.call(this, spriteMaterial);
	this.borderThickness=4;this.fontface="Arial";this.fontsize=28;this.borderColor={r:0,g:0,b:0,a:1.0};this.backgroundColor={r:255,g:255,b:255,a:1.0};this.textColor={r:255,g:255,b:255,a:1.0};this.text="";this.setText(text);};Potree.TextSprite.prototype=new _three2.default.Object3D();Potree.TextSprite.prototype.setText=function(text){this.text=text;this.update();};Potree.TextSprite.prototype.setTextColor=function(color){this.textColor=color;this.update();};Potree.TextSprite.prototype.setBorderColor=function(color){this.borderColor=color;this.update();};Potree.TextSprite.prototype.setBackgroundColor=function(color){this.backgroundColor=color;this.update();};Potree.TextSprite.prototype.update=function(){var canvas=document.createElement('canvas');var context=canvas.getContext('2d');context.font="Bold "+this.fontsize+"px "+this.fontface; // get size data (height depends only on font size)
	var metrics=context.measureText(this.text);var textWidth=metrics.width;var spriteWidth=textWidth+2*this.borderThickness;var spriteHeight=this.fontsize*1.4+2*this.borderThickness;var canvas=document.createElement('canvas');var context=canvas.getContext('2d');context.canvas.width=spriteWidth;context.canvas.height=spriteHeight;context.font="Bold "+this.fontsize+"px "+this.fontface; // background color
	context.fillStyle="rgba("+this.backgroundColor.r+","+this.backgroundColor.g+","+this.backgroundColor.b+","+this.backgroundColor.a+")"; // border color
	context.strokeStyle="rgba("+this.borderColor.r+","+this.borderColor.g+","+this.borderColor.b+","+this.borderColor.a+")";context.lineWidth=this.borderThickness;this.roundRect(context,this.borderThickness/2,this.borderThickness/2,textWidth+this.borderThickness,this.fontsize*1.4+this.borderThickness,6); // text color
	context.strokeStyle="rgba(0, 0, 0, 1.0)";context.strokeText(this.text,this.borderThickness,this.fontsize+this.borderThickness);context.fillStyle="rgba("+this.textColor.r+","+this.textColor.g+","+this.textColor.b+","+this.textColor.a+")";context.fillText(this.text,this.borderThickness,this.fontsize+this.borderThickness);var texture=new _three2.default.Texture(canvas);texture.minFilter=_three2.default.LinearFilter;texture.magFilter=_three2.default.LinearFilter;texture.needsUpdate=true; //var spriteMaterial = new THREE.SpriteMaterial( 
	//  { map: texture, useScreenCoordinates: false } );
	this.sprite.material.map=texture;this.sprite.scale.set(spriteWidth*0.01,spriteHeight*0.01,1.0); //this.material = spriteMaterial;             
	};Potree.TextSprite.prototype.roundRect=function(ctx,x,y,w,h,r){ctx.beginPath();ctx.moveTo(x+r,y);ctx.lineTo(x+w-r,y);ctx.quadraticCurveTo(x+w,y,x+w,y+r);ctx.lineTo(x+w,y+h-r);ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);ctx.lineTo(x+r,y+h);ctx.quadraticCurveTo(x,y+h,x,y+h-r);ctx.lineTo(x,y+r);ctx.quadraticCurveTo(x,y,x+r,y);ctx.closePath();ctx.fill();ctx.stroke();};Potree.Version=function(version){this.version=version;var vmLength=version.indexOf(".")===-1?version.length:version.indexOf(".");this.versionMajor=parseInt(version.substr(0,vmLength));this.versionMinor=parseInt(version.substr(vmLength+1));if(this.versionMinor.length===0){this.versionMinor=0;}};Potree.Version.prototype.newerThan=function(version){var v=new Potree.Version(version);if(this.versionMajor>v.versionMajor){return true;}else if(this.versionMajor===v.versionMajor&&this.versionMinor>v.versionMinor){return true;}else {return false;}};Potree.Version.prototype.equalOrHigher=function(version){var v=new Potree.Version(version);if(this.versionMajor>v.versionMajor){return true;}else if(this.versionMajor===v.versionMajor&&this.versionMinor>=v.versionMinor){return true;}else {return false;}};Potree.Version.prototype.upTo=function(version){return !this.newerThan(version);};Potree.Measure=function(){var scope=this;_three2.default.Object3D.call(this);this.points=[];this._showDistances=true;this._showArea=true;this._closed=true;this.maxMarkers=Number.MAX_SAFE_INTEGER;this.spheres=[];this.edges=[];this.sphereLabels=[];this.edgeLabels=[];this.angleLabels=[];this.areaLabel=new Potree.TextSprite("");this.areaLabel.setBorderColor({r:0,g:255,b:0,a:0.0});this.areaLabel.setBackgroundColor({r:0,g:255,b:0,a:0.0});this.areaLabel.setTextColor({r:180,g:220,b:180,a:1.0});this.areaLabel.material.depthTest=false;this.areaLabel.material.opacity=1;this.add(this.areaLabel);var sphereGeometry=new _three2.default.SphereGeometry(0.4,10,10);this.color=new _three2.default.Color(0xff0000);var createSphereMaterial=function createSphereMaterial(){var sphereMaterial=new _three2.default.MeshLambertMaterial({shading:_three2.default.SmoothShading,color:scope.color,ambient:0xaaaaaa,depthTest:false,depthWrite:false});return sphereMaterial;};var moveEvent=function moveEvent(event){event.target.material.emissive.setHex(0x888888);};var leaveEvent=function leaveEvent(event){event.target.material.emissive.setHex(0x000000);};var dragEvent=function dragEvent(event){var tool=event.tool;var dragstart=tool.dragstart;var mouse=tool.mouse;var I=tool.getMousePointCloudIntersection();if(I){var index=scope.spheres.indexOf(tool.dragstart.object);scope.setPosition(index,I);} //event.event.stopImmediatePropagation();
	};var dropEvent=function dropEvent(event){};this.addMarker=function(point){this.points.push(point); // sphere
	var sphere=new _three2.default.Mesh(sphereGeometry,createSphereMaterial());sphere.addEventListener("move",moveEvent);sphere.addEventListener("leave",leaveEvent);sphere.addEventListener("drag",dragEvent);sphere.addEventListener("drop",dropEvent);this.add(sphere);this.spheres.push(sphere);{ // edges
	var lineGeometry=new _three2.default.Geometry();lineGeometry.vertices.push(new _three2.default.Vector3(),new _three2.default.Vector3());lineGeometry.colors.push(this.color,this.color,this.color);var lineMaterial=new _three2.default.LineBasicMaterial({linewidth:1});lineMaterial.depthTest=false;var edge=new _three2.default.Line(lineGeometry,lineMaterial);edge.visible=true;this.add(edge);this.edges.push(edge);}{ // edge labels
	var edgeLabel=new Potree.TextSprite(0);edgeLabel.setBorderColor({r:0,g:255,b:0,a:0.0});edgeLabel.setBackgroundColor({r:0,g:255,b:0,a:0.0});edgeLabel.material.depthTest=false;edgeLabel.visible=false;this.edgeLabels.push(edgeLabel);this.add(edgeLabel);}{ // angle labels
	var angleLabel=new Potree.TextSprite();angleLabel.setBorderColor({r:0,g:255,b:0,a:0.0});angleLabel.setBackgroundColor({r:0,g:255,b:0,a:0.0});angleLabel.material.depthTest=false;angleLabel.material.opacity=1;angleLabel.visible=false;this.angleLabels.push(angleLabel);this.add(angleLabel);}var event={type:"marker_added",measurement:this};this.dispatchEvent(event);this.setPosition(this.points.length-1,point);};this.removeMarker=function(index){this.points.splice(index,1);this.remove(this.spheres[index]);var edgeIndex=index==0?0:index-1;this.remove(this.edges[edgeIndex]);this.edges.splice(edgeIndex,1);this.remove(this.edgeLabels[edgeIndex]);this.edgeLabels.splice(edgeIndex,1);this.spheres.splice(index,1);this.update();};this.setPosition=function(index,position){var point=this.points[index];point.copy(position);var event={type:'marker_moved',measure:this,index:index,position:position.clone()};this.dispatchEvent(event);this.update();};this.getArea=function(){var area=0;var j=this.points.length-1;for(var i=0;i<this.points.length;i++){var p1=this.points[i];var p2=this.points[j];area+=(p2.x+p1.x)*(p1.z-p2.z);j=i;}return Math.abs(area/2);};this.getAngleBetweenLines=function(cornerPoint,point1,point2){var v1=new _three2.default.Vector3().subVectors(point1,cornerPoint);var v2=new _three2.default.Vector3().subVectors(point2,cornerPoint);return v1.angleTo(v2);};this.update=function(){if(this.points.length===0){return;}else if(this.points.length===1){var point=this.points[0];this.spheres[0].position.copy(point);return;}var lastIndex=this.points.length-1;var centroid=new _three2.default.Vector3();for(var i=0;i<=lastIndex;i++){var point=this.points[i];centroid.add(point);}centroid.divideScalar(this.points.length);for(var i=0;i<=lastIndex;i++){var index=i;var nextIndex=i+1>lastIndex?0:i+1;var previousIndex=i===0?lastIndex:i-1;var point=this.points[index];var nextPoint=this.points[nextIndex];var previousPoint=this.points[previousIndex];var sphere=this.spheres[index]; // spheres
	sphere.position.copy(point);sphere.material.color=scope.color;{ // edges
	var edge=this.edges[index];edge.material.color=this.color;edge.geometry.vertices[0].copy(point);edge.geometry.vertices[1].copy(nextPoint);edge.geometry.verticesNeedUpdate=true;edge.geometry.computeBoundingSphere();edge.visible=index<lastIndex||this.closed;}{ // edge labels
	var edgeLabel=this.edgeLabels[i];var center=new _three2.default.Vector3().add(point);center.add(nextPoint);center=center.multiplyScalar(0.5);var distance=point.distanceTo(nextPoint);edgeLabel.position.copy(center);edgeLabel.setText(distance.toFixed(2));edgeLabel.visible=this.showDistances&&(index<lastIndex||this.closed)&&this.points.length>=2&&distance>0;}{ // angle labels
	var angleLabel=this.angleLabels[i];var angle=this.getAngleBetweenLines(point,previousPoint,nextPoint);var dir=nextPoint.clone().sub(previousPoint);dir.multiplyScalar(0.5);dir=previousPoint.clone().add(dir).sub(point).normalize();var dist=Math.min(point.distanceTo(previousPoint),point.distanceTo(nextPoint));dist=dist/9;var labelPos=point.clone().add(dir.multiplyScalar(dist));angleLabel.position.copy(labelPos);var msg=Potree.utils.addCommas((angle*(180.0/Math.PI)).toFixed(1))+'';angleLabel.setText(msg);angleLabel.visible=this.showAngles&&(index<lastIndex||this.closed)&&this.points.length>=3&&angle>0;}} // update area label
	this.areaLabel.position.copy(centroid);this.areaLabel.visible=this.showArea&&this.points.length>=3;var msg=Potree.utils.addCommas(this.getArea().toFixed(1))+"";this.areaLabel.setText(msg);};this.raycast=function(raycaster,intersects){for(var i=0;i<this.points.length;i++){var sphere=this.spheres[i];sphere.raycast(raycaster,intersects);} // recalculate distances because they are not necessarely correct
	// for scaled objects.
	// see https://github.com/mrdoob/three.js/issues/5827
	// TODO: remove this once the bug has been fixed
	for(var i=0;i<intersects.length;i++){var I=intersects[i];I.distance=raycaster.ray.origin.distanceTo(I.point);}intersects.sort(function(a,b){return a.distance-b.distance;});};};Potree.Measure.prototype=Object.create(_three2.default.Object3D.prototype);Object.defineProperty(Potree.Measure.prototype,"showArea",{get:function get(){return this._showArea;},set:function set(value){this._showArea=value;this.update();}});Object.defineProperty(Potree.Measure.prototype,"closed",{get:function get(){return this._closed;},set:function set(value){this._closed=value;this.update();}});Object.defineProperty(Potree.Measure.prototype,"showDistances",{get:function get(){return this._showDistances;},set:function set(value){this._showDistances=value;this.update();}});Potree.MeasuringTool=function(scene,camera,renderer){var scope=this;this.enabled=false;this.scene=scene;this.camera=camera;this.renderer=renderer;this.domElement=renderer.domElement;this.mouse={x:0,y:0};var STATE={DEFAULT:0,INSERT:1};var state=STATE.DEFAULT;this.activeMeasurement;this.measurements=[];this.sceneMeasurement=new _three2.default.Scene();this.sceneRoot=new _three2.default.Object3D();this.sceneMeasurement.add(this.sceneRoot);this.light=new _three2.default.DirectionalLight(0xffffff,1);this.light.position.set(0,0,10);this.light.lookAt(new _three2.default.Vector3(0,0,0));this.sceneMeasurement.add(this.light);this.hoveredElement=null;function onClick(event){if(state===STATE.INSERT){var I=scope.getMousePointCloudIntersection();if(I){var pos=I.clone();scope.activeMeasurement.addMarker(pos);var event={type:'newpoint',position:pos.clone()};scope.dispatchEvent(event);if(scope.activeMeasurement.points.length>scope.activeMeasurement.maxMarkers){scope.finishInsertion();}}}};function onMouseMove(event){var rect=scope.domElement.getBoundingClientRect();scope.mouse.x=(event.clientX-rect.left)/scope.domElement.clientWidth*2-1;scope.mouse.y=-((event.clientY-rect.top)/scope.domElement.clientHeight)*2+1;if(scope.dragstart){var arg={type:"drag",event:event,tool:scope};scope.dragstart.object.dispatchEvent(arg);}else if(state==STATE.INSERT&&scope.activeMeasurement){var I=scope.getMousePointCloudIntersection();if(I){var lastIndex=scope.activeMeasurement.points.length-1;scope.activeMeasurement.setPosition(lastIndex,I);}}else {var I=getHoveredElement();if(I){I.object.dispatchEvent({type:"move",target:I.object,event:event});if(scope.hoveredElement&&scope.hoveredElement!==I.object){scope.hoveredElement.dispatchEvent({type:"leave",target:scope.hoveredElement,event:event});}scope.hoveredElement=I.object;}else {if(scope.hoveredElement){scope.hoveredElement.dispatchEvent({type:"leave",target:scope.hoveredElement,event:event});}scope.hoveredElement=null;}}};function onRightClick(event){if(state==STATE.INSERT){scope.finishInsertion();}}this.getState=function(){ // TODO remove
	return state;};function onMouseDown(event){if(event.which===1){if(state!==STATE.DEFAULT){event.stopImmediatePropagation();}var I=getHoveredElement();if(I){scope.dragstart={object:I.object,sceneClickPos:I.point,sceneStartPos:scope.sceneRoot.position.clone(),mousePos:{x:scope.mouse.x,y:scope.mouse.y}};event.stopImmediatePropagation();}}else if(event.which===3){onRightClick(event);}}function onDoubleClick(event){ // fix move event after double click
	// see: http://stackoverflow.com/questions/8125165/event-listener-for-dblclick-causes-event-for-mousemove-to-not-work-and-show-a-ci
	if(window.getSelection){window.getSelection().removeAllRanges();}else if(document.selection){document.selection.empty();}if(scope.activeMeasurement&&state===STATE.INSERT){scope.activeMeasurement.removeMarker(scope.activeMeasurement.points.length-1);scope.finishInsertion();}}function onMouseUp(event){if(scope.dragstart){scope.dragstart.object.dispatchEvent({type:"drop",event:event});scope.dragstart=null;}}function getHoveredElement(){var vector=new _three2.default.Vector3(scope.mouse.x,scope.mouse.y,0.5);vector.unproject(scope.camera);var raycaster=new _three2.default.Raycaster();raycaster.ray.set(scope.camera.position,vector.sub(scope.camera.position).normalize());var spheres=[];for(var i=0;i<scope.measurements.length;i++){var m=scope.measurements[i];for(var j=0;j<m.spheres.length;j++){spheres.push(m.spheres[j]);}}var intersections=raycaster.intersectObjects(spheres,true);if(intersections.length>0){return intersections[0];}else {return false;}};this.getMousePointCloudIntersection=function(){var vector=new _three2.default.Vector3(scope.mouse.x,scope.mouse.y,0.5);vector.unproject(scope.camera);var direction=vector.sub(scope.camera.position).normalize();var ray=new _three2.default.Ray(scope.camera.position,direction);var pointClouds=[];scope.scene.traverse(function(object){if(object instanceof Potree.PointCloudOctree||object instanceof Potree.PointCloudArena4D){pointClouds.push(object);}});var closestPoint=null;var closestPointDistance=null;for(var i=0;i<pointClouds.length;i++){var pointcloud=pointClouds[i];var point=pointcloud.pick(scope.renderer,scope.camera,ray);if(!point){continue;}var distance=scope.camera.position.distanceTo(point.position);if(!closestPoint||distance<closestPointDistance){closestPoint=point;closestPointDistance=distance;}}return closestPoint?closestPoint.position:null;};this.startInsertion=function(args){state=STATE.INSERT;var args=args||{};var showDistances=typeof args.showDistances!="undefined"?args.showDistances:true;var showArea=typeof args.showArea!="undefined"?args.showArea:false;var showAngles=typeof args.showAngles!="undefined"?args.showAngles:false;var closed=typeof args.closed!="undefined"?args.closed:false;var maxMarkers=args.maxMarkers||Number.MAX_SAFE_INTEGER;var measurement=new Potree.Measure();measurement.showDistances=showDistances;measurement.showArea=showArea;measurement.showAngles=showAngles;measurement.closed=closed;measurement.maxMarkers=maxMarkers;this.addMeasurement(measurement);measurement.addMarker(new _three2.default.Vector3(0,0,0));this.activeMeasurement=measurement;};this.finishInsertion=function(){this.activeMeasurement.removeMarker(this.activeMeasurement.points.length-1);var event={type:"insertion_finished",measurement:this.activeMeasurement};this.dispatchEvent(event);this.activeMeasurement=null;state=STATE.DEFAULT;};this.addMeasurement=function(measurement){this.sceneMeasurement.add(measurement);this.measurements.push(measurement);this.dispatchEvent({"type":"measurement_added",measurement:measurement});measurement.addEventListener("marker_added",function(event){scope.dispatchEvent(event);});measurement.addEventListener("marker_removed",function(event){scope.dispatchEvent(event);});measurement.addEventListener("marker_moved",function(event){scope.dispatchEvent(event);});};this.removeMeasurement=function(measurement){this.sceneMeasurement.remove(measurement);var index=this.measurements.indexOf(measurement);if(index>=0){this.measurements.splice(index,1);}};this.reset=function(){for(var i=this.measurements.length-1;i>=0;i--){var measurement=this.measurements[i];this.removeMeasurement(measurement);}};this.update=function(){var measurements=[];for(var i=0;i<this.measurements.length;i++){measurements.push(this.measurements[i]);}if(this.activeMeasurement){measurements.push(this.activeMeasurement);} // make sizes independant of distance and fov
	for(var i=0;i<measurements.length;i++){var measurement=measurements[i]; // spheres
	for(var j=0;j<measurement.spheres.length;j++){var sphere=measurement.spheres[j];var distance=scope.camera.position.distanceTo(sphere.getWorldPosition());var pr=projectedRadius(1,scope.camera.fov*Math.PI/180,distance,renderer.domElement.clientHeight);var scale=15/pr;sphere.scale.set(scale,scale,scale);} // edgeLabels
	for(var j=0;j<measurement.edgeLabels.length;j++){var label=measurement.edgeLabels[j];var distance=scope.camera.position.distanceTo(label.getWorldPosition());var pr=projectedRadius(1,scope.camera.fov*Math.PI/180,distance,renderer.domElement.clientHeight);var scale=70/pr;label.scale.set(scale,scale,scale);} // angle labels
	for(var j=0;j<measurement.edgeLabels.length;j++){var label=measurement.angleLabels[j];var distance=scope.camera.position.distanceTo(label.getWorldPosition());var pr=projectedRadius(1,scope.camera.fov*Math.PI/180,distance,renderer.domElement.clientHeight);var scale=70/pr;label.scale.set(scale,scale,scale);} // areaLabel
	var distance=scope.camera.position.distanceTo(measurement.areaLabel.getWorldPosition());var pr=projectedRadius(1,scope.camera.fov*Math.PI/180,distance,renderer.domElement.clientHeight);var scale=80/pr;measurement.areaLabel.scale.set(scale,scale,scale);}this.light.position.copy(this.camera.position);this.light.lookAt(this.camera.getWorldDirection().add(this.camera.position));};this.render=function(){this.update();this.renderer.render(this.sceneMeasurement,this.camera);};this.domElement.addEventListener('click',onClick,false);this.domElement.addEventListener('dblclick',onDoubleClick,false);this.domElement.addEventListener('mousemove',onMouseMove,false);this.domElement.addEventListener('mousedown',onMouseDown,false);this.domElement.addEventListener('mouseup',onMouseUp,true);};Potree.MeasuringTool.prototype=Object.create(_three2.default.EventDispatcher.prototype);Potree.HeightProfile=function(){var scope=this;_three2.default.Object3D.call(this);this.points=[];this.spheres=[];this.edges=[];this.boxes=[];this.width=1;this.height=20;this._modifiable=true;var sphereGeometry=new _three2.default.SphereGeometry(0.4,10,10);var lineColor=new _three2.default.Color(0xff0000);var createSphereMaterial=function createSphereMaterial(){var sphereMaterial=new _three2.default.MeshLambertMaterial({shading:_three2.default.SmoothShading,color:0xff0000,ambient:0xaaaaaa,depthTest:false,depthWrite:false});return sphereMaterial;};var moveEvent=function moveEvent(event){event.target.material.emissive.setHex(0x888888);};var leaveEvent=function leaveEvent(event){event.target.material.emissive.setHex(0x000000);};var dragEvent=function dragEvent(event){var tool=event.tool;var dragstart=tool.dragstart;var mouse=tool.mouse;if(event.event.ctrlKey){var mouseStart=new _three2.default.Vector3(dragstart.mousePos.x,dragstart.mousePos.y,0);var mouseEnd=new _three2.default.Vector3(mouse.x,mouse.y,0);var widthStart=dragstart.widthStart;var scale=1-10*(mouseStart.y-mouseEnd.y);scale=Math.max(0.01,scale);if(widthStart){scope.setWidth(widthStart*scale);}}else {var I=tool.getMousePointCloudIntersection();if(I){var index=scope.spheres.indexOf(tool.dragstart.object);scope.setPosition(index,I);}}event.event.stopImmediatePropagation();};var dropEvent=function dropEvent(event){};this.addMarker=function(point){this.points.push(point); // sphere
	var sphere=new _three2.default.Mesh(sphereGeometry,createSphereMaterial());sphere.addEventListener("mousemove",moveEvent);sphere.addEventListener("mouseleave",leaveEvent);sphere.addEventListener("mousedrag",dragEvent);sphere.addEventListener("drop",dropEvent);this.add(sphere);this.spheres.push(sphere); // edges & boxes
	if(this.points.length>1){var lineGeometry=new _three2.default.Geometry();lineGeometry.vertices.push(new _three2.default.Vector3(),new _three2.default.Vector3());lineGeometry.colors.push(lineColor,lineColor,lineColor);var lineMaterial=new _three2.default.LineBasicMaterial({vertexColors:_three2.default.VertexColors,linewidth:2,transparent:true,opacity:0.4});lineMaterial.depthTest=false;var edge=new _three2.default.Line(lineGeometry,lineMaterial);edge.visible=false;this.add(edge);this.edges.push(edge);var boxGeometry=new _three2.default.BoxGeometry(1,1,1);var boxMaterial=new _three2.default.MeshBasicMaterial({color:0xff0000,transparent:true,opacity:0.2});var box=new _three2.default.Mesh(boxGeometry,boxMaterial);box.visible=false;this.add(box);this.boxes.push(box);}var event={"type":"marker_added","profile":this};this.dispatchEvent(event);this.setPosition(this.points.length-1,point);};this.removeMarker=function(index){this.points.splice(index,1);this.remove(this.spheres[index]);var edgeIndex=index==0?0:index-1;this.remove(this.edges[edgeIndex]);this.edges.splice(edgeIndex,1);this.remove(this.boxes[edgeIndex]);this.boxes.splice(edgeIndex,1);this.spheres.splice(index,1);this.update();var event={"type":"marker_removed","profile":this};this.dispatchEvent(event);}; /**
	   * see http://www.mathopenref.com/coordpolygonarea2.html
	   */this.getArea=function(){var area=0;var j=this.points.length-1;for(var i=0;i<this.points.length;i++){var p1=this.points[i];var p2=this.points[j];area+=(p2.x+p1.x)*(p1.z-p2.z);j=i;}return Math.abs(area/2);};this.setPosition=function(index,position){var point=this.points[index];point.copy(position);var event={type:'marker_moved',profile:this,index:index,position:position.clone()};this.dispatchEvent(event);this.update();};this.setWidth=function(width){this.width=width;this.update();};this.update=function(){if(this.points.length===0){return;}else if(this.points.length===1){var point=this.points[0];this.spheres[0].position.copy(point);return;}var min=this.points[0].clone();var max=this.points[0].clone();var centroid=new _three2.default.Vector3();var lastIndex=this.points.length-1;for(var i=0;i<=lastIndex;i++){var point=this.points[i];var sphere=this.spheres[i];var leftIndex=i===0?lastIndex:i-1;var rightIndex=i===lastIndex?0:i+1;var leftVertex=this.points[leftIndex];var rightVertex=this.points[rightIndex];var leftEdge=this.edges[leftIndex];var rightEdge=this.edges[i];var leftBox=this.boxes[leftIndex];var rightBox=this.boxes[i];var leftEdgeLength=point.distanceTo(leftVertex);var rightEdgeLength=point.distanceTo(rightVertex);var leftEdgeCenter=new _three2.default.Vector3().addVectors(leftVertex,point).multiplyScalar(0.5);var rightEdgeCenter=new _three2.default.Vector3().addVectors(point,rightVertex).multiplyScalar(0.5);sphere.position.copy(point);if(this._modifiable){sphere.visible=true;}else {sphere.visible=false;}if(leftEdge){leftEdge.geometry.vertices[1].copy(point);leftEdge.geometry.verticesNeedUpdate=true;leftEdge.geometry.computeBoundingSphere();}if(rightEdge){rightEdge.geometry.vertices[0].copy(point);rightEdge.geometry.verticesNeedUpdate=true;rightEdge.geometry.computeBoundingSphere();}if(leftBox){var start=leftVertex;var end=point;var length=start.clone().setY(0).distanceTo(end.clone().setY(0));leftBox.scale.set(length,this.height,this.width);var center=new _three2.default.Vector3().addVectors(start,end).multiplyScalar(0.5);var diff=new _three2.default.Vector3().subVectors(end,start);var target=new _three2.default.Vector3(diff.z,0,-diff.x);leftBox.position.set(0,0,0);leftBox.lookAt(target);leftBox.position.copy(center);}centroid.add(point);min.min(point);max.max(point);}centroid.multiplyScalar(1/this.points.length);for(var i=0;i<this.boxes.length;i++){var box=this.boxes[i];box.position.y=min.y+(max.y-min.y)/2; //box.scale.y = max.y - min.y + 50;
	box.scale.y=1000000;}};this.raycast=function(raycaster,intersects){for(var i=0;i<this.points.length;i++){var sphere=this.spheres[i];sphere.raycast(raycaster,intersects);} // recalculate distances because they are not necessarely correct
	// for scaled objects.
	// see https://github.com/mrdoob/three.js/issues/5827
	// TODO: remove this once the bug has been fixed
	for(var i=0;i<intersects.length;i++){var I=intersects[i];I.distance=raycaster.ray.origin.distanceTo(I.point);}intersects.sort(function(a,b){return a.distance-b.distance;});};};Potree.HeightProfile.prototype=Object.create(_three2.default.Object3D.prototype);Object.defineProperty(Potree.HeightProfile.prototype,"modifiable",{get:function get(){return this.modifiable;},set:function set(value){this._modifiable=value;this.update();}}); //
	// calculating area of a polygon:
	// http://www.mathopenref.com/coordpolygonarea2.html
	//
	//
	//
	Potree.ProfileTool=function(scene,camera,renderer){var scope=this;this.enabled=false;this.scene=scene;this.camera=camera;this.renderer=renderer;this.domElement=renderer.domElement;this.mouse={x:0,y:0};var STATE={DEFAULT:0,INSERT:1};var state=STATE.DEFAULT;var sphereGeometry=new _three2.default.SphereGeometry(0.4,10,10);this.activeProfile;this.profiles=[];this.sceneProfile=new _three2.default.Scene();this.sceneRoot=new _three2.default.Object3D();this.sceneProfile.add(this.sceneRoot);this.light=new _three2.default.DirectionalLight(0xffffff,1);this.light.position.set(0,0,10);this.light.lookAt(new _three2.default.Vector3(0,0,0));this.sceneProfile.add(this.light);this.hoveredElement=null;function createSphereMaterial(){var sphereMaterial=new _three2.default.MeshLambertMaterial({shading:_three2.default.SmoothShading,color:0xff0000,ambient:0xaaaaaa,depthTest:false,depthWrite:false});return sphereMaterial;};function onClick(event){if(state===STATE.INSERT){var I=scope.getMousePointCloudIntersection();if(I){var pos=I.clone();scope.activeProfile.addMarker(pos);var event={type:'newpoint',position:pos.clone()};scope.dispatchEvent(event);}}};function onMouseMove(event){var rect=scope.domElement.getBoundingClientRect();scope.mouse.x=(event.clientX-rect.left)/scope.domElement.clientWidth*2-1;scope.mouse.y=-((event.clientY-rect.top)/scope.domElement.clientHeight)*2+1;if(scope.dragstart){var arg={type:"mousedrag",event:event,tool:scope};scope.dragstart.object.dispatchEvent(arg);}else if(state==STATE.INSERT&&scope.activeProfile){var I=scope.getMousePointCloudIntersection();if(I){var lastIndex=scope.activeProfile.points.length-1;scope.activeProfile.setPosition(lastIndex,I);}}else {var I=getHoveredElement();if(I){I.object.dispatchEvent({type:"mousemove",target:I.object,event:event});if(scope.hoveredElement&&scope.hoveredElement!==I.object){scope.hoveredElement.dispatchEvent({type:"mouseleave",target:scope.hoveredElement,event:event});}scope.hoveredElement=I.object;}else {if(scope.hoveredElement){scope.hoveredElement.dispatchEvent({type:"mouseleave",target:scope.hoveredElement,event:event});}scope.hoveredElement=null;}}};function onRightClick(event){if(state==STATE.INSERT){scope.finishInsertion();}}function onMouseDown(event){if(state!==STATE.DEFAULT){event.stopImmediatePropagation();}if(event.which===1){var I=getHoveredElement();if(I){var widthStart=null;for(var i=0;i<scope.profiles.length;i++){var profile=scope.profiles[i];for(var j=0;j<profile.spheres.length;j++){var sphere=profile.spheres[j];if(sphere===I.object){widthStart=profile.width;}}}scope.dragstart={object:I.object,sceneClickPos:I.point,sceneStartPos:scope.sceneRoot.position.clone(),mousePos:{x:scope.mouse.x,y:scope.mouse.y},widthStart:widthStart};event.stopImmediatePropagation();}}else if(event.which===3){onRightClick(event);}}function onDoubleClick(event){ // fix move event after double click
	// see: http://stackoverflow.com/questions/8125165/event-listener-for-dblclick-causes-event-for-mousemove-to-not-work-and-show-a-ci
	if(window.getSelection){window.getSelection().removeAllRanges();}else if(document.selection){document.selection.empty();}if(scope.activeProfile&&state===STATE.INSERT){scope.activeProfile.removeMarker(scope.activeProfile.points.length-1);scope.finishInsertion();}}function onMouseUp(event){if(scope.dragstart){scope.dragstart.object.dispatchEvent({type:"drop",event:event});scope.dragstart=null;}}function getHoveredElement(){var vector=new _three2.default.Vector3(scope.mouse.x,scope.mouse.y,0.5);vector.unproject(scope.camera);var raycaster=new _three2.default.Raycaster();raycaster.ray.set(scope.camera.position,vector.sub(scope.camera.position).normalize());var intersections=raycaster.intersectObjects(scope.profiles);if(intersections.length>0){return intersections[0];}else {return false;}};this.getMousePointCloudIntersection=function(){var vector=new _three2.default.Vector3(scope.mouse.x,scope.mouse.y,0.5);vector.unproject(scope.camera);var direction=vector.sub(scope.camera.position).normalize();var ray=new _three2.default.Ray(scope.camera.position,direction);var pointClouds=[];scope.scene.traverse(function(object){if(object instanceof Potree.PointCloudOctree||object instanceof Potree.PointCloudArena4D){pointClouds.push(object);}});var closestPoint=null;var closestPointDistance=null;for(var i=0;i<pointClouds.length;i++){var pointcloud=pointClouds[i];var point=pointcloud.pick(scope.renderer,scope.camera,ray);if(!point){continue;}var distance=scope.camera.position.distanceTo(point.position);if(!closestPoint||distance<closestPointDistance){closestPoint=point;closestPointDistance=distance;}}return closestPoint?closestPoint.position:null;};this.startInsertion=function(args){state=STATE.INSERT;var args=args||{};var clip=args.clip||false;var width=args.width||1.0;this.activeProfile=new Potree.HeightProfile();this.activeProfile.clip=clip;this.activeProfile.setWidth(width);this.addProfile(this.activeProfile);this.activeProfile.addMarker(new _three2.default.Vector3(0,0,0));return this.activeProfile;};this.finishInsertion=function(){this.activeProfile.removeMarker(this.activeProfile.points.length-1);var event={type:"insertion_finished",profile:this.activeProfile};this.dispatchEvent(event);this.activeProfile=null;state=STATE.DEFAULT;};this.addProfile=function(profile){this.profiles.push(profile);this.sceneProfile.add(profile);profile.update();this.dispatchEvent({"type":"profile_added",profile:profile});profile.addEventListener("marker_added",function(event){scope.dispatchEvent(event);});profile.addEventListener("marker_removed",function(event){scope.dispatchEvent(event);});profile.addEventListener("marker_moved",function(event){scope.dispatchEvent(event);});};this.removeProfile=function(profile){this.sceneProfile.remove(profile);var index=this.profiles.indexOf(profile);if(index>=0){this.profiles.splice(index,1);}this.dispatchEvent({"type":"profile_removed",profile:profile});};this.reset=function(){for(var i=this.profiles.length-1;i>=0;i--){var profile=this.profiles[i];this.removeProfile(profile);}};this.update=function(){for(var i=0;i<this.profiles.length;i++){var profile=this.profiles[i];for(var j=0;j<profile.spheres.length;j++){var sphere=profile.spheres[j];var distance=scope.camera.position.distanceTo(sphere.getWorldPosition());var pr=projectedRadius(1,scope.camera.fov*Math.PI/180,distance,renderer.domElement.clientHeight);var scale=15/pr;sphere.scale.set(scale,scale,scale);}}this.light.position.copy(this.camera.position);this.light.lookAt(this.camera.getWorldDirection().add(this.camera.position));};this.render=function(){this.update();renderer.render(this.sceneProfile,this.camera);};this.domElement.addEventListener('click',onClick,false);this.domElement.addEventListener('dblclick',onDoubleClick,false);this.domElement.addEventListener('mousemove',onMouseMove,false);this.domElement.addEventListener('mousedown',onMouseDown,false);this.domElement.addEventListener('mouseup',onMouseUp,true);};Potree.ProfileTool.prototype=Object.create(_three2.default.EventDispatcher.prototype);Potree.TransformationTool=function(scene,camera,renderer){var scope=this;this.enabled=false;this.scene=scene;this.camera=camera;this.renderer=renderer;this.domElement=renderer.domElement;this.mouse={x:0,y:0};this.dragstart=null;this.sceneTransformation=new _three2.default.Scene();this.sceneRoot=new _three2.default.Object3D();this.sceneTransformation.add(this.sceneRoot);this.sceneRotation=new _three2.default.Scene();this.translationNode=new _three2.default.Object3D();this.rotationNode=new _three2.default.Object3D();this.scaleNode=new _three2.default.Object3D();this.sceneRoot.add(this.translationNode);this.sceneRoot.add(this.rotationNode);this.sceneRoot.add(this.scaleNode);this.sceneRoot.visible=false;this.hoveredElement=null;this.STATE={DEFAULT:0,TRANSLATE_X:1,TRANSLATE_Y:2,TRANSLATE_Z:3,SCALE_X:1,SCALE_Y:2,SCALE_Z:3};this.parts={ARROW_X:{name:"arrow_x",object:undefined,color:new _three2.default.Color(0xff0000),state:this.STATE.TRANSLATE_X},ARROW_Z:{name:"arrow_z",object:undefined,color:new _three2.default.Color(0x0000ff),state:this.STATE.TRANSLATE_Z},ARROW_Y:{name:"arrow_y",object:undefined,color:new _three2.default.Color(0x00ff00),state:this.STATE.TRANSLATE_Y},SCALE_X:{name:"scale_x",object:undefined,color:new _three2.default.Color(0xff0000),state:this.STATE.SCALE_X},SCALE_Z:{name:"scale_z",object:undefined,color:new _three2.default.Color(0x0000ff),state:this.STATE.SCALE_Z},SCALE_Y:{name:"scale_y",object:undefined,color:new _three2.default.Color(0x00ff00),state:this.STATE.SCALE_Y},ROTATE_X:{name:"rotate_x",object:undefined,color:new _three2.default.Color(0xff0000),state:this.STATE.ROTATE_X},ROTATE_Z:{name:"rotate_z",object:undefined,color:new _three2.default.Color(0x0000ff),state:this.STATE.ROTATE_Z},ROTATE_Y:{name:"rotate_y",object:undefined,color:new _three2.default.Color(0x00ff00),state:this.STATE.ROTATE_Y}};this.buildTranslationNode=function(){var arrowX=scope.createArrow(scope.parts.ARROW_X,scope.parts.ARROW_X.color);arrowX.rotation.z=-Math.PI/2;var arrowY=scope.createArrow(scope.parts.ARROW_Y,scope.parts.ARROW_Y.color);var arrowZ=scope.createArrow(scope.parts.ARROW_Z,scope.parts.ARROW_Z.color);arrowZ.rotation.x=-Math.PI/2;this.translationNode.add(arrowX);this.translationNode.add(arrowY);this.translationNode.add(arrowZ);};this.buildScaleNode=function(){var xHandle=this.createScaleHandle(scope.parts.SCALE_X,0xff0000);xHandle.rotation.z=-Math.PI/2;var yHandle=this.createScaleHandle(scope.parts.SCALE_Y,0x00ff00);var zHandle=this.createScaleHandle(scope.parts.SCALE_Z,0x0000ff);zHandle.rotation.x=-Math.PI/2;this.scaleNode.add(xHandle);this.scaleNode.add(yHandle);this.scaleNode.add(zHandle);};this.buildRotationNode=function(){var xHandle=this.createRotationCircle(scope.parts.ROTATE_X,0xff0000);xHandle.rotation.y=-Math.PI/2;var yHandle=this.createRotationCircle(scope.parts.ROTATE_Y,0x00ff00);var zHandle=this.createRotationCircle(scope.parts.ROTATE_Z,0x0000ff);yHandle.rotation.x=-Math.PI/2;this.rotationNode.add(xHandle);this.rotationNode.add(yHandle);this.rotationNode.add(zHandle);var sg=new _three2.default.SphereGeometry(2.9,24,24);var sphere=new _three2.default.Mesh(sg,new _three2.default.MeshBasicMaterial({color:0xaaaaaa,transparent:true,opacity:0.4}));this.sceneRotation.add(sphere);var moveEvent=function moveEvent(event){sphere.material.color.setHex(0x555555);};var leaveEvent=function leaveEvent(event){sphere.material.color.setHex(0xaaaaaa);};var dragEvent=function dragEvent(event){event.event.stopImmediatePropagation();var mouseStart=new _three2.default.Vector3(scope.dragstart.mousePos.x,scope.dragstart.mousePos.y,0.1);var mouseEnd=new _three2.default.Vector3(scope.mouse.x,scope.mouse.y,0.1);var mouseDiff=new _three2.default.Vector3().subVectors(mouseEnd,mouseStart);var sceneStart=mouseStart.clone().unproject(scope.camera);var sceneEnd=mouseEnd.clone().unproject(scope.camera);var sceneDiff=new _three2.default.Vector3().subVectors(sceneEnd,sceneStart);var sceneDir=sceneDiff.clone().normalize();var toCamDir=new _three2.default.Vector3().subVectors(scope.camera.position,sceneStart).normalize();var rotationAxis=toCamDir.clone().cross(sceneDir);var rotationAmount=6*mouseDiff.length();for(var i=0;i<scope.targets.length;i++){var target=scope.targets[i];var startRotation=scope.dragstart.rotations[i];target.rotation.copy(startRotation);var q=new _three2.default.Quaternion();q.setFromAxisAngle(rotationAxis,rotationAmount);target.quaternion.multiplyQuaternions(q,target.quaternion);}};var dropEvent=function dropEvent(event){};sphere.addEventListener("mousemove",moveEvent);sphere.addEventListener("mouseleave",leaveEvent);sphere.addEventListener("mousedrag",dragEvent);sphere.addEventListener("drop",dropEvent);};this.createBox=function(color){var boxGeometry=new _three2.default.BoxGeometry(1,1,1);var boxMaterial=new _three2.default.MeshBasicMaterial({color:color,transparent:true,opacity:0.5});var box=new _three2.default.Mesh(boxGeometry,boxMaterial);return box;};var sph1,sph2,sph3;this.createRotationCircle=function(partID,color){ //var geometry = new THREE.TorusGeometry(3, 0.1, 12, 48);
	//var material = new THREE.MeshBasicMaterial({color: color});
	//
	//var ring = new THREE.Mesh(geometry, material);
	var vertices=[];var segments=128;for(var i=0;i<=segments;i++){var u=2*Math.PI*i/segments;var x=3*Math.cos(u);var y=3*Math.sin(u);vertices.push(new _three2.default.Vector3(x,y,0));}var geometry=new _three2.default.Geometry();for(var i=0;i<vertices.length;i++){geometry.vertices.push(vertices[i]);}var material=new _three2.default.LineBasicMaterial({color:color});var ring=new _three2.default.Line(geometry,material);ring.mode=_three2.default.LineStrip;ring.scale.set(1,1,1); //this.rotationNode.add(ring);
	var moveEvent=function moveEvent(event){material.color.setRGB(1,1,0);};var leaveEvent=function leaveEvent(event){material.color.setHex(color);};var dragEvent=function dragEvent(event){event.event.stopImmediatePropagation();var normal=new _three2.default.Vector3();if(partID===scope.parts.ROTATE_X){normal.x=1;}else if(partID===scope.parts.ROTATE_Y){normal.y=1;}else if(partID===scope.parts.ROTATE_Z){normal.z=-1;}var sceneClickPos=scope.dragstart.sceneClickPos.clone();var sceneOrigin=scope.sceneRoot.position.clone();var sceneNormal=sceneClickPos.clone().sub(sceneOrigin).normalize();var screenClickPos=sceneClickPos.clone().project(scope.camera);var screenOrigin=sceneOrigin.clone().project(scope.camera);var screenNormal=screenClickPos.clone().sub(screenOrigin).normalize();var screenTangent=new _three2.default.Vector3(screenNormal.y,screenNormal.x,0);var mouseStart=new _three2.default.Vector3(scope.dragstart.mousePos.x,scope.dragstart.mousePos.y,0);var mouseEnd=new _three2.default.Vector3(scope.mouse.x,scope.mouse.y,0);var plane=new _three2.default.Plane().setFromNormalAndCoplanarPoint(normal,scope.sceneRoot.position);var camOrigin=scope.camera.position;var camDirection=new _three2.default.Vector3(0,0,-1).applyQuaternion(scope.camera.quaternion);var direction=new _three2.default.Vector3(mouseEnd.x,mouseEnd.y,0.5).unproject(scope.camera).sub(scope.camera.position).normalize();var ray=new _three2.default.Ray(camOrigin,direction);var I=ray.intersectPlane(plane);if(!I){return;}sceneTargetNormal=I.clone().sub(sceneOrigin).normalize();var angleToClick;var angleToTarget;if(partID===scope.parts.ROTATE_X){angleToClick=2*Math.PI+Math.atan2(sceneNormal.y,-sceneNormal.z);angleToTarget=4*Math.PI+Math.atan2(sceneTargetNormal.y,-sceneTargetNormal.z);}else if(partID===scope.parts.ROTATE_Y){angleToClick=2*Math.PI+Math.atan2(-sceneNormal.z,sceneNormal.x);angleToTarget=4*Math.PI+Math.atan2(-sceneTargetNormal.z,sceneTargetNormal.x);}else if(partID===scope.parts.ROTATE_Z){angleToClick=2*Math.PI+Math.atan2(sceneNormal.x,sceneNormal.y);angleToTarget=4*Math.PI+Math.atan2(sceneTargetNormal.x,sceneTargetNormal.y);}var diff=angleToTarget-angleToClick;for(var i=0;i<scope.targets.length;i++){var target=scope.targets[i];var startRotation=scope.dragstart.rotations[i];target.rotation.copy(startRotation);var q=new _three2.default.Quaternion();q.setFromAxisAngle(normal,diff); // axis must be normalized, angle in radians
	target.quaternion.multiplyQuaternions(q,target.quaternion);}};var dropEvent=function dropEvent(event){};ring.addEventListener("mousemove",moveEvent);ring.addEventListener("mouseleave",leaveEvent);ring.addEventListener("mousedrag",dragEvent);ring.addEventListener("drop",dropEvent);return ring;};this.createScaleHandle=function(partID,color){var boxGeometry=new _three2.default.BoxGeometry(1,1,1);var material=new _three2.default.MeshBasicMaterial({color:color,depthTest:false,depthWrite:false});var box=new _three2.default.Mesh(boxGeometry,material);box.scale.set(0.3,0.3,0.3);box.position.set(0,3,0);var shaftGeometry=new _three2.default.Geometry();shaftGeometry.vertices.push(new _three2.default.Vector3(0,0,0));shaftGeometry.vertices.push(new _three2.default.Vector3(0,3,0));var shaftMaterial=new _three2.default.LineBasicMaterial({color:color,depthTest:false,depthWrite:false});var shaft=new _three2.default.Line(shaftGeometry,shaftMaterial);var handle=new _three2.default.Object3D();handle.add(box);handle.add(shaft);handle.partID=partID;var moveEvent=function moveEvent(event){shaftMaterial.color.setRGB(1,1,0);material.color.setRGB(1,1,0);};var leaveEvent=function leaveEvent(event){shaftMaterial.color.setHex(color);material.color.setHex(color);};var dragEvent=function dragEvent(event){var sceneDirection=new _three2.default.Vector3();if(partID===scope.parts.SCALE_X){sceneDirection.x=1;}else if(partID===scope.parts.SCALE_Y){sceneDirection.y=1;}else if(partID===scope.parts.SCALE_Z){sceneDirection.z=-1;}var sceneClickPos=scope.dragstart.sceneClickPos.clone();sceneClickPos.multiply(sceneDirection);sceneClickPos.z*=-1;var lineStart=scope.dragstart.sceneStartPos.clone().project(scope.camera);var lineEnd=scope.dragstart.sceneStartPos.clone().add(sceneDirection).project(scope.camera);var origin=lineStart.clone();var screenDirection=lineEnd.clone().sub(lineStart);screenDirection.normalize();var mouseStart=new _three2.default.Vector3(scope.dragstart.mousePos.x,scope.dragstart.mousePos.y,0);var mouseEnd=new _three2.default.Vector3(scope.mouse.x,scope.mouse.y,0);var directionDistance=new _three2.default.Vector3().subVectors(mouseEnd,mouseStart).dot(screenDirection);var pointOnLine=screenDirection.clone().multiplyScalar(directionDistance).add(origin);pointOnLine.unproject(scope.camera);var diff=scope.sceneRoot.position.clone().sub(pointOnLine);diff.multiply(new _three2.default.Vector3(-1,-1,1));for(var i=0;i<scope.targets.length;i++){var target=scope.targets[i];var startScale=scope.dragstart.scales[i];target.scale.copy(startScale).add(diff);target.scale.x=Math.max(target.scale.x,0.01);target.scale.y=Math.max(target.scale.y,0.01);target.scale.z=Math.max(target.scale.z,0.01);}event.event.stopImmediatePropagation();};var dropEvent=function dropEvent(event){material.color.set(color);};box.addEventListener("mousemove",moveEvent);box.addEventListener("mouseleave",leaveEvent);box.addEventListener("mousedrag",dragEvent);box.addEventListener("drop",dropEvent);shaft.addEventListener("mousemove",moveEvent);shaft.addEventListener("mouseleave",leaveEvent);shaft.addEventListener("mousedrag",dragEvent);shaft.addEventListener("drop",dropEvent);return handle;};this.createArrow=function(partID,color){var material=new _three2.default.MeshBasicMaterial({color:color,depthTest:false,depthWrite:false}); //var shaftGeometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 10, 1, false);
	//var shaftMaterial  = material;
	//var shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
	//shaft.position.y = 1.5;
	var shaftGeometry=new _three2.default.Geometry();shaftGeometry.vertices.push(new _three2.default.Vector3(0,0,0));shaftGeometry.vertices.push(new _three2.default.Vector3(0,3,0));var shaftMaterial=new _three2.default.LineBasicMaterial({color:color,depthTest:false,depthWrite:false});var shaft=new _three2.default.Line(shaftGeometry,shaftMaterial);var headGeometry=new _three2.default.CylinderGeometry(0,0.2,0.5,10,1,false);var headMaterial=material;var head=new _three2.default.Mesh(headGeometry,headMaterial);head.position.y=3;var arrow=new _three2.default.Object3D();arrow.add(shaft);arrow.add(head);arrow.partID=partID;arrow.material=material;var moveEvent=function moveEvent(event){headMaterial.color.setRGB(1,1,0);shaftMaterial.color.setRGB(1,1,0);};var leaveEvent=function leaveEvent(event){headMaterial.color.set(color);shaftMaterial.color.set(color);};var dragEvent=function dragEvent(event){var sceneDirection=new _three2.default.Vector3();if(partID===scope.parts.ARROW_X){sceneDirection.x=1;}else if(partID===scope.parts.ARROW_Y){sceneDirection.y=1;}else if(partID===scope.parts.ARROW_Z){sceneDirection.z=-1;}var sceneClickPos=scope.dragstart.sceneClickPos.clone();sceneClickPos.multiply(sceneDirection);sceneClickPos.z*=-1; //var lineStart = new THREE.Vector3();
	//lineStart.x = scope.dragstart.mousePos.x;     
	//lineStart.y = scope.dragstart.mousePos.y;
	var lineStart=scope.dragstart.sceneStartPos.clone().project(scope.camera);var lineEnd=scope.dragstart.sceneStartPos.clone().add(sceneDirection).project(scope.camera);var origin=lineStart.clone();var screenDirection=lineEnd.clone().sub(lineStart);screenDirection.normalize();var mouseStart=new _three2.default.Vector3(scope.dragstart.mousePos.x,scope.dragstart.mousePos.y,0);var mouseEnd=new _three2.default.Vector3(scope.mouse.x,scope.mouse.y,0); //var htmlStart = mouseStart.clone().addScalar(1).multiplyScalar(0.5);
	//htmlStart.x *= scope.domElement.clientWidth;
	//htmlStart.y *= scope.domElement.clientHeight;
	//
	//var htmlEnd = mouseEnd.clone().addScalar(1).multiplyScalar(0.5);
	//htmlEnd.x *= scope.domElement.clientWidth;
	//htmlEnd.y *= scope.domElement.clientHeight;
	//
	//var el = document.getElementById("testDiv");
	//el.style.left = htmlStart.x;
	//el.style.width = htmlEnd.x - htmlStart.x;
	//el.style.bottom = htmlStart.y;
	//el.style.top = scope.domElement.clientHeight - htmlEnd.y;
	//var directionDistance = new THREE.Vector3().subVectors(mouseEnd, origin).dot(screenDirection);
	var directionDistance=new _three2.default.Vector3().subVectors(mouseEnd,mouseStart).dot(screenDirection);var pointOnLine=screenDirection.clone().multiplyScalar(directionDistance).add(origin);pointOnLine.unproject(scope.camera);var diff=scope.sceneRoot.position.clone(); //scope.position.copy(pointOnLine);
	var offset=sceneClickPos.clone().sub(scope.dragstart.sceneStartPos);scope.sceneRoot.position.copy(pointOnLine); //scope.sceneRoot.position.sub(offset);
	diff.sub(scope.sceneRoot.position);for(var i=0;i<scope.targets.length;i++){var target=scope.targets[i];target.position.sub(diff);} //if(!sph1){
	//  var g = new THREE.SphereGeometry(0.2);
	//  
	//  var m1 = new THREE.MeshBasicMaterial({color: 0xff0000});
	//  var m2 = new THREE.MeshBasicMaterial({color: 0x00ff00});
	//  var m3 = new THREE.MeshBasicMaterial({color: 0x0000ff});
	//  
	//  sph1 = new THREE.Mesh(g, m1);
	//  sph2 = new THREE.Mesh(g, m2);
	//  sph3 = new THREE.Mesh(g, m3);
	//  
	//  scope.scene.add(sph1);
	//  scope.scene.add(sph2);
	//  scope.scene.add(sph3);
	//}
	//sph1.position.copy(scope.dragstart.sceneStartPos);
	//sph2.position.copy(scope.dragstart.sceneClickPos);
	//sph3.position.copy(pointOnLine);
	event.event.stopImmediatePropagation();};var dropEvent=function dropEvent(event){shaftMaterial.color.set(color);};shaft.addEventListener("mousemove",moveEvent);head.addEventListener("mousemove",moveEvent);shaft.addEventListener("mouseleave",leaveEvent);head.addEventListener("mouseleave",leaveEvent);shaft.addEventListener("mousedrag",dragEvent);head.addEventListener("mousedrag",dragEvent);shaft.addEventListener("drop",dropEvent);head.addEventListener("drop",dropEvent);return arrow;};function onMouseMove(event){scope.mouse.x=event.clientX/scope.domElement.clientWidth*2-1;scope.mouse.y=-(event.clientY/scope.domElement.clientHeight)*2+1;if(scope.dragstart){scope.dragstart.object.dispatchEvent({type:"mousedrag",event:event});}else {var I=getHoveredElement();if(I){var object=I.object; //var g = new THREE.SphereGeometry(2);
	//var m = new THREE.Mesh(g);
	//scope.scene.add(m);
	//m.position.copy(I.point);
	object.dispatchEvent({type:"mousemove",event:event});if(scope.hoveredElement&&scope.hoveredElement!==object){scope.hoveredElement.dispatchEvent({type:"mouseleave",event:event});}scope.hoveredElement=object;}else {if(scope.hoveredElement){scope.hoveredElement.dispatchEvent({type:"mouseleave",event:event});}scope.hoveredElement=null;}}};function onMouseDown(event){if(event.which===1){ // left click
	var I=getHoveredElement();if(I){var scales=[];var rotations=[];for(var i=0;i<scope.targets.length;i++){scales.push(scope.targets[i].scale.clone());rotations.push(scope.targets[i].rotation.clone());}scope.dragstart={object:I.object,sceneClickPos:I.point,sceneStartPos:scope.sceneRoot.position.clone(),mousePos:{x:scope.mouse.x,y:scope.mouse.y},scales:scales,rotations:rotations};event.stopImmediatePropagation();}}else if(event.which===3){ // right click
	scope.setTargets([]);}};function onMouseUp(event){if(scope.dragstart){scope.dragstart.object.dispatchEvent({type:"drop",event:event});scope.dragstart=null;}};function getHoveredElement(){if(scope.targets.length===0){return;}var vector=new _three2.default.Vector3(scope.mouse.x,scope.mouse.y,0.5);vector.unproject(scope.camera);var raycaster=new _three2.default.Raycaster();raycaster.ray.set(scope.camera.position,vector.sub(scope.camera.position).normalize());raycaster.linePrecision=0.2;var objects=[];if(scope.translationNode.visible){objects.push(scope.translationNode);}else if(scope.scaleNode.visible){objects.push(scope.scaleNode);}else if(scope.rotationNode.visible){objects.push(scope.rotationNode);objects.push(scope.sceneRotation);}var intersections=raycaster.intersectObjects(objects,true); // recalculate distances because they are not necessarely correct
	// for scaled objects.
	// see https://github.com/mrdoob/three.js/issues/5827
	// TODO: remove this once the bug has been fixed
	for(var i=0;i<intersections.length;i++){var I=intersections[i];I.distance=scope.camera.position.distanceTo(I.point);}intersections.sort(function(a,b){return a.distance-b.distance;});if(intersections.length>0){return intersections[0];}else {return false;}};this.setTargets=function(targets){scope.targets=targets;if(scope.targets.length===0){this.sceneRoot.visible=false;this.sceneRotation.visible=false;return;}else {this.sceneRoot.visible=true;} //TODO calculate centroid of all targets
	var target=targets[0];var bb;if(target.geometry&&target.geometry.boundingBox){bb=target.geometry.boundingBox;}else {bb=target.boundingBox;}if(bb){var centroid=bb.clone().applyMatrix4(target.matrixWorld).center();scope.sceneRoot.position.copy(centroid);} //for(var i = 0; i < targets.length; i++){
	//  var target = targets[i];
	//}
	};this.update=function(){var node=this.sceneRoot;var wp=node.getWorldPosition().applyMatrix4(this.camera.matrixWorldInverse);var pp=new _three2.default.Vector4(wp.x,wp.y,wp.z).applyMatrix4(camera.projectionMatrix);var w=Math.abs(wp.z/20); // * (2 - pp.z / pp.w);
	node.scale.set(w,w,w);if(this.targets&&this.targets.length===1){this.scaleNode.rotation.copy(this.targets[0].rotation);}this.sceneRotation.scale.set(w,w,w);};this.render=function(){this.update();this.sceneRotation.position.copy(this.sceneRoot.position);this.sceneRotation.visible=this.rotationNode.visible&&this.sceneRoot.visible;renderer.render(this.sceneRotation,this.camera);renderer.render(this.sceneTransformation,this.camera);};this.translate=function(){this.translationNode.visible=true;this.scaleNode.visible=false;this.rotationNode.visible=false;};this.scale=function(){this.translationNode.visible=false;this.scaleNode.visible=true;this.rotationNode.visible=false;};this.rotate=function(){this.translationNode.visible=false;this.scaleNode.visible=false;this.rotationNode.visible=true;};this.buildTranslationNode();this.buildScaleNode();this.buildRotationNode(); //this.translate();
	this.rotate();this.setTargets([]); //this.domElement.addEventListener( 'click', onClick, false);
	this.domElement.addEventListener('mousemove',onMouseMove,true);this.domElement.addEventListener('mousedown',onMouseDown,true);this.domElement.addEventListener('mouseup',onMouseUp,true);};Potree.Volume=function(args){_three2.default.Object3D.call(this);args=args||{};this._clip=args.clip||false;this._modifiable=args.modifiable||true;var boxGeometry=new _three2.default.BoxGeometry(1,1,1);boxGeometry.computeBoundingBox();var boxFrameGeometry=new _three2.default.Geometry(); // bottom
	boxFrameGeometry.vertices.push(new _three2.default.Vector3(-0.5,-0.5,0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(0.5,-0.5,0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(0.5,-0.5,0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(0.5,-0.5,-0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(0.5,-0.5,-0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(-0.5,-0.5,-0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(-0.5,-0.5,-0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(-0.5,-0.5,0.5)); // top
	boxFrameGeometry.vertices.push(new _three2.default.Vector3(-0.5,0.5,0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(0.5,0.5,0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(0.5,0.5,0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(0.5,0.5,-0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(0.5,0.5,-0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(-0.5,0.5,-0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(-0.5,0.5,-0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(-0.5,0.5,0.5)); // sides
	boxFrameGeometry.vertices.push(new _three2.default.Vector3(-0.5,-0.5,0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(-0.5,0.5,0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(0.5,-0.5,0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(0.5,0.5,0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(0.5,-0.5,-0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(0.5,0.5,-0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(-0.5,-0.5,-0.5));boxFrameGeometry.vertices.push(new _three2.default.Vector3(-0.5,0.5,-0.5));this.dimension=new _three2.default.Vector3(1,1,1);var material=new _three2.default.MeshBasicMaterial({color:0x00ff00,transparent:true,opacity:0.3});this.box=new _three2.default.Mesh(boxGeometry,material);this.box.geometry.computeBoundingBox();this.boundingBox=this.box.geometry.boundingBox;this.add(this.box);this.frame=new _three2.default.Line(boxFrameGeometry,new _three2.default.LineBasicMaterial({color:0x000000}));this.frame.mode=_three2.default.LinePieces;this.add(this.frame);this.label=new Potree.TextSprite("0");this.label.setBorderColor({r:0,g:255,b:0,a:0.0});this.label.setBackgroundColor({r:0,g:255,b:0,a:0.0});this.label.material.depthTest=false;this.label.position.y-=0.5;this.add(this.label);var v=this;this.label.updateMatrixWorld=function(){var volumeWorldPos=new _three2.default.Vector3();volumeWorldPos.setFromMatrixPosition(v.matrixWorld);v.label.position.copy(volumeWorldPos);v.label.updateMatrix();v.label.matrixWorld.copy(v.label.matrix);v.label.matrixWorldNeedsUpdate=false;for(var i=0,l=v.label.children.length;i<l;i++){v.label.children[i].updateMatrixWorld(true);}};this.setDimension=function(x,y,z){this.dimension.set(x,y,z);this.box.scale.set(x,y,z);this.frame.scale.set(x,y,z);};this.volume=function(){return Math.abs(this.scale.x*this.scale.y*this.scale.z); //return Math.abs(this.dimension.x * this.dimension.y * this.dimension.z);
	};this.update=function(){this.boundingBox=this.box.geometry.boundingBox;if(this._clip){this.box.visible=false;this.label.visible=false;}else {this.box.visible=true;this.label.visible=true;}};this.raycast=function(raycaster,intersects){var is=[];this.box.raycast(raycaster,is);if(is.length>0){var I=is[0];intersects.push({distance:I.distance,object:this,point:I.point.clone()});}};this.update();};Potree.Volume.prototype=Object.create(_three2.default.Object3D.prototype);Object.defineProperty(Potree.Volume.prototype,"clip",{get:function get(){return this._clip;},set:function set(value){this._clip=value;this.update();}});Object.defineProperty(Potree.Volume.prototype,"modifiable",{get:function get(){return this._modifiable;},set:function set(value){this._modifiable=value;this.update();}});Potree.VolumeTool=function(scene,camera,renderer){var scope=this;this.enabled=false;this.scene=scene;this.sceneVolume=new _three2.default.Scene();this.camera=camera;this.renderer=renderer;this.domElement=renderer.domElement;this.mouse={x:0,y:0};this.volumes=[];var STATE={DEFAULT:0,INSERT_VOLUME:1};var state=STATE.DEFAULT;function onMouseMove(event){var rect=scope.domElement.getBoundingClientRect();scope.mouse.x=(event.clientX-rect.left)/scope.domElement.clientWidth*2-1;scope.mouse.y=-((event.clientY-rect.top)/scope.domElement.clientHeight)*2+1;};function onMouseClick(event){ //if(state === STATE.INSERT_VOLUME){
	//  scope.finishInsertion();
	//}else if(event.which === 1){
	//  var I = getHoveredElement();
	//  
	//  if(I){
	//    transformationTool.setTargets([I.object]);
	//  }
	//}
	};function onMouseDown(event){if(state!==STATE.DEFAULT){event.stopImmediatePropagation();}if(state===STATE.INSERT_VOLUME){scope.finishInsertion();}else if(event.which===1){var I=getHoveredElement();if(I&&I.object.modifiable){transformationTool.setTargets([I.object]);}}if(event.which===3){ // open context menu
	//var element = getHoveredElement();
	//
	//if(element){
	//  var menu = document.createElement("div");
	//  menu.style.position = "fixed";
	//  menu.style.backgroundColor = "#bbbbbb";
	//  menu.style.top = event.clientY + "px";
	//  menu.style.left = event.clientX + "px";
	//  menu.style.width = "200px";
	//  menu.style.height = "100px";
	//  menu.innerHTML = "abc";
	//  menu.addEventListener("contextmenu", function(event){
	//    event.preventDefault();
	//    return false;
	//  }, false);
	//  
	//  scope.renderer.domElement.parentElement.appendChild(menu);
	//}
	}};function onContextMenu(event){event.preventDefault();return false;}function getHoveredElement(){var vector=new _three2.default.Vector3(scope.mouse.x,scope.mouse.y,0.5);vector.unproject(scope.camera);var raycaster=new _three2.default.Raycaster();raycaster.ray.set(scope.camera.position,vector.sub(scope.camera.position).normalize());var objects=[];for(var i=0;i<scope.volumes.length;i++){var object=scope.volumes[i];objects.push(object);}var intersections=raycaster.intersectObjects(objects,false);if(intersections.length>0){return intersections[0];}else {return false;}};function getMousePointCloudIntersection(){var vector=new _three2.default.Vector3(scope.mouse.x,scope.mouse.y,0.5);vector.unproject(scope.camera);var direction=vector.sub(scope.camera.position).normalize();var ray=new _three2.default.Ray(scope.camera.position,direction);var pointClouds=[];scope.scene.traverse(function(object){if(object instanceof Potree.PointCloudOctree||object instanceof Potree.PointCloudArena4D){pointClouds.push(object);}});var closestPoint=null;var closestPointDistance=null;for(var i=0;i<pointClouds.length;i++){var pointcloud=pointClouds[i];var point=pointcloud.pick(scope.renderer,scope.camera,ray);if(!point){continue;}var distance=scope.camera.position.distanceTo(point.position);if(!closestPoint||distance<closestPointDistance){closestPoint=point;closestPointDistance=distance;}}return closestPoint?closestPoint.position:null;}this.update=function(delta){if(state===STATE.INSERT_VOLUME){var I=getMousePointCloudIntersection();if(I){this.activeVolume.position.copy(I);var wp=this.activeVolume.getWorldPosition().applyMatrix4(this.camera.matrixWorldInverse);var pp=new _three2.default.Vector4(wp.x,wp.y,wp.z).applyMatrix4(this.camera.projectionMatrix);var w=Math.abs(wp.z/10); //this.activeVolume.setDimension(w, w, w);
	this.activeVolume.scale.set(w,w,w);}}var volumes=[];for(var i=0;i<this.volumes.length;i++){volumes.push(this.volumes[i]);}if(this.activeVolume){volumes.push(this.activeVolume);}for(var i=0;i<volumes.length;i++){var volume=volumes[i];var box=volume.box;var label=volume.label;var capacity=volume.volume();var msg=Potree.utils.addCommas(capacity.toFixed(1))+"";label.setText(msg);var distance=scope.camera.position.distanceTo(label.getWorldPosition());var pr=projectedRadius(1,scope.camera.fov*Math.PI/180,distance,renderer.domElement.clientHeight);var scale=70/pr;label.scale.set(scale,scale,scale);}};this.startInsertion=function(args){state=STATE.INSERT_VOLUME;var args=args||{};var clip=args.clip||false;this.activeVolume=new Potree.Volume();this.activeVolume.clip=clip;this.sceneVolume.add(this.activeVolume);this.volumes.push(this.activeVolume);};this.finishInsertion=function(){transformationTool.setTargets([this.activeVolume]);var event={type:"insertion_finished",volume:this.activeVolume};this.dispatchEvent(event);this.activeVolume=null;state=STATE.DEFAULT;};this.addVolume=function(volume){this.sceneVolume.add(volume);this.volumes.push(volume);};this.removeVolume=function(volume){this.sceneVolume.remove(volume);var index=this.volumes.indexOf(volume);if(index>=0){this.volumes.splice(index,1);}};this.reset=function(){for(var i=this.volumes.length-1;i>=0;i--){var volume=this.volumes[i];this.removeVolume(volume);}};this.render=function(){renderer.render(this.sceneVolume,this.camera);};this.domElement.addEventListener('click',onMouseClick,false);this.domElement.addEventListener('mousedown',onMouseDown,false);this.domElement.addEventListener('mousemove',onMouseMove,false);this.domElement.addEventListener('contextmenu',onContextMenu,false);};Potree.VolumeTool.prototype=Object.create(_three2.default.EventDispatcher.prototype);Potree.PointCloudArena4DProxyNode=function(geometryNode){_three2.default.Object3D.call(this);this.geometryNode=geometryNode;this.pcoGeometry=geometryNode;this.boundingBox=geometryNode.boundingBox;this.boundingSphere=geometryNode.boundingSphere;this.number=geometryNode.name;this.numPoints=geometryNode.numPoints;this.level=geometryNode.level;};Potree.PointCloudArena4DProxyNode.prototype=Object.create(_three2.default.Object3D.prototype);Potree.PointCloudArena4D=function(geometry){_three2.default.Object3D.call(this);this.root=null;this.visiblePointsTarget=2*1000*1000;this.minimumNodePixelSize=150;this.position.sub(geometry.offset);this.updateMatrix();this.numVisibleNodes=0;this.numVisiblePoints=0;this.boundingBoxNodes=[];this.loadQueue=[];this.visibleNodes=[];this.pcoGeometry=geometry;this.boundingBox=this.pcoGeometry.boundingBox;this.boundingSphere=this.pcoGeometry.boundingSphere;this.material=new Potree.PointCloudMaterial({vertexColors:_three2.default.VertexColors,size:0.05,treeType:Potree.TreeType.KDTREE});this.material.sizeType=Potree.PointSizeType.ATTENUATED;this.material.size=0.05;this.pickTarget;this.pickMaterial;this.updateMatrixWorld();};Potree.PointCloudArena4D.prototype=Object.create(_three2.default.Object3D.prototype);Potree.PointCloudArena4D.prototype.updateMaterial=function(camera,renderer){this.material.fov=camera.fov*(Math.PI/180);this.material.screenWidth=renderer.domElement.clientWidth;this.material.screenHeight=renderer.domElement.clientHeight;this.material.spacing=this.pcoGeometry.spacing;this.material.near=camera.near;this.material.far=camera.far;this.material.minSize=3;var bbSize=this.boundingBox.size();this.material.bbSize=[bbSize.x,bbSize.y,bbSize.z];};Potree.PointCloudArena4D.prototype.hideDescendants=function(object){var stack=[];for(var i=0;i<object.children.length;i++){var child=object.children[i];if(child.visible){stack.push(child);}}while(stack.length>0){var object=stack.shift();object.visible=false;if(object.boundingBoxNode){object.boundingBoxNode.visible=false;}for(var i=0;i<object.children.length;i++){var child=object.children[i];if(child.visible){stack.push(child);}}}};Potree.PointCloudArena4D.prototype.updateMatrixWorld=function(force){ //node.matrixWorld.multiplyMatrices( node.parent.matrixWorld, node.matrix );
	if(this.matrixAutoUpdate===true)this.updateMatrix();if(this.matrixWorldNeedsUpdate===true||force===true){if(this.parent===undefined){this.matrixWorld.copy(this.matrix);}else {this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}this.matrixWorldNeedsUpdate=false;force=true;}};var dbgFullyInside=0;Potree.PointCloudArena4D.prototype.update=function(camera,renderer){var geometry=this.pcoGeometry;if(!geometry.root){return;}else if(!this.rootProxyGenerated){var rootProxy=new Potree.PointCloudArena4DProxyNode(this.pcoGeometry.root);this.add(rootProxy);this.rootProxyGenerated=true;}this.updateMatrixWorld(true);this.loadQueue=[];this.visibleNodes=[];this.numVisibleNodes=0;this.numVisiblePoints=0;dbgFullyInside=0;if(!this.showBoundingBox){for(var i=0;i<this.boundingBoxNodes.length;i++){var bbNode=this.boundingBoxNodes[i];this.remove(bbNode);bbNode.geometry.dispose();}}this.updateMaterial(camera,renderer);this.hideDescendants(this.children[0]); // create frustum in object space
	camera.updateMatrixWorld();var frustum=new _three2.default.Frustum();var viewI=camera.matrixWorldInverse;var world=this.matrixWorld;var proj=camera.projectionMatrix;var fm=new _three2.default.Matrix4().multiply(proj).multiply(viewI).multiply(world);frustum.setFromMatrix(fm); // calculate camera position in object space
	var view=camera.matrixWorld;var worldI=new _three2.default.Matrix4().getInverse(world);var camMatrixObject=new _three2.default.Matrix4().multiply(worldI).multiply(view);var camObjPos=new _three2.default.Vector3().setFromMatrixPosition(camMatrixObject);var stack=[];stack.push({node:this.children[0],weight:1});while(stack.length>0){var element=stack.shift();var node=element.node;var weight=element.weight; //if(node.level > 3){
	//  continue;
	//}
	node.matrixWorld.multiplyMatrices(this.matrixWorld,node.matrix);var box=node.boundingBox.clone(); //box.min.sub(this.boundingBox.min);
	//box.max.sub(this.boundingBox.min);
	var insideFrustum=frustum.intersectsBox(box);var visible=insideFrustum;node.visible=visible;if(!visible){continue;}var pointsInside=0; //pointsInside += frustum.containsPoint(new THREE.Vector3(box.min.x, box.min.y, box.min.z)) ? 1 : 0;
	//pointsInside += frustum.containsPoint(new THREE.Vector3(box.min.x, box.min.y, box.max.z)) ? 1 : 0;
	//pointsInside += frustum.containsPoint(new THREE.Vector3(box.min.x, box.max.y, box.min.z)) ? 1 : 0;
	//pointsInside += frustum.containsPoint(new THREE.Vector3(box.min.x, box.max.y, box.max.z)) ? 1 : 0;
	//pointsInside += frustum.containsPoint(new THREE.Vector3(box.max.x, box.min.y, box.min.z)) ? 1 : 0;
	//pointsInside += frustum.containsPoint(new THREE.Vector3(box.max.x, box.min.y, box.max.z)) ? 1 : 0;
	//pointsInside += frustum.containsPoint(new THREE.Vector3(box.max.x, box.max.y, box.min.z)) ? 1 : 0;
	//pointsInside += frustum.containsPoint(new THREE.Vector3(box.max.x, box.max.y, box.max.z)) ? 1 : 0;
	if(pointsInside===8){dbgFullyInside++;}if(node instanceof Potree.PointCloudArena4DProxyNode){var geometryNode=node.geometryNode;if(geometryNode.loaded===true){this.replaceProxy(node);}else {this.loadQueue.push(element);}}else if(node instanceof _three2.default.PointCloud){if(this.numVisiblePoints+node.pcoGeometry.numPoints>pointcloud.visiblePointsTarget){break;}this.numVisibleNodes++;this.numVisiblePoints+=node.pcoGeometry.numPoints;this.visibleNodes.push({node:node,weight:weight});if(this.showBoundingBox&&!node.boundingBoxNode){var boxHelper=new _three2.default.BoxHelper(node);this.add(boxHelper);this.boundingBoxNodes.push(boxHelper);node.boundingBoxNode=boxHelper;node.boundingBoxNode.matrixWorld.copy(node.matrixWorld);}else if(this.showBoundingBox&&node.boundingBoxNode){node.boundingBoxNode.visible=true;}else if(!this.showBoundingBox){delete node.boundingBoxNode;}for(var i=0;i<node.children.length;i++){var child=node.children[i]; //var box = child.geometryNode.boundingBox;
	var sphere=child.boundingSphere;var distance=sphere.center.distanceTo(camObjPos);var radius=box.size().length()/2;var fov=camera.fov/2*Math.PI/180.0;var pr=1/Math.tan(fov)*radius/Math.sqrt(distance*distance-radius*radius);if(distance<radius){pr=Number.MAX_VALUE;}var screenPixelRadius=renderer.domElement.clientHeight*pr;if(screenPixelRadius<this.minimumNodePixelSize){continue;}var weight=pr;if(stack.length===0){stack.push({node:child,weight:weight});}else {var ipos=0;for(var j=0;j<stack.length;j++){if(weight>stack[j].weight){var ipos=j;break;}else if(j==stack.length-1){ipos=stack.length;break;}}stack.splice(ipos,0,{node:child,weight:weight});} //stack.push({node: child, weight: 1});
	}}}this.updateLoadQueue();this.maxLevel=0;for(var i=0;i<this.visibleNodes.length;i++){this.maxLevel=Math.max(this.visibleNodes[i].node.pcoGeometry.level,this.maxLevel);}var vn=[];for(var i=0;i<this.visibleNodes.length;i++){vn.push(this.visibleNodes[i].node);}this.updateVisibilityTexture(this.material,vn); //{ // only show nodes on ray
	//  var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
	//  vector.unproject(camera);
	//
	//  var direction = vector.sub(camera.position).normalize();
	//  var ray = new THREE.Ray(camera.position, direction);
	//    
	//    
	//  var nodesOnRay = pointcloud.nodesOnRay(pointcloud.visibleNodes, ray); 
	//  
	//  for(var i = 0; i < this.visibleNodes.length; i++){
	//    var node = this.visibleNodes[i].node;
	//    
	//    node.visible = false;
	//    if(node.boundingBoxNode){
	//      node.boundingBoxNode.visible = false;
	//    }
	//  }
	//  
	//  for(var i = 0; i < nodesOnRay.length; i++){
	//    var node = nodesOnRay[i];
	//  
	//    node.visible = true;
	//    this.numVisiblePoints += node.pcoGeometry.numPoints;
	//    if(node.boundingBoxNode){
	//      node.boundingBoxNode.visible = true;
	//    }
	//  }
	//  this.numVisibleNodes = nodesOnRay.length;
	//  
	//  var pickPos = this.pick(renderer, camera, ray, {});
	//  if(pickPos){
	//    var sg = new THREE.SphereGeometry(0.2);
	//    var sm = new THREE.Mesh(sg);
	//    sm.position.copy(pickPos.position);
	//    scene.add(sm);
	//  }
	//}
	};Potree.PointCloudArena4D.prototype.replaceProxy=function(proxy){var geometryNode=proxy.geometryNode;if(geometryNode.loaded===true){var geometry=geometryNode.geometry;var node=new _three2.default.PointCloud(geometry,this.material);node.number=proxy.number;node.numPoints=proxy.numPoints;node.boundingBox=geometryNode.boundingBox;node.boundingSphere=geometryNode.boundingSphere;node.pcoGeometry=geometryNode;var parent=proxy.parent;parent.remove(proxy);parent.add(node); //node.position.copy(node.boundingBox.min);
	//node.position.sub(this.pcoGeometry.boundingBox.min);
	//var current = parent;
	//while(!(current instanceof Potree.PointCloudArena4D)){
	//  node.position.sub(current.boundingBox.min);
	//  
	//  current = current.parent;
	//}
	node.updateMatrix(); //console.log(geometryNode.number + ": " + node.position.x + ", " + node.position.y + ", " + node.position.z);
	node.matrixWorld.multiplyMatrices(this.matrixWorld,node.matrix);if(geometryNode.left){var child=geometryNode.left;var childProxy=new Potree.PointCloudArena4DProxyNode(child);node.add(childProxy);}if(geometryNode.right){var child=geometryNode.right;var childProxy=new Potree.PointCloudArena4DProxyNode(child);node.add(childProxy);}return node;}};Potree.PointCloudArena4D.prototype.updateLoadQueue=function(vn){if(this.loadQueue.length>0){if(this.loadQueue.length>=2){this.loadQueue.sort(function(a,b){return b.weight-a.weight;});}for(var i=0;i<Math.min(5,this.loadQueue.length);i++){this.loadQueue[i].node.geometryNode.load();}}};Potree.PointCloudArena4D.prototype.getVisibleGeometry=function(camera){var visibleGeometry=[]; // create frustum in object space
	camera.updateMatrixWorld();var frustum=new _three2.default.Frustum();var viewI=camera.matrixWorldInverse;var world=this.matrixWorld;var proj=camera.projectionMatrix;var fm=new _three2.default.Matrix4().multiply(proj).multiply(viewI).multiply(world);frustum.setFromMatrix(fm);var stack=[];var pointCount=0;stack.push(this.pcoGeometry.root);while(stack.length>0){if(visibleGeometry.length>12){break;}var node=stack.shift();var box=node.boundingBox.clone();box.max.sub(box.min);box.min.sub(box.min);var insideFrustum=frustum.intersectsBox(box);var visible=insideFrustum;if(!visible){continue;}if(pointCount+node.numPoints>this.visiblePointsTarget){break;}pointCount+=node.numPoints;visibleGeometry.push(node);if(node.loaded){if(node.left){stack.push(node.left);}if(node.right){stack.push(node.right);}}}return visibleGeometry;};Potree.PointCloudArena4D.prototype.nodesOnRay=function(nodes,ray){var nodesOnRay=[];var _ray=ray.clone();for(var i=0;i<nodes.length;i++){var node=nodes[i].node; //var inverseWorld = new THREE.Matrix4().getInverse(node.matrixWorld);
	var sphere=node.boundingSphere.clone().applyMatrix4(node.matrixWorld);var box=node.boundingBox.clone().applyMatrix4(node.matrixWorld);if(_ray.isIntersectionBox(box)){ //if(_ray.isIntersectionSphere(sphere)){
	nodesOnRay.push(node);}}return nodesOnRay;};Potree.PointCloudArena4D.prototype.pick=function(renderer,camera,ray,params){var params=params||{};var pickWindowSize=params.pickWindowSize||17;var nodes=this.nodesOnRay(this.visibleNodes,ray);if(nodes.length===0){return null;}var width=Math.ceil(renderer.domElement.clientWidth);var height=Math.ceil(renderer.domElement.clientHeight);var pixelPos=new _three2.default.Vector3().addVectors(camera.position,ray.direction).project(camera);pixelPos.addScalar(1).multiplyScalar(0.5);pixelPos.x*=width;pixelPos.y*=height;if(!this.pickTarget){this.pickTarget=new _three2.default.WebGLRenderTarget(1,1,{minFilter:_three2.default.LinearFilter,magFilter:_three2.default.NearestFilter,format:_three2.default.RGBAFormat});}else if(this.pickTarget.width!=width||this.pickTarget.height!=height){this.pickTarget.dispose();this.pickTarget=new _three2.default.WebGLRenderTarget(1,1,{minFilter:_three2.default.LinearFilter,magFilter:_three2.default.NearestFilter,format:_three2.default.RGBAFormat});}this.pickTarget.setSize(width,height); // setup pick material.
	// use the same point size functions as the main material to get the same point sizes.
	if(!this.pickMaterial){this.pickMaterial=new Potree.PointCloudMaterial({treeType:Potree.TreeType.KDTREE});this.pickMaterial.pointColorType=Potree.PointColorType.POINT_INDEX;this.pickMaterial.pointSizeType=Potree.PointSizeType.FIXED;}this.pickMaterial.pointSizeType=this.material.pointSizeType;this.pickMaterial.size=this.material.size;this.pickMaterial.fov=this.material.fov;this.pickMaterial.screenWidth=this.material.screenWidth;this.pickMaterial.screenHeight=this.material.screenHeight;this.pickMaterial.spacing=this.material.spacing;this.pickMaterial.near=this.material.near;this.pickMaterial.far=this.material.far;this.pickMaterial.interpolate=this.material.interpolate;this.pickMaterial.minSize=this.material.minSize;this.pickMaterial.maxSize=this.material.maxSize;this.pickMaterial.bbSize=this.material.bbSize;if(this.pickMaterial.pointSizeType===Potree.PointSizeType.ADAPTIVE){this.updateVisibilityTexture(this.pickMaterial,nodes);}var _gl=renderer.context;_gl.enable(_gl.SCISSOR_TEST);_gl.scissor(pixelPos.x-(pickWindowSize-1)/2,pixelPos.y-(pickWindowSize-1)/2,pickWindowSize,pickWindowSize);_gl.disable(_gl.SCISSOR_TEST);var material=this.pickMaterial;renderer.setRenderTarget(this.pickTarget);renderer.state.setDepthTest(material.depthTest);renderer.state.setDepthWrite(material.depthWrite);renderer.state.setBlending(_three2.default.NoBlending);renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil); //TODO: UGLY HACK CHAMPIONSHIP SUBMISSION!! drawing first node does not work properly so we draw it twice.
	if(nodes.length>0){nodes.push(nodes[0]);}for(var i=0;i<nodes.length;i++){var object=nodes[i];var geometry=object.geometry;if(!geometry.attributes.indices.buffer){continue;}material.pcIndex=i;if(material.program){var program=material.program.program;_gl.useProgram(program); //_gl.disable( _gl.BLEND );
	var attributePointer=_gl.getAttribLocation(program,"indices");var attributeSize=4;_gl.bindBuffer(_gl.ARRAY_BUFFER,geometry.attributes.indices.buffer); //if(!bufferSubmitted){
	//  _gl.bufferData( _gl.ARRAY_BUFFER, new Uint8Array(geometry.attributes.indices.array), _gl.STATIC_DRAW );
	//  bufferSubmitted = true;
	//}
	_gl.enableVertexAttribArray(attributePointer);_gl.vertexAttribPointer(attributePointer,attributeSize,_gl.UNSIGNED_BYTE,true,0,0);_gl.uniform1f(material.program.uniforms.pcIndex,material.pcIndex);}renderer.renderBufferDirect(camera,[],null,material,geometry,object);}var pickWindowSize=17;var pixelCount=pickWindowSize*pickWindowSize;var buffer=new ArrayBuffer(pixelCount*4);var pixels=new Uint8Array(buffer);var ibuffer=new Uint32Array(buffer);renderer.context.readPixels(pixelPos.x-(pickWindowSize-1)/2,pixelPos.y-(pickWindowSize-1)/2,pickWindowSize,pickWindowSize,renderer.context.RGBA,renderer.context.UNSIGNED_BYTE,pixels); //{ // show big render target for debugging purposes
	//  var br = new ArrayBuffer(width*height*4);
	//  var bp = new Uint8Array(br);
	//  renderer.context.readPixels( 0, 0, width, height, 
	//    renderer.context.RGBA, renderer.context.UNSIGNED_BYTE, bp);
	//
	//  var img = pixelsArrayToImage(bp, width, height);
	//  img.style.boder = "2px solid red";
	//  img.style.position = "absolute";
	//  img.style.top  = "0px";
	//  img.style.width = width + "px";
	//  img.style.height = height + "px";
	//  img.onclick = function(){document.body.removeChild(img)};
	//  document.body.appendChild(img);
	//}
	// find closest hit inside pixelWindow boundaries
	var min=Number.MAX_VALUE;var hit=null; //console.log("finding closest hit");
	for(var u=0;u<pickWindowSize;u++){for(var v=0;v<pickWindowSize;v++){var offset=u+v*pickWindowSize;var distance=Math.pow(u-(pickWindowSize-1)/2,2)+Math.pow(v-(pickWindowSize-1)/2,2);var pcIndex=pixels[4*offset+3];pixels[4*offset+3]=0;var pIndex=ibuffer[offset];if((pIndex!==0||pcIndex!==0)&&distance<min){hit={pIndex:pIndex,pcIndex:pcIndex};min=distance;}}}if(hit){var point={};var pc=nodes[hit.pcIndex];var attributes=pc.geometry.attributes;for(var property in attributes){if(attributes.hasOwnProperty(property)){var values=geometry.attributes[property];if(property==="position"){var positionArray=pc.geometry.attributes.position.array;var x=positionArray[3*hit.pIndex+0];var y=positionArray[3*hit.pIndex+1];var z=positionArray[3*hit.pIndex+2];var position=new _three2.default.Vector3(x,y,z);position.applyMatrix4(this.matrixWorld);point[property]=position;}else if(property==="indices"){}else {if(values.itemSize===1){point[property]=values.array[i+j];}else {var value=[];for(var j=0;j<values.itemSize;j++){value.push(values.array[i*values.itemSize+j]);}point[property]=value;}}}}return point;}else {return null;}};Potree.PointCloudArena4D.prototype.updateVisibilityTexture=function(material,visibleNodes){if(!material){return;}var texture=material.visibleNodesTexture;var data=texture.image.data; // copy array
	visibleNodes=visibleNodes.slice(); // sort by level and number
	var sort=function sort(a,b){var la=a.pcoGeometry.level;var lb=b.pcoGeometry.level;var na=a.pcoGeometry.number;var nb=b.pcoGeometry.number;if(la!=lb)return la-lb;if(na<nb)return -1;if(na>nb)return 1;return 0;};visibleNodes.sort(sort);var visibleNodeNames=[];for(var i=0;i<visibleNodes.length;i++){ //visibleNodeNames[visibleNodes[i].pcoGeometry.number] = true;
	visibleNodeNames.push(visibleNodes[i].pcoGeometry.number);}for(var i=0;i<visibleNodes.length;i++){var node=visibleNodes[i];var b1=0; // children
	var b2=0; // offset to first child
	var b3=0; // split 
	if(node.pcoGeometry.left&&visibleNodeNames.indexOf(node.pcoGeometry.left.number)>0){b1+=1;b2=visibleNodeNames.indexOf(node.pcoGeometry.left.number)-i;}if(node.pcoGeometry.right&&visibleNodeNames.indexOf(node.pcoGeometry.right.number)>0){b1+=2;b2=b2===0?visibleNodeNames.indexOf(node.pcoGeometry.right.number)-i:b2;}if(node.pcoGeometry.split==="X"){b3=1;}else if(node.pcoGeometry.split==="Y"){b3=2;}else if(node.pcoGeometry.split==="Z"){b3=4;}data[i*3+0]=b1;data[i*3+1]=b2;data[i*3+2]=b3;}texture.needsUpdate=true;};Object.defineProperty(Potree.PointCloudArena4D.prototype,"progress",{get:function get(){if(this.pcoGeometry.root){return Potree.PointCloudArena4DGeometryNode.nodesLoading>0?0:1;}else {return 0;}}}); //Potree.PointCloudArena4D.prototype.updateMatrixWorld = function( force ){
	//  //node.matrixWorld.multiplyMatrices( node.parent.matrixWorld, node.matrix );
	//  
	//  if ( this.matrixAutoUpdate === true ) this.updateMatrix();
	//
	//  if ( this.matrixWorldNeedsUpdate === true || force === true ) {
	//
	//    if ( this.parent === undefined ) {
	//
	//      this.matrixWorld.copy( this.matrix );
	//
	//    } else {
	//
	//      this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	//
	//    }
	//
	//    this.matrixWorldNeedsUpdate = false;
	//
	//    force = true;
	//
	//  }
	//};
	Potree.PointCloudArena4DGeometryNode=function(){var scope=this;this.left=null;this.right=null;this.boundingBox=null;this.number=null;this.pcoGeometry=null;this.loaded=false;this.numPoints=0;this.level=0;};Potree.PointCloudArena4DGeometryNode.nodesLoading=0;Potree.PointCloudArena4DGeometryNode.prototype.load=function(){if(this.loaded||this.loading){return;}if(Potree.PointCloudArena4DGeometryNode.nodesLoading>=5){return;}this.loading=true;Potree.PointCloudArena4DGeometryNode.nodesLoading++;var url=this.pcoGeometry.url+"?node="+this.number;var xhr=new XMLHttpRequest();xhr.open("GET",url,true);xhr.responseType="arraybuffer";var scope=this;xhr.onreadystatechange=function(){if(!(xhr.readyState===4&&xhr.status===200)){return;}var buffer=xhr.response;var view=new DataView(buffer);var numPoints=buffer.byteLength/17;var positions=new Float32Array(numPoints*3);var colors=new Float32Array(numPoints*3);var indices=new Uint32Array(numPoints);for(var i=0;i<numPoints;i++){var x=view.getFloat32(i*17+0,true)+scope.boundingBox.min.x;var y=view.getFloat32(i*17+4,true)+scope.boundingBox.min.y;var z=view.getFloat32(i*17+8,true)+scope.boundingBox.min.z;var r=view.getUint8(i*17+12,true)/256;var g=view.getUint8(i*17+13,true)/256;var b=view.getUint8(i*17+14,true)/256;positions[i*3+0]=x;positions[i*3+1]=y;positions[i*3+2]=z;colors[i*3+0]=r;colors[i*3+1]=g;colors[i*3+2]=b;indices[i]=i;}var geometry=new _three2.default.BufferGeometry();geometry.addAttribute("position",new _three2.default.BufferAttribute(positions,3));geometry.addAttribute("color",new _three2.default.BufferAttribute(colors,3));geometry.addAttribute("indices",new _three2.default.BufferAttribute(indices,1));geometry.addAttribute("normal",new _three2.default.BufferAttribute(new Float32Array(numPoints*3),3));scope.geometry=geometry;scope.loaded=true;Potree.PointCloudArena4DGeometryNode.nodesLoading--;geometry.boundingBox=scope.boundingBox;geometry.boundingSphere=scope.boundingSphere;scope.numPoints=numPoints;scope.loading=false;};xhr.send(null);};Potree.PointCloudArena4DGeometry=function(){var scope=this;this.numPoints=0;this.version=0;this.boundingBox=null;this.numNodes=0;this.name=null;this.provider=null;this.url=null;this.root=null;this.levels=0;this._spacing=null;this.pointAttributes=new Potree.PointAttributes(["POSITION_CARTESIAN","COLOR_PACKED"]);};Potree.PointCloudArena4DGeometry.load=function(url,callback){var xhr=new XMLHttpRequest();xhr.open('GET',url+"?info",true);xhr.onreadystatechange=function(){try{if(xhr.readyState===4&&xhr.status===200){var response=JSON.parse(xhr.responseText);var geometry=new Potree.PointCloudArena4DGeometry();geometry.url=url;geometry.name=response.Name;geometry.provider=response.Provider;geometry.numNodes=response.Nodes;geometry.numPoints=response.Points;geometry.version=response.Version;geometry.boundingBox=new _three2.default.Box3(new _three2.default.Vector3().fromArray(response.BoundingBox.slice(0,3)),new _three2.default.Vector3().fromArray(response.BoundingBox.slice(3,6)));if(response.Spacing){geometry.spacing=response.Spacing;}var offset=geometry.boundingBox.min.clone().multiplyScalar(-1);geometry.boundingBox.min.add(offset);geometry.boundingBox.max.add(offset);geometry.offset=offset;var center=geometry.boundingBox.center();var radius=geometry.boundingBox.size().length()/2;geometry.boundingSphere=new _three2.default.Sphere(center,radius);geometry.loadHierarchy();callback(geometry);}else if(xhr.readyState===4){callback(null);}}catch(e){callback(null);}};xhr.send(null);};Potree.PointCloudArena4DGeometry.prototype.loadHierarchy=function(){var url=this.url+"?tree";var xhr=new XMLHttpRequest();xhr.open("GET",url,true);xhr.responseType="arraybuffer";var scope=this;xhr.onreadystatechange=function(){if(!(xhr.readyState===4&&xhr.status===200)){return;}var buffer=xhr.response;var numNodes=buffer.byteLength/3;var view=new DataView(buffer);var stack=[];var root=null;var levels=0;var start=new Date().getTime(); // read hierarchy
	for(var i=0;i<numNodes;i++){var mask=view.getUint8(i*3+0,true);var numPoints=view.getUint16(i*3+1,true);var hasLeft=(mask&1)>0;var hasRight=(mask&2)>0;var splitX=(mask&4)>0;var splitY=(mask&8)>0;var splitZ=(mask&16)>0;var split=null;if(splitX){split="X";}else if(splitY){split="Y";}if(splitZ){split="Z";}var node=new Potree.PointCloudArena4DGeometryNode();node.hasLeft=hasLeft;node.hasRight=hasRight;node.split=split;node.isLeaf=!hasLeft&&!hasRight;node.number=i;node.left=null;node.right=null;node.pcoGeometry=scope;node.level=stack.length;levels=Math.max(levels,node.level);if(stack.length>0){var parent=stack[stack.length-1];node.boundingBox=parent.boundingBox.clone();var parentBBSize=parent.boundingBox.size();if(parent.hasLeft&&!parent.left){parent.left=node;if(parent.split==="X"){node.boundingBox.max.x=node.boundingBox.min.x+parentBBSize.x/2;}else if(parent.split==="Y"){node.boundingBox.max.y=node.boundingBox.min.y+parentBBSize.y/2;}else if(parent.split==="Z"){node.boundingBox.max.z=node.boundingBox.min.z+parentBBSize.z/2;}var center=node.boundingBox.center();var radius=node.boundingBox.size().length()/2;node.boundingSphere=new _three2.default.Sphere(center,radius);}else {parent.right=node;if(parent.split==="X"){node.boundingBox.min.x=node.boundingBox.min.x+parentBBSize.x/2;}else if(parent.split==="Y"){node.boundingBox.min.y=node.boundingBox.min.y+parentBBSize.y/2;}else if(parent.split==="Z"){node.boundingBox.min.z=node.boundingBox.min.z+parentBBSize.z/2;}var center=node.boundingBox.center();var radius=node.boundingBox.size().length()/2;node.boundingSphere=new _three2.default.Sphere(center,radius);}}else {root=node;root.boundingBox=scope.boundingBox.clone();var center=root.boundingBox.center();var radius=root.boundingBox.size().length()/2;root.boundingSphere=new _three2.default.Sphere(center,radius);}var bbSize=node.boundingBox.size();node.spacing=(bbSize.x+bbSize.y+bbSize.z)/3/75;stack.push(node);if(node.isLeaf){var done=false;while(!done&&stack.length>0){stack.pop();var top=stack[stack.length-1];done=stack.length>0&&top.hasRight&&top.right==null;}}}var end=new Date().getTime();var parseDuration=end-start;var msg=parseDuration; //document.getElementById("lblDebug").innerHTML = msg;
	scope.root=root;scope.levels=levels; //console.log(this.root);
	};xhr.send(null);};Object.defineProperty(Potree.PointCloudArena4DGeometry.prototype,"spacing",{get:function get(){if(this._spacing){return this._spacing;}else if(this.root){return this.root.spacing;}else {null;}},set:function set(value){this._spacing=value;}}); // Export the Potree object for **Node.js**, with
	// backwards-compatibility for the old `require()` API. If we're in
	// the browser, add `_` as a global object via a string identifier,
	// for Closure Compiler "advanced" mode.
	if(true){if(typeof module!=='undefined'&&module.exports){exports=module.exports=Potree;}exports.Potree=Potree;}else {undefined['Potree']=Potree;}

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _three = __webpack_require__(2);

	var _three2 = _interopRequireDefault(_three);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ImageUtils = {

	  getNormalMap: function getNormalMap(image, depth) {

	    // Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

	    function cross(a, b) {

	      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
	    }

	    function subtract(a, b) {

	      return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
	    }

	    function normalize(a) {

	      var l = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
	      return [a[0] / l, a[1] / l, a[2] / l];
	    }

	    depth = depth | 1;

	    var width = image.width;
	    var height = image.height;

	    var canvas = document.createElement('canvas');
	    canvas.width = width;
	    canvas.height = height;

	    var context = canvas.getContext('2d');
	    context.drawImage(image, 0, 0);

	    var data = context.getImageData(0, 0, width, height).data;
	    var imageData = context.createImageData(width, height);
	    var output = imageData.data;

	    for (var x = 0; x < width; x++) {

	      for (var y = 0; y < height; y++) {

	        var ly = y - 1 < 0 ? 0 : y - 1;
	        var uy = y + 1 > height - 1 ? height - 1 : y + 1;
	        var lx = x - 1 < 0 ? 0 : x - 1;
	        var ux = x + 1 > width - 1 ? width - 1 : x + 1;

	        var points = [];
	        var origin = [0, 0, data[(y * width + x) * 4] / 255 * depth];
	        points.push([-1, 0, data[(y * width + lx) * 4] / 255 * depth]);
	        points.push([-1, -1, data[(ly * width + lx) * 4] / 255 * depth]);
	        points.push([0, -1, data[(ly * width + x) * 4] / 255 * depth]);
	        points.push([1, -1, data[(ly * width + ux) * 4] / 255 * depth]);
	        points.push([1, 0, data[(y * width + ux) * 4] / 255 * depth]);
	        points.push([1, 1, data[(uy * width + ux) * 4] / 255 * depth]);
	        points.push([0, 1, data[(uy * width + x) * 4] / 255 * depth]);
	        points.push([-1, 1, data[(uy * width + lx) * 4] / 255 * depth]);

	        var normals = [];
	        var num_points = points.length;

	        for (var i = 0; i < num_points; i++) {

	          var v1 = points[i];
	          var v2 = points[(i + 1) % num_points];
	          v1 = subtract(v1, origin);
	          v2 = subtract(v2, origin);
	          normals.push(normalize(cross(v1, v2)));
	        }

	        var normal = [0, 0, 0];

	        for (var i = 0; i < normals.length; i++) {

	          normal[0] += normals[i][0];
	          normal[1] += normals[i][1];
	          normal[2] += normals[i][2];
	        }

	        normal[0] /= normals.length;
	        normal[1] /= normals.length;
	        normal[2] /= normals.length;

	        var idx = (y * width + x) * 4;

	        output[idx] = (normal[0] + 1.0) / 2.0 * 255 | 0;
	        output[idx + 1] = (normal[1] + 1.0) / 2.0 * 255 | 0;
	        output[idx + 2] = normal[2] * 255 | 0;
	        output[idx + 3] = 255;
	      }
	    }

	    context.putImageData(imageData, 0, 0);

	    return canvas;
	  },

	  generateDataTexture: function generateDataTexture(width, height, color) {

	    var size = width * height;
	    var data = new Uint8Array(3 * size);

	    var r = Math.floor(color.r * 255);
	    var g = Math.floor(color.g * 255);
	    var b = Math.floor(color.b * 255);

	    for (var i = 0; i < size; i++) {

	      data[i * 3] = r;
	      data[i * 3 + 1] = g;
	      data[i * 3 + 2] = b;
	    }

	    var texture = new _three2.default.DataTexture(data, width, height, _three2.default.RGBFormat);
	    texture.needsUpdate = true;

	    return texture;
	  },

	  crossOrigin: undefined,

	  loadTexture: function loadTexture(url, mapping, onLoad, onError) {

	    console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');

	    var loader = new _three2.default.TextureLoader();
	    loader.setCrossOrigin(this.crossOrigin);

	    var texture = loader.load(url, onLoad, undefined, onError);

	    if (mapping) texture.mapping = mapping;

	    return texture;
	  },

	  loadTextureCube: function loadTextureCube(urls, mapping, onLoad, onError) {

	    console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');

	    var loader = new _three2.default.CubeTextureLoader();
	    loader.setCrossOrigin(this.crossOrigin);

	    var texture = loader.load(urls, onLoad, undefined, onError);

	    if (mapping) texture.mapping = mapping;

	    return texture;
	  },

	  loadCompressedTexture: function loadCompressedTexture() {

	    console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
	  },

	  loadCompressedTextureCube: function loadCompressedTextureCube() {

	    console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
	  }

	}; /**
	    * @author alteredq / http://alteredqualia.com/
	    * @author mrdoob / http://mrdoob.com/
	    * @author Daosheng Mu / https://github.com/DaoshengMu/
	    */

	exports.default = ImageUtils;

/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * from: http://eloquentjavascript.net/1st_edition/appendix2.html
	 *
	 */

	var BinaryHeap = function BinaryHeap(scoreFunction) {
	  this.content = [];
	  this.scoreFunction = scoreFunction;
	};

	BinaryHeap.prototype = {
	  push: function push(element) {
	    // Add the new element to the end of the array.
	    this.content.push(element);
	    // Allow it to bubble up.
	    this.bubbleUp(this.content.length - 1);
	  },

	  pop: function pop() {
	    // Store the first element so we can return it later.
	    var result = this.content[0];
	    // Get the element at the end of the array.
	    var end = this.content.pop();
	    // If there are any elements left, put the end element at the
	    // start, and let it sink down.
	    if (this.content.length > 0) {
	      this.content[0] = end;
	      this.sinkDown(0);
	    }
	    return result;
	  },

	  remove: function remove(node) {
	    var length = this.content.length;
	    // To remove a value, we must search through the array to find
	    // it.
	    for (var i = 0; i < length; i++) {
	      if (this.content[i] != node) continue;
	      // When it is found, the process seen in 'pop' is repeated
	      // to fill up the hole.
	      var end = this.content.pop();
	      // If the element we popped was the one we needed to remove,
	      // we're done.
	      if (i == length - 1) break;
	      // Otherwise, we replace the removed element with the popped
	      // one, and allow it to float up or sink down as appropriate.
	      this.content[i] = end;
	      this.bubbleUp(i);
	      this.sinkDown(i);
	      break;
	    }
	  },

	  size: function size() {
	    return this.content.length;
	  },

	  bubbleUp: function bubbleUp(n) {
	    // Fetch the element that has to be moved.
	    var element = this.content[n],
	        score = this.scoreFunction(element);
	    // When at 0, an element can not go up any further.
	    while (n > 0) {
	      // Compute the parent element's index, and fetch it.
	      var parentN = Math.floor((n + 1) / 2) - 1,
	          parent = this.content[parentN];
	      // If the parent has a lesser score, things are in order and we
	      // are done.
	      if (score >= this.scoreFunction(parent)) break;

	      // Otherwise, swap the parent with the current element and
	      // continue.
	      this.content[parentN] = element;
	      this.content[n] = parent;
	      n = parentN;
	    }
	  },

	  sinkDown: function sinkDown(n) {
	    // Look up the target element and its score.
	    var length = this.content.length,
	        element = this.content[n],
	        elemScore = this.scoreFunction(element);

	    while (true) {
	      // Compute the indices of the child elements.
	      var child2N = (n + 1) * 2,
	          child1N = child2N - 1;
	      // This is used to store the new position of the element,
	      // if any.
	      var swap = null;
	      // If the first child exists (is inside the array)...
	      if (child1N < length) {
	        // Look it up and compute its score.
	        var child1 = this.content[child1N],
	            child1Score = this.scoreFunction(child1);
	        // If the score is less than our element's, we need to swap.
	        if (child1Score < elemScore) swap = child1N;
	      }
	      // Do the same checks for the other child.
	      if (child2N < length) {
	        var child2 = this.content[child2N],
	            child2Score = this.scoreFunction(child2);
	        if (child2Score < (swap == null ? elemScore : child1Score)) swap = child2N;
	      }

	      // No need to swap further, we are done.
	      if (swap == null) break;

	      // Otherwise, swap and continue.
	      this.content[n] = this.content[swap];
	      this.content[swap] = element;
	      n = swap;
	    }
	  }
	};

	exports.default = BinaryHeap;

/***/ },
/* 11 */
/***/ function(module, exports) {

	// stats.js - http://github.com/mrdoob/stats.js
	var Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel("FPS","#0ff","#002")),f=h(new Stats.Panel("MS","#0f0","#020"));
	if(self.performance&&self.performance.memory)var t=h(new Stats.Panel("MB","#f08","#201"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};
	Stats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=f;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,
	v){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+" "+h+" ("+e(c)+"-"+e(g)+")",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};"object"===typeof module&&(module.exports=Stats);


/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function ProgressBar() {
	  this._progress = 0;
	  this._message = "";

	  this.maxOpacity = 0.6;

	  this.element = document.createElement("div");
	  this.elProgress = document.createElement("div");
	  this.elProgressMessage = document.createElement("div");

	  //this.element.innerHTML = "element";
	  //this.elProgress.innerHTML = "progress";

	  this.element.innerHTML = "";
	  this.element.style.position = "fixed";
	  this.element.style.bottom = "40px";
	  this.element.style.width = "200px";
	  this.element.style.marginLeft = "-100px";
	  this.element.style.left = "50%";
	  this.element.style.borderRadius = "5px";
	  this.element.style.border = "1px solid #727678";
	  this.element.style.height = "16px";
	  this.element.style.padding = "1px";
	  this.element.style.textAlign = "center";
	  this.element.style.backgroundColor = "#6ba8e5";
	  this.element.style.opacity = this.maxOpacity;
	  this.element.style.pointerEvents = "none";

	  this.elProgress.innerHTML = " ";
	  this.elProgress.style.backgroundColor = "#b8e1fc";
	  this.elProgress.style.position = "absolute";
	  this.elProgress.style.borderRadius = "5px";
	  this.elProgress.style.width = "0%";
	  this.elProgress.style.height = "100%";
	  this.elProgress.style.margin = "0px";
	  this.elProgress.style.padding = "0px";

	  this.elProgressMessage.style.position = "absolute";
	  this.elProgressMessage.style.width = "100%";
	  this.elProgressMessage.innerHTML = "loading 1 / 10";

	  document.body.appendChild(this.element);
	  this.element.appendChild(this.elProgress);
	  this.element.appendChild(this.elProgressMessage);

	  this.hide();
	};

	ProgressBar.prototype.hide = function () {
	  this.element.style.opacity = 0;
	  this.element.style.transition = "all 0.2s ease";
	};

	ProgressBar.prototype.show = function () {
	  this.element.style.opacity = this.maxOpacity;
	  this.element.style.transition = "all 0.2s ease";
	};

	Object.defineProperty(ProgressBar.prototype, "progress", {
	  get: function get() {
	    return this._progress;
	  },
	  set: function set(value) {
	    this._progress = value;
	    this.elProgress.style.width = value * 100 + "%";
	  }
	});

	Object.defineProperty(ProgressBar.prototype, "message", {
	  get: function get() {
	    return this._message;
	  },
	  set: function set(message) {
	    this._message = message;
	    this.elProgressMessage.innerHTML = message;
	  }
	});

	exports.default = ProgressBar;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _three = __webpack_require__(2);

	var _three2 = _interopRequireDefault(_three);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var GizmoMaterial = function GizmoMaterial(parameters) {

	  _three2.default.MeshBasicMaterial.call(this);

	  this.depthTest = false;
	  this.depthWrite = false;
	  this.side = _three2.default.FrontSide;
	  this.transparent = true;

	  this.setValues(parameters);

	  this.oldColor = this.color.clone();
	  this.oldOpacity = this.opacity;

	  this.highlight = function (highlighted) {

	    if (highlighted) {

	      this.color.setRGB(1, 1, 0);
	      this.opacity = 1;
	    } else {

	      this.color.copy(this.oldColor);
	      this.opacity = this.oldOpacity;
	    }
	  };
	};

	GizmoMaterial.prototype = Object.create(_three2.default.MeshBasicMaterial.prototype);
	GizmoMaterial.prototype.constructor = GizmoMaterial;

	var GizmoLineMaterial = function GizmoLineMaterial(parameters) {

	  _three2.default.LineBasicMaterial.call(this);

	  this.depthTest = false;
	  this.depthWrite = false;
	  this.transparent = true;
	  this.linewidth = 1;

	  this.setValues(parameters);

	  this.oldColor = this.color.clone();
	  this.oldOpacity = this.opacity;

	  this.highlight = function (highlighted) {

	    if (highlighted) {

	      this.color.setRGB(1, 1, 0);
	      this.opacity = 1;
	    } else {

	      this.color.copy(this.oldColor);
	      this.opacity = this.oldOpacity;
	    }
	  };
	};

	GizmoLineMaterial.prototype = Object.create(_three2.default.LineBasicMaterial.prototype);
	GizmoLineMaterial.prototype.constructor = GizmoLineMaterial;

	var pickerMaterial = new GizmoMaterial({ visible: false, transparent: false });

	var TransformGizmo = function TransformGizmo() {

	  var scope = this;

	  this.init = function () {

	    _three2.default.Object3D.call(this);

	    this.handles = new _three2.default.Object3D();
	    this.pickers = new _three2.default.Object3D();
	    this.planes = new _three2.default.Object3D();

	    this.add(this.handles);
	    this.add(this.pickers);
	    this.add(this.planes);

	    //// PLANES

	    var planeGeometry = new _three2.default.PlaneBufferGeometry(50, 50, 2, 2);
	    var planeMaterial = new _three2.default.MeshBasicMaterial({ visible: false, side: _three2.default.DoubleSide });

	    var planes = {
	      "XY": new _three2.default.Mesh(planeGeometry, planeMaterial),
	      "YZ": new _three2.default.Mesh(planeGeometry, planeMaterial),
	      "XZ": new _three2.default.Mesh(planeGeometry, planeMaterial),
	      "XYZE": new _three2.default.Mesh(planeGeometry, planeMaterial)
	    };

	    this.activePlane = planes["XYZE"];

	    planes["YZ"].rotation.set(0, Math.PI / 2, 0);
	    planes["XZ"].rotation.set(-Math.PI / 2, 0, 0);

	    for (var i in planes) {

	      planes[i].name = i;
	      this.planes.add(planes[i]);
	      this.planes[i] = planes[i];
	    }

	    //// HANDLES AND PICKERS

	    var setupGizmos = function setupGizmos(gizmoMap, parent) {

	      for (var name in gizmoMap) {

	        for (i = gizmoMap[name].length; i--;) {

	          var object = gizmoMap[name][i][0];
	          var position = gizmoMap[name][i][1];
	          var rotation = gizmoMap[name][i][2];

	          object.name = name;

	          if (position) object.position.set(position[0], position[1], position[2]);
	          if (rotation) object.rotation.set(rotation[0], rotation[1], rotation[2]);

	          parent.add(object);
	        }
	      }
	    };

	    setupGizmos(this.handleGizmos, this.handles);
	    setupGizmos(this.pickerGizmos, this.pickers);

	    // reset Transformations

	    this.traverse(function (child) {

	      if (child instanceof _three2.default.Mesh) {

	        child.updateMatrix();

	        var tempGeometry = child.geometry.clone();
	        tempGeometry.applyMatrix(child.matrix);
	        child.geometry = tempGeometry;

	        child.position.set(0, 0, 0);
	        child.rotation.set(0, 0, 0);
	        child.scale.set(1, 1, 1);
	      }
	    });
	  };

	  this.highlight = function (axis) {

	    this.traverse(function (child) {

	      if (child.material && child.material.highlight) {

	        if (child.name === axis) {

	          child.material.highlight(true);
	        } else {

	          child.material.highlight(false);
	        }
	      }
	    });
	  };
	};

	TransformGizmo.prototype = Object.create(_three2.default.Object3D.prototype);
	TransformGizmo.prototype.constructor = TransformGizmo;

	TransformGizmo.prototype.update = function (rotation, eyeObject) {

	  var vec1 = new _three2.default.Vector3(0, 0, 0);
	  var vec2 = new _three2.default.Vector3(0, 1, 0);
	  var lookAtMatrix = new _three2.default.Matrix4();

	  this.traverse(function (child) {

	    if (child.name.search("E") !== -1) {

	      child.quaternion.setFromRotationMatrix(lookAtMatrix.lookAt(eyeObject, vec1, vec2));
	    } else if (child.name.search("X") !== -1 || child.name.search("Y") !== -1 || child.name.search("Z") !== -1) {

	      child.quaternion.setFromEuler(rotation);
	    }
	  });
	};

	var TransformGizmoTranslate = function TransformGizmoTranslate() {

	  TransformGizmo.call(this);

	  var arrowGeometry = new _three2.default.Geometry();
	  var mesh = new _three2.default.Mesh(new _three2.default.CylinderGeometry(0, 0.05, 0.2, 12, 1, false));
	  mesh.position.y = 0.5;
	  mesh.updateMatrix();

	  arrowGeometry.merge(mesh.geometry, mesh.matrix);

	  var lineXGeometry = new _three2.default.BufferGeometry();
	  lineXGeometry.addAttribute('position', new _three2.default.BufferAttribute(new Float32Array([0, 0, 0, 1, 0, 0]), 3));

	  var lineYGeometry = new _three2.default.BufferGeometry();
	  lineYGeometry.addAttribute('position', new _three2.default.BufferAttribute(new Float32Array([0, 0, 0, 0, 1, 0]), 3));

	  var lineZGeometry = new _three2.default.BufferGeometry();
	  lineZGeometry.addAttribute('position', new _three2.default.BufferAttribute(new Float32Array([0, 0, 0, 0, 0, 1]), 3));

	  this.handleGizmos = {

	    X: [[new _three2.default.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xff0000 })), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new _three2.default.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xff0000 }))]],

	    Y: [[new _three2.default.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x00ff00 })), [0, 0.5, 0]], [new _three2.default.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x00ff00 }))]],

	    Z: [[new _three2.default.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new _three2.default.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x0000ff }))]],

	    XYZ: [[new _three2.default.Mesh(new _three2.default.OctahedronGeometry(0.1, 0), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 })), [0, 0, 0], [0, 0, 0]]],

	    XY: [[new _three2.default.Mesh(new _three2.default.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xffff00, opacity: 0.25 })), [0.15, 0.15, 0]]],

	    YZ: [[new _three2.default.Mesh(new _three2.default.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0x00ffff, opacity: 0.25 })), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],

	    XZ: [[new _three2.default.Mesh(new _three2.default.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xff00ff, opacity: 0.25 })), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]]

	  };

	  this.pickerGizmos = {

	    X: [[new _three2.default.Mesh(new _three2.default.CylinderGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],

	    Y: [[new _three2.default.Mesh(new _three2.default.CylinderGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0.6, 0]]],

	    Z: [[new _three2.default.Mesh(new _three2.default.CylinderGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],

	    XYZ: [[new _three2.default.Mesh(new _three2.default.OctahedronGeometry(0.2, 0), pickerMaterial)]],

	    XY: [[new _three2.default.Mesh(new _three2.default.PlaneBufferGeometry(0.4, 0.4), pickerMaterial), [0.2, 0.2, 0]]],

	    YZ: [[new _three2.default.Mesh(new _three2.default.PlaneBufferGeometry(0.4, 0.4), pickerMaterial), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],

	    XZ: [[new _three2.default.Mesh(new _three2.default.PlaneBufferGeometry(0.4, 0.4), pickerMaterial), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]

	  };

	  this.setActivePlane = function (axis, eyeObject) {

	    var tempMatrix = new _three2.default.Matrix4();
	    eyeObject.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));

	    if (axis === "X") {

	      this.activePlane = this.planes["XY"];

	      if (Math.abs(eyeObject.y) > Math.abs(eyeObject.z)) this.activePlane = this.planes["XZ"];
	    }

	    if (axis === "Y") {

	      this.activePlane = this.planes["XY"];

	      if (Math.abs(eyeObject.x) > Math.abs(eyeObject.z)) this.activePlane = this.planes["YZ"];
	    }

	    if (axis === "Z") {

	      this.activePlane = this.planes["XZ"];

	      if (Math.abs(eyeObject.x) > Math.abs(eyeObject.y)) this.activePlane = this.planes["YZ"];
	    }

	    if (axis === "XYZ") this.activePlane = this.planes["XYZE"];

	    if (axis === "XY") this.activePlane = this.planes["XY"];

	    if (axis === "YZ") this.activePlane = this.planes["YZ"];

	    if (axis === "XZ") this.activePlane = this.planes["XZ"];
	  };

	  this.init();
	};

	TransformGizmoTranslate.prototype = Object.create(TransformGizmo.prototype);
	TransformGizmoTranslate.prototype.constructor = TransformGizmoTranslate;

	var TransformGizmoRotate = function TransformGizmoRotate() {

	  TransformGizmo.call(this);

	  var CircleGeometry = function CircleGeometry(radius, facing, arc) {

	    var geometry = new _three2.default.BufferGeometry();
	    var vertices = [];
	    arc = arc ? arc : 1;

	    for (var i = 0; i <= 64 * arc; ++i) {

	      if (facing === 'x') vertices.push(0, Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius);
	      if (facing === 'y') vertices.push(Math.cos(i / 32 * Math.PI) * radius, 0, Math.sin(i / 32 * Math.PI) * radius);
	      if (facing === 'z') vertices.push(Math.sin(i / 32 * Math.PI) * radius, Math.cos(i / 32 * Math.PI) * radius, 0);
	    }

	    geometry.addAttribute('position', new _three2.default.BufferAttribute(new Float32Array(vertices), 3));
	    return geometry;
	  };

	  this.handleGizmos = {

	    X: [[new _three2.default.Line(new CircleGeometry(1, 'x', 0.5), new GizmoLineMaterial({ color: 0xff0000 }))]],

	    Y: [[new _three2.default.Line(new CircleGeometry(1, 'y', 0.5), new GizmoLineMaterial({ color: 0x00ff00 }))]],

	    Z: [[new _three2.default.Line(new CircleGeometry(1, 'z', 0.5), new GizmoLineMaterial({ color: 0x0000ff }))]],

	    E: [[new _three2.default.Line(new CircleGeometry(1.25, 'z', 1), new GizmoLineMaterial({ color: 0xcccc00 }))]],

	    XYZE: [[new _three2.default.Line(new CircleGeometry(1, 'z', 1), new GizmoLineMaterial({ color: 0x787878 }))]]

	  };

	  this.pickerGizmos = {

	    X: [[new _three2.default.Mesh(new _three2.default.TorusGeometry(1, 0.12, 4, 12, Math.PI), pickerMaterial), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],

	    Y: [[new _three2.default.Mesh(new _three2.default.TorusGeometry(1, 0.12, 4, 12, Math.PI), pickerMaterial), [0, 0, 0], [Math.PI / 2, 0, 0]]],

	    Z: [[new _three2.default.Mesh(new _three2.default.TorusGeometry(1, 0.12, 4, 12, Math.PI), pickerMaterial), [0, 0, 0], [0, 0, -Math.PI / 2]]],

	    E: [[new _three2.default.Mesh(new _three2.default.TorusGeometry(1.25, 0.12, 2, 24), pickerMaterial)]],

	    XYZE: [[new _three2.default.Mesh(new _three2.default.Geometry())] // TODO
	    ]

	  };

	  this.setActivePlane = function (axis) {

	    if (axis === "E") this.activePlane = this.planes["XYZE"];

	    if (axis === "X") this.activePlane = this.planes["YZ"];

	    if (axis === "Y") this.activePlane = this.planes["XZ"];

	    if (axis === "Z") this.activePlane = this.planes["XY"];
	  };

	  this.update = function (rotation, eye2) {

	    TransformGizmo.prototype.update.apply(this, arguments);

	    var group = {

	      handles: this["handles"],
	      pickers: this["pickers"]

	    };

	    var tempMatrix = new _three2.default.Matrix4();
	    var worldRotation = new _three2.default.Euler(0, 0, 1);
	    var tempQuaternion = new _three2.default.Quaternion();
	    var unitX = new _three2.default.Vector3(1, 0, 0);
	    var unitY = new _three2.default.Vector3(0, 1, 0);
	    var unitZ = new _three2.default.Vector3(0, 0, 1);
	    var quaternionX = new _three2.default.Quaternion();
	    var quaternionY = new _three2.default.Quaternion();
	    var quaternionZ = new _three2.default.Quaternion();
	    var eyeObject = eye2.clone();

	    worldRotation.copy(this.planes["XY"].rotation);
	    tempQuaternion.setFromEuler(worldRotation);

	    tempMatrix.makeRotationFromQuaternion(tempQuaternion).getInverse(tempMatrix);
	    eyeObject.applyMatrix4(tempMatrix);

	    this.traverse(function (child) {

	      tempQuaternion.setFromEuler(worldRotation);

	      if (child.name === "X") {

	        quaternionX.setFromAxisAngle(unitX, Math.atan2(-eyeObject.y, eyeObject.z));
	        tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
	        child.quaternion.copy(tempQuaternion);
	      }

	      if (child.name === "Y") {

	        quaternionY.setFromAxisAngle(unitY, Math.atan2(eyeObject.x, eyeObject.z));
	        tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
	        child.quaternion.copy(tempQuaternion);
	      }

	      if (child.name === "Z") {

	        quaternionZ.setFromAxisAngle(unitZ, Math.atan2(eyeObject.y, eyeObject.x));
	        tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);
	        child.quaternion.copy(tempQuaternion);
	      }
	    });
	  };

	  this.init();
	};

	TransformGizmoRotate.prototype = Object.create(TransformGizmo.prototype);
	TransformGizmoRotate.prototype.constructor = TransformGizmoRotate;

	var TransformGizmoScale = function TransformGizmoScale() {

	  TransformGizmo.call(this);

	  var arrowGeometry = new _three2.default.Geometry();
	  var mesh = new _three2.default.Mesh(new _three2.default.BoxGeometry(0.125, 0.125, 0.125));
	  mesh.position.y = 0.5;
	  mesh.updateMatrix();

	  arrowGeometry.merge(mesh.geometry, mesh.matrix);

	  var lineXGeometry = new _three2.default.BufferGeometry();
	  lineXGeometry.addAttribute('position', new _three2.default.BufferAttribute(new Float32Array([0, 0, 0, 1, 0, 0]), 3));

	  var lineYGeometry = new _three2.default.BufferGeometry();
	  lineYGeometry.addAttribute('position', new _three2.default.BufferAttribute(new Float32Array([0, 0, 0, 0, 1, 0]), 3));

	  var lineZGeometry = new _three2.default.BufferGeometry();
	  lineZGeometry.addAttribute('position', new _three2.default.BufferAttribute(new Float32Array([0, 0, 0, 0, 0, 1]), 3));

	  this.handleGizmos = {

	    X: [[new _three2.default.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xff0000 })), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new _three2.default.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xff0000 }))]],

	    Y: [[new _three2.default.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x00ff00 })), [0, 0.5, 0]], [new _three2.default.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x00ff00 }))]],

	    Z: [[new _three2.default.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new _three2.default.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x0000ff }))]],

	    XYZ: [[new _three2.default.Mesh(new _three2.default.BoxGeometry(0.125, 0.125, 0.125), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 }))]]

	  };

	  this.pickerGizmos = {

	    X: [[new _three2.default.Mesh(new _three2.default.CylinderGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],

	    Y: [[new _three2.default.Mesh(new _three2.default.CylinderGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0.6, 0]]],

	    Z: [[new _three2.default.Mesh(new _three2.default.CylinderGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],

	    XYZ: [[new _three2.default.Mesh(new _three2.default.BoxGeometry(0.4, 0.4, 0.4), pickerMaterial)]]

	  };

	  this.setActivePlane = function (axis, eyeObject) {

	    var tempMatrix = new _three2.default.Matrix4();
	    eyeObject.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));

	    if (axis === "X") {

	      this.activePlane = this.planes["XY"];
	      if (Math.abs(eyeObject.y) > Math.abs(eyeObject.z)) this.activePlane = this.planes["XZ"];
	    }

	    if (axis === "Y") {

	      this.activePlane = this.planes["XY"];
	      if (Math.abs(eyeObject.x) > Math.abs(eyeObject.z)) this.activePlane = this.planes["YZ"];
	    }

	    if (axis === "Z") {

	      this.activePlane = this.planes["XZ"];
	      if (Math.abs(eyeObject.x) > Math.abs(eyeObject.y)) this.activePlane = this.planes["YZ"];
	    }

	    if (axis === "XYZ") this.activePlane = this.planes["XYZE"];
	  };

	  this.init();
	};

	TransformGizmoScale.prototype = Object.create(TransformGizmo.prototype);
	TransformGizmoScale.prototype.constructor = TransformGizmoScale;

	var TransformControls = function TransformControls(camera, domElement) {

	  // TODO: Make non-uniform scale and rotate play nice in hierarchies
	  // TODO: ADD RXYZ controls

	  _three2.default.Object3D.call(this);

	  var domElement = domElement !== undefined ? domElement : document;

	  this.object = undefined;
	  this.visible = false;
	  this.translationSnap = null;
	  this.rotationSnap = null;
	  this.space = "world";
	  this.size = 1;
	  this.axis = null;

	  var scope = this;

	  var _mode = "translate";
	  var _dragging = false;
	  var _plane = "XY";
	  var _gizmo = {

	    "translate": new TransformGizmoTranslate(),
	    "rotate": new TransformGizmoRotate(),
	    "scale": new TransformGizmoScale()
	  };

	  for (var type in _gizmo) {

	    var gizmoObj = _gizmo[type];

	    gizmoObj.visible = type === _mode;
	    this.add(gizmoObj);
	  }

	  var changeEvent = { type: "change" };
	  var mouseDownEvent = { type: "mouseDown" };
	  var mouseUpEvent = { type: "mouseUp", mode: _mode };
	  var objectChangeEvent = { type: "objectChange" };
	  var startEvent = { type: 'start' };
	  var endEvent = { type: 'end' };

	  var ray = new _three2.default.Raycaster();
	  var pointerVector = new _three2.default.Vector2();

	  var point = new _three2.default.Vector3();
	  var offset = new _three2.default.Vector3();

	  var rotation = new _three2.default.Vector3();
	  var offsetRotation = new _three2.default.Vector3();
	  var scale = 1;

	  var lookAtMatrix = new _three2.default.Matrix4();
	  var eyeObject = new _three2.default.Vector3();
	  var eyeCamera = new _three2.default.Vector3();

	  var tempMatrix = new _three2.default.Matrix4();
	  var tempVector = new _three2.default.Vector3();
	  var tempQuaternion = new _three2.default.Quaternion();
	  var unitX = new _three2.default.Vector3(1, 0, 0);
	  var unitY = new _three2.default.Vector3(0, 1, 0);
	  var unitZ = new _three2.default.Vector3(0, 0, 1);

	  var quaternionXYZ = new _three2.default.Quaternion();
	  var quaternionX = new _three2.default.Quaternion();
	  var quaternionY = new _three2.default.Quaternion();
	  var quaternionZ = new _three2.default.Quaternion();
	  var quaternionE = new _three2.default.Quaternion();

	  var oldPosition = new _three2.default.Vector3();
	  var oldScale = new _three2.default.Vector3();
	  var oldRotationMatrix = new _three2.default.Matrix4();

	  var parentRotationMatrix = new _three2.default.Matrix4();
	  var parentScale = new _three2.default.Vector3();

	  var worldPosition = new _three2.default.Vector3();
	  var worldRotation = new _three2.default.Euler();
	  var worldRotationMatrix = new _three2.default.Matrix4();
	  var camPosition = new _three2.default.Vector3();
	  var camRotation = new _three2.default.Euler();

	  // Object size
	  this.radius = 0;

	  // Camera moving
	  var EPS = 0.000001;
	  this.target = new _three2.default.Vector3();

	  // for reset
	  var target0 = this.target.clone();
	  var position0 = camera.position.clone();
	  var up0 = camera.up.clone();

	  this.screen = { left: 0, top: 0, width: 0, height: 0 };
	  var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };
	  var currState = STATE.NONE;
	  var prevState = STATE.NONE;

	  // Camera zoom
	  var zoomStart = new _three2.default.Vector2();
	  var zoomEnd = new _three2.default.Vector2();

	  this.zoomSpeed = 1.2;
	  this.staticMoving = false;
	  this.dynamicDampingFactor = 0.2;

	  // Camera pan
	  var panStart = new _three2.default.Vector2();
	  var panEnd = new _three2.default.Vector2();

	  this.panSpeed = 0.3;

	  // Camera rotate
	  var rotatePrev = new _three2.default.Vector2();
	  var rotateCurr = new _three2.default.Vector2();
	  var lastAxis = new _three2.default.Vector3();
	  var lastAngle = 0;

	  this.rotateSpeed = 1.0;

	  domElement.addEventListener('contextmenu', contextmenu, false);
	  domElement.addEventListener("mousedown", onPointerDown, false);
	  domElement.addEventListener("touchstart", onPointerDown, false);

	  domElement.addEventListener("mousemove", onPointerHover, false);
	  domElement.addEventListener("touchmove", onPointerHover, false);

	  domElement.addEventListener("mousemove", onPointerMove, false);
	  domElement.addEventListener("touchmove", onPointerMove, false);

	  domElement.addEventListener("mouseup", onPointerUp, false);
	  domElement.addEventListener("mouseout", onPointerUp, false);
	  domElement.addEventListener("touchend", onPointerUp, false);
	  domElement.addEventListener("touchcancel", onPointerUp, false);
	  domElement.addEventListener("touchleave", onPointerUp, false);

	  domElement.addEventListener('mousewheel', OnMouseWheel, false);

	  this.dispose = function () {

	    domElement.removeEventListener("contextmenu", contextmenu);
	    domElement.removeEventListener("mousedown", onPointerDown);
	    domElement.removeEventListener("touchstart", onPointerDown);

	    domElement.removeEventListener("mousemove", onPointerHover);
	    domElement.removeEventListener("touchmove", onPointerHover);

	    domElement.removeEventListener("mousemove", onPointerMove);
	    domElement.removeEventListener("touchmove", onPointerMove);

	    domElement.removeEventListener("mouseup", onPointerUp);
	    domElement.removeEventListener("mouseout", onPointerUp);
	    domElement.removeEventListener("touchend", onPointerUp);
	    domElement.removeEventListener("touchcancel", onPointerUp);
	    domElement.removeEventListener("touchleave", onPointerUp);
	    domElement.removeEventListener('mousewheel', OnMouseWheel);
	  };

	  this.handleResize = function () {

	    if (this.domElement === document) {

	      this.screen.left = 0;
	      this.screen.top = 0;
	      this.screen.width = window.innerWidth;
	      this.screen.height = window.innerHeight;
	    } else {

	      var box = domElement.getBoundingClientRect();
	      // adjustments come from similar code in the jquery offset() function
	      var d = domElement.ownerDocument.documentElement;
	      this.screen.left = box.left + window.pageXOffset - d.clientLeft;
	      this.screen.top = box.top + window.pageYOffset - d.clientTop;
	      this.screen.width = box.width;
	      this.screen.height = box.height;
	    }
	  };

	  this.handleResize();

	  this.handleEvent = function (event) {

	    if (typeof this[event.type] == 'function') {

	      this[event.type](event);
	    }
	  };

	  this.attach = function (object) {

	    this.object = object;
	    this.visible = true;
	    this.radius = getObjectSize(object);
	    this.update();
	  };

	  this.detach = function () {

	    this.object = undefined;
	    this.visible = false;
	    this.axis = null;
	  };

	  this.getMode = function () {

	    return _mode;
	  };

	  this.setMode = function (mode) {

	    _mode = mode ? mode : _mode;

	    if (_mode === "scale") scope.space = "local";

	    for (var type in _gizmo) {
	      _gizmo[type].visible = type === _mode;
	    }this.update();
	    scope.dispatchEvent(changeEvent);
	  };

	  this.setTranslationSnap = function (translationSnap) {

	    scope.translationSnap = translationSnap;
	  };

	  this.setRotationSnap = function (rotationSnap) {

	    scope.rotationSnap = rotationSnap;
	  };

	  this.setSize = function (size) {

	    scope.size = size;
	    this.update();
	    scope.dispatchEvent(changeEvent);
	  };

	  this.setSpace = function (space) {

	    scope.space = space;
	    this.update();
	    scope.dispatchEvent(changeEvent);
	  };

	  this.update = function () {

	    if (scope.object === undefined) return;

	    scope.object.updateMatrixWorld();
	    worldPosition.setFromMatrixPosition(scope.object.matrixWorld);
	    worldRotation.setFromRotationMatrix(tempMatrix.extractRotation(scope.object.matrixWorld));

	    camera.updateMatrixWorld();
	    camPosition.setFromMatrixPosition(camera.matrixWorld);
	    camRotation.setFromRotationMatrix(tempMatrix.extractRotation(camera.matrixWorld));

	    // scale = worldPosition.distanceTo( camPosition ) / 6 * scope.size;
	    this.position.copy(worldPosition);
	    // this.scale.set( scale, scale, scale );
	    this.scale.set(this.radius, this.radius, this.radius);

	    eyeObject.copy(camPosition).sub(worldPosition).normalize();

	    if (scope.space === "local") {

	      _gizmo[_mode].update(worldRotation, eyeObject);
	    } else if (scope.space === "world") {

	      _gizmo[_mode].update(new _three2.default.Euler(), eyeObject);
	    }

	    _gizmo[_mode].highlight(scope.axis);

	    eyeCamera.subVectors(camera.position, scope.target);
	    scope.rotateCamera();
	    scope.panCamera();
	    scope.zoomCamera();
	    zoomStart.copy(zoomEnd);
	    camera.position.addVectors(scope.target, eyeCamera);
	    camera.lookAt(scope.target);

	    scope.dispatchEvent(changeEvent);
	  };

	  this.rotateCamera = function () {
	    var axis = new _three2.default.Vector3();
	    var quaternion = new _three2.default.Quaternion();
	    var eyeDirection = new _three2.default.Vector3();
	    var cameraUp = new _three2.default.Vector3();
	    var cameraSideways = new _three2.default.Vector3();
	    var moveDirection = new _three2.default.Vector3();
	    var angle;

	    return function rotateCamera() {
	      moveDirection.set(rotateCurr.x - rotatePrev.x, rotateCurr.y - rotatePrev.y, 0);
	      angle = moveDirection.length();

	      if (angle) {
	        eyeCamera.copy(camera.position).sub(scope.target);

	        eyeDirection.copy(eyeCamera).normalize();
	        cameraUp.copy(camera.up).normalize();
	        cameraSideways.crossVectors(cameraUp, eyeDirection).normalize();

	        cameraUp.setLength(rotateCurr.y - rotatePrev.y);
	        cameraSideways.setLength(rotateCurr.x - rotatePrev.x);

	        moveDirection.copy(cameraUp.add(cameraSideways));

	        axis.crossVectors(moveDirection, eyeCamera).normalize();

	        angle *= scope.rotateSpeed;
	        quaternion.setFromAxisAngle(axis, angle);

	        eyeCamera.applyQuaternion(quaternion);
	        camera.up.applyQuaternion(quaternion);

	        lastAxis.copy(axis);
	        lastAngle = angle;
	      } else if (!scope.staticMoving && lastAngle) {
	        lastAngle *= Math.sqrt(1.0 - scope.dynamicDampingFactor);
	        eyeCamera.copy(camera.position).sub(scope.target);
	        quaternion.setFromAxisAngle(lastAxis, lastAngle);
	        eyeCamera.applyQuaternion(quaternion);
	        cameraUp.applyQuaternion(quaternion);
	      }

	      rotatePrev.copy(rotateCurr);
	    };
	  }();

	  this.panCamera = function () {

	    var mouseChange = new _three2.default.Vector2();
	    var cameraUp = new _three2.default.Vector3();
	    var pan = new _three2.default.Vector3();

	    return function panCamera() {
	      mouseChange.copy(panEnd).sub(panStart);

	      if (mouseChange.lengthSq()) {
	        mouseChange.multiplyScalar(eyeCamera.length() * scope.panSpeed);
	        pan.copy(eyeCamera).cross(camera.up).setLength(mouseChange.x);
	        pan.add(cameraUp.copy(camera.up).setLength(mouseChange.y));

	        camera.position.add(pan);
	        scope.target.add(pan);

	        if (scope.staticMoving) {
	          panStart.copy(panEnd);
	        } else {
	          panStart.add(mouseChange.subVectors(panEnd, panStart).multiplyScalar(scope.dynamicDampingFactor));
	        }
	      }
	    };
	  }();

	  this.zoomCamera = function () {

	    var factor;

	    factor = 1.0 + (zoomEnd.y - zoomStart.y) * this.zoomSpeed;

	    if (factor !== 1.0 && factor > 0.0) {

	      eyeCamera.multiplyScalar(factor);

	      if (this.staticMoving) {

	        zoomStart.copy(zoomEnd);
	      } else {

	        zoomStart.y += (zoomEnd.y - zoomStart.y) * this.dynamicDampingFactor;
	      }
	    }
	  };

	  this.reset = function () {
	    currState = STATE.NONE;
	    prevState = STATE.NONE;

	    this.target.copy(target0);
	    camera.position.copy(position0);
	    camera.up.copy(up0);

	    eyeCamera.subVectors(camera.position, this.target);
	    camera.lookAt(this.target);

	    scope.dispatchEvent(changeEvent);
	  };

	  function onPointerHover(event) {

	    if (scope.object === undefined || _dragging === true || event.button !== undefined && event.button !== 0) return;

	    var pointer = event.changedTouches ? event.changedTouches[0] : event;

	    var intersect = intersectObjects(pointer, _gizmo[_mode].pickers.children);

	    var axis = null;

	    if (intersect) {

	      axis = intersect.object.name;

	      event.preventDefault();
	    }

	    if (scope.axis !== axis) {

	      scope.axis = axis;
	      scope.update();
	      scope.dispatchEvent(changeEvent);
	    }
	  }

	  function onPointerDown(event) {

	    if (scope.object === undefined || _dragging === true) return;

	    event.preventDefault();
	    event.stopPropagation();

	    var pointer = event.changedTouches ? event.changedTouches[0] : event;
	    var intersect = false;

	    if (pointer.button === 0 || pointer.button === undefined) {

	      intersect = intersectObjects(pointer, _gizmo[_mode].pickers.children);

	      if (intersect) {

	        scope.dispatchEvent(mouseDownEvent);

	        scope.axis = intersect.object.name;

	        scope.update();

	        eyeObject.copy(camPosition).sub(worldPosition).normalize();

	        _gizmo[_mode].setActivePlane(scope.axis, eyeObject);

	        var planeIntersect = intersectObjects(pointer, [_gizmo[_mode].activePlane]);

	        if (planeIntersect) {

	          oldPosition.copy(scope.object.position);
	          oldScale.copy(scope.object.scale);

	          oldRotationMatrix.extractRotation(scope.object.matrix);
	          worldRotationMatrix.extractRotation(scope.object.matrixWorld);

	          parentRotationMatrix.extractRotation(scope.object.parent.matrixWorld);
	          parentScale.setFromMatrixScale(tempMatrix.getInverse(scope.object.parent.matrixWorld));

	          offset.copy(planeIntersect.point);
	        }
	      }
	    }

	    if (!intersect) {

	      if (currState === STATE.NONE) {
	        currState = pointer.button;
	      }

	      if (currState === STATE.ROTATE) {
	        rotateCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
	        rotatePrev.copy(rotateCurr);
	      } else if (currState === STATE.ZOOM) {} else if (currState === STATE.PAN) {
	        panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
	        panEnd.copy(panStart);
	      }

	      domElement.addEventListener('mousemove', mousemove, false);
	      domElement.addEventListener('mouseup', mouseup, false);

	      scope.dispatchEvent(startEvent);
	    }

	    _dragging = true;
	  }

	  function mousemove(event) {
	    event.preventDefault();
	    event.stopPropagation();

	    if (currState === STATE.NONE) {
	      currState = pointer.button;
	    }

	    if (currState === STATE.ROTATE) {
	      rotatePrev.copy(rotateCurr);
	      rotateCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
	    } else if (currState === STATE.ZOOM) {} else if (currState === STATE.PAN) {
	      panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
	    }
	  }

	  function mouseup(event) {
	    event.preventDefault();
	    event.stopPropagation();

	    currState = STATE.NONE;

	    domElement.removeEventListener('mousemove', mousemove);
	    domElement.removeEventListener('mouseup', mouseup);

	    scope.dispatchEvent(endEvent);
	  }

	  function onPointerMove(event) {

	    if (scope.object === undefined || scope.axis === null || _dragging === false) return;

	    var pointer = event.changedTouches ? event.changedTouches[0] : event;

	    var planeIntersect = intersectObjects(pointer, [_gizmo[_mode].activePlane]);

	    if (planeIntersect === false) return;

	    event.preventDefault();
	    event.stopPropagation();

	    point.copy(planeIntersect.point);

	    if (_mode === "translate") {

	      point.sub(offset);
	      point.multiply(parentScale);

	      if (scope.space === "local") {

	        point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

	        if (scope.axis.search("X") === -1) point.x = 0;
	        if (scope.axis.search("Y") === -1) point.y = 0;
	        if (scope.axis.search("Z") === -1) point.z = 0;

	        point.applyMatrix4(oldRotationMatrix);

	        scope.object.position.copy(oldPosition);
	        scope.object.position.add(point);
	      }

	      if (scope.space === "world" || scope.axis.search("XYZ") !== -1) {

	        if (scope.axis.search("X") === -1) point.x = 0;
	        if (scope.axis.search("Y") === -1) point.y = 0;
	        if (scope.axis.search("Z") === -1) point.z = 0;

	        point.applyMatrix4(tempMatrix.getInverse(parentRotationMatrix));

	        scope.object.position.copy(oldPosition);
	        scope.object.position.add(point);
	      }

	      if (scope.translationSnap !== null) {

	        if (scope.space === "local") {

	          scope.object.position.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));
	        }

	        if (scope.axis.search("X") !== -1) scope.object.position.x = Math.round(scope.object.position.x / scope.translationSnap) * scope.translationSnap;
	        if (scope.axis.search("Y") !== -1) scope.object.position.y = Math.round(scope.object.position.y / scope.translationSnap) * scope.translationSnap;
	        if (scope.axis.search("Z") !== -1) scope.object.position.z = Math.round(scope.object.position.z / scope.translationSnap) * scope.translationSnap;

	        if (scope.space === "local") {

	          scope.object.position.applyMatrix4(worldRotationMatrix);
	        }
	      }
	    } else if (_mode === "scale") {

	      point.sub(offset);
	      point.multiply(parentScale);

	      if (scope.space === "local") {

	        if (scope.axis === "XYZ") {

	          scale = 1 + point.y / Math.max(oldScale.x, oldScale.y, oldScale.z);

	          scope.object.scale.x = oldScale.x * scale;
	          scope.object.scale.y = oldScale.y * scale;
	          scope.object.scale.z = oldScale.z * scale;
	        } else {

	          point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

	          if (scope.axis === "X") scope.object.scale.x = oldScale.x * (1 + point.x / oldScale.x);
	          if (scope.axis === "Y") scope.object.scale.y = oldScale.y * (1 + point.y / oldScale.y);
	          if (scope.axis === "Z") scope.object.scale.z = oldScale.z * (1 + point.z / oldScale.z);
	        }
	      }
	    } else if (_mode === "rotate") {

	      point.sub(worldPosition);
	      point.multiply(parentScale);
	      tempVector.copy(offset).sub(worldPosition);
	      tempVector.multiply(parentScale);

	      if (scope.axis === "E") {

	        point.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));
	        tempVector.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));

	        rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
	        offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));

	        tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));

	        quaternionE.setFromAxisAngle(eyeObject, rotation.z - offsetRotation.z);
	        quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

	        tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionE);
	        tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

	        scope.object.quaternion.copy(tempQuaternion);
	      } else if (scope.axis === "XYZE") {

	        quaternionE.setFromEuler(point.clone().cross(tempVector).normalize()); // rotation axis

	        tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));
	        quaternionX.setFromAxisAngle(quaternionE, -point.clone().angleTo(tempVector));
	        quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

	        tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
	        tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

	        scope.object.quaternion.copy(tempQuaternion);
	      } else if (scope.space === "local") {

	        point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

	        tempVector.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

	        rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
	        offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));

	        quaternionXYZ.setFromRotationMatrix(oldRotationMatrix);

	        if (scope.rotationSnap !== null) {

	          quaternionX.setFromAxisAngle(unitX, Math.round((rotation.x - offsetRotation.x) / scope.rotationSnap) * scope.rotationSnap);
	          quaternionY.setFromAxisAngle(unitY, Math.round((rotation.y - offsetRotation.y) / scope.rotationSnap) * scope.rotationSnap);
	          quaternionZ.setFromAxisAngle(unitZ, Math.round((rotation.z - offsetRotation.z) / scope.rotationSnap) * scope.rotationSnap);
	        } else {

	          quaternionX.setFromAxisAngle(unitX, rotation.x - offsetRotation.x);
	          quaternionY.setFromAxisAngle(unitY, rotation.y - offsetRotation.y);
	          quaternionZ.setFromAxisAngle(unitZ, rotation.z - offsetRotation.z);
	        }

	        if (scope.axis === "X") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionX);
	        if (scope.axis === "Y") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionY);
	        if (scope.axis === "Z") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionZ);

	        scope.object.quaternion.copy(quaternionXYZ);
	      } else if (scope.space === "world") {

	        rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
	        offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));

	        tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));

	        if (scope.rotationSnap !== null) {

	          quaternionX.setFromAxisAngle(unitX, Math.round((rotation.x - offsetRotation.x) / scope.rotationSnap) * scope.rotationSnap);
	          quaternionY.setFromAxisAngle(unitY, Math.round((rotation.y - offsetRotation.y) / scope.rotationSnap) * scope.rotationSnap);
	          quaternionZ.setFromAxisAngle(unitZ, Math.round((rotation.z - offsetRotation.z) / scope.rotationSnap) * scope.rotationSnap);
	        } else {

	          quaternionX.setFromAxisAngle(unitX, rotation.x - offsetRotation.x);
	          quaternionY.setFromAxisAngle(unitY, rotation.y - offsetRotation.y);
	          quaternionZ.setFromAxisAngle(unitZ, rotation.z - offsetRotation.z);
	        }

	        quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

	        if (scope.axis === "X") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
	        if (scope.axis === "Y") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
	        if (scope.axis === "Z") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);

	        tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

	        scope.object.quaternion.copy(tempQuaternion);
	      }
	    }

	    scope.update();
	    scope.dispatchEvent(changeEvent);
	    scope.dispatchEvent(objectChangeEvent);
	  }

	  function onPointerUp(event) {

	    // if ( event.button !== undefined && event.button !== 0 ) return;

	    if (_dragging && scope.axis !== null) {

	      mouseUpEvent.mode = _mode;
	      scope.dispatchEvent(mouseUpEvent);
	    }

	    _dragging = false;
	    onPointerHover(event);
	  }

	  function OnMouseWheel(event) {

	    // if ( _this.enabled === false ) return;

	    event.preventDefault();
	    // event.stopPropagation();

	    var delta = 0;

	    if (event.wheelDelta) {

	      // WebKit / Opera / Explorer 9

	      delta = event.wheelDelta / 40;
	    } else if (event.detail) {

	      // Firefox

	      delta = -event.detail / 3;
	    }

	    zoomStart.y += delta * 0.01;

	    scope.dispatchEvent(startEvent);
	    scope.dispatchEvent(endEvent);
	  }

	  function intersectObjects(pointer, objects) {

	    var rect = domElement.getBoundingClientRect();
	    var x = (pointer.clientX - rect.left) / rect.width;
	    var y = (pointer.clientY - rect.top) / rect.height;

	    pointerVector.set(x * 2 - 1, -(y * 2) + 1);
	    ray.setFromCamera(pointerVector, camera);

	    var intersections = ray.intersectObjects(objects, true);
	    return intersections[0] ? intersections[0] : false;
	  }

	  function getObjectSize(object) {
	    var x_min = Number.MAX_VALUE;
	    var y_min = Number.MAX_VALUE;
	    var z_min = Number.MAX_VALUE;
	    var x_max = -Number.MAX_VALUE;
	    var y_max = -Number.MAX_VALUE;
	    var z_max = -Number.MAX_VALUE;

	    var geometry = object.geometry;

	    for (var i = 0; i < geometry.vertices.length; i++) {
	      var vertex = geometry.vertices[i];

	      if (vertex.x > x_max) x_max = vertex.x;else if (vertex.x < x_min) x_min = vertex.x;

	      if (vertex.y > y_max) y_max = vertex.y;else if (vertex.y < y_min) y_min = vertex.y;

	      if (vertex.z > z_max) z_max = vertex.z;else if (vertex.z < z_min) z_min = vertex.z;
	    }

	    return Math.max(x_max - x_min, y_max - y_min, z_max - z_min) / 2;
	  }

	  var getMouseOnScreen = function () {

	    var vector = new _three2.default.Vector2();

	    return function getMouseOnScreen(pageX, pageY) {

	      vector.set((pageX - scope.screen.left) / scope.screen.width, (pageY - scope.screen.top) / scope.screen.height);

	      return vector;
	    };
	  }();

	  var getMouseOnCircle = function () {
	    var vector = new _three2.default.Vector2();

	    return function getMouseOnCircle(pageX, pageY) {
	      vector.set((pageX - scope.screen.width * 0.5 - scope.screen.left) / (scope.screen.width * 0.5), (scope.screen.height + 2 * (scope.screen.top - pageY)) / scope.screen.width);

	      return vector;
	    };
	  }();

	  function contextmenu(event) {

	    event.preventDefault();
	  }
	};

	TransformControls.prototype = Object.create(_three2.default.Object3D.prototype);
	TransformControls.prototype.constructor = TransformControls;

	exports.default = TransformControls;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _three = __webpack_require__(2);

	var _three2 = _interopRequireDefault(_three);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var FirstPersonControls = function FirstPersonControls(object, domElement) {
	  this.object = object;
	  this.domElement = domElement !== undefined ? domElement : document;

	  // Set to false to disable this control
	  this.enabled = true;

	  this.rotateSpeed = 1.0;
	  this.moveSpeed = 10.0;

	  this.keys = {
	    LEFT: 37,
	    UP: 38,
	    RIGHT: 39,
	    BOTTOM: 40,
	    A: 'A'.charCodeAt(0),
	    S: 'S'.charCodeAt(0),
	    D: 'D'.charCodeAt(0),
	    W: 'W'.charCodeAt(0)
	  };

	  var scope = this;

	  var rotateStart = new _three2.default.Vector2();
	  var rotateEnd = new _three2.default.Vector2();
	  var rotateDelta = new _three2.default.Vector2();

	  var panStart = new _three2.default.Vector2();
	  var panEnd = new _three2.default.Vector2();
	  var panDelta = new _three2.default.Vector2();
	  var panOffset = new _three2.default.Vector3();

	  var offset = new _three2.default.Vector3();

	  var phiDelta = 0;
	  var thetaDelta = 0;
	  var scale = 1;
	  var pan = new _three2.default.Vector3();

	  var lastPosition = new _three2.default.Vector3();

	  var STATE = { NONE: -1, ROTATE: 0, SPEEDCHANGE: 1, PAN: 2 };

	  var state = STATE.NONE;

	  // for reset
	  this.position0 = this.object.position.clone();

	  // events

	  var changeEvent = { type: 'change' };
	  var startEvent = { type: 'start' };
	  var endEvent = { type: 'end' };

	  this.rotateLeft = function (angle) {
	    thetaDelta -= angle;
	  };

	  this.rotateUp = function (angle) {
	    phiDelta -= angle;
	  };

	  // pass in distance in world space to move left
	  this.panLeft = function (distance) {

	    var te = this.object.matrix.elements;

	    // get X column of matrix
	    panOffset.set(te[0], te[1], te[2]);
	    panOffset.multiplyScalar(-distance);

	    pan.add(panOffset);
	  };

	  // pass in distance in world space to move up
	  this.panUp = function (distance) {

	    var te = this.object.matrix.elements;

	    // get Y column of matrix
	    panOffset.set(te[4], te[5], te[6]);
	    panOffset.multiplyScalar(distance);

	    pan.add(panOffset);
	  };

	  // pass in distance in world space to move forward
	  this.panForward = function (distance) {

	    var te = this.object.matrix.elements;

	    // get Y column of matrix
	    panOffset.set(te[8], te[9], te[10]);
	    panOffset.multiplyScalar(distance);

	    pan.add(panOffset);
	  };

	  this.pan = function (deltaX, deltaY) {

	    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

	    if (scope.object.fov !== undefined) {
	      // perspective
	      var position = scope.object.position;
	      var offset = position.clone();
	      var targetDistance = offset.length();

	      // half of the fov is center to top of screen
	      targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);

	      // we actually don't use screenWidth, since perspective camera is fixed to screen height
	      scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);
	      scope.panUp(2 * deltaY * targetDistance / element.clientHeight);
	    } else if (scope.object.top !== undefined) {

	      // orthographic
	      scope.panLeft(deltaX * (scope.object.right - scope.object.left) / element.clientWidth);
	      scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight);
	    } else {

	      // camera neither orthographic or perspective
	      console.warn('WARNING: FirstPersonControls.js encountered an unknown camera type - pan disabled.');
	    }
	  };

	  this.update = function (delta) {
	    this.object.rotation.order = 'ZYX';

	    var object = this.object;

	    this.object = new _three2.default.Object3D();
	    this.object.position.copy(object.position);
	    this.object.rotation.copy(object.rotation);
	    this.object.updateMatrix();
	    this.object.updateMatrixWorld();

	    var position = this.object.position;

	    if (delta !== undefined) {
	      if (this.moveRight) {
	        this.panLeft(-delta * this.moveSpeed);
	      }
	      if (this.moveLeft) {
	        this.panLeft(delta * this.moveSpeed);
	      }
	      if (this.moveForward) {
	        this.panForward(-delta * this.moveSpeed);
	      }
	      if (this.moveBackward) {
	        this.panForward(delta * this.moveSpeed);
	      }
	    }

	    if (!pan.equals(new _three2.default.Vector3(0, 0, 0))) {
	      var event = {
	        type: 'move',
	        translation: pan.clone()
	      };
	      this.dispatchEvent(event);
	    }

	    position.add(pan);

	    if (!(thetaDelta === 0.0 && phiDelta === 0.0)) {
	      var event = {
	        type: 'rotate',
	        thetaDelta: thetaDelta,
	        phiDelta: phiDelta
	      };
	      this.dispatchEvent(event);
	    }

	    this.object.updateMatrix();
	    var rot = new _three2.default.Matrix4().makeRotationY(thetaDelta);
	    var res = new _three2.default.Matrix4().multiplyMatrices(rot, this.object.matrix);
	    this.object.quaternion.setFromRotationMatrix(res);

	    this.object.rotation.x += phiDelta;
	    this.object.updateMatrixWorld();

	    // send transformation proposal to listeners
	    var proposeTransformEvent = {
	      type: "proposeTransform",
	      oldPosition: object.position,
	      newPosition: this.object.position,
	      objections: 0,
	      counterProposals: []
	    };
	    this.dispatchEvent(proposeTransformEvent);

	    // check some counter proposals if transformation wasn't accepted
	    if (proposeTransformEvent.objections > 0) {
	      if (proposeTransformEvent.counterProposals.length > 0) {
	        var cp = proposeTransformEvent.counterProposals;
	        this.object.position.copy(cp[0]);

	        proposeTransformEvent.objections = 0;
	        proposeTransformEvent.counterProposals = [];
	      }
	    }

	    // apply transformation, if accepted
	    if (proposeTransformEvent.objections > 0) {} else {
	      object.position.copy(this.object.position);
	    }

	    object.rotation.copy(this.object.rotation);

	    this.object = object;

	    thetaDelta = 0;
	    phiDelta = 0;
	    scale = 1;
	    pan.set(0, 0, 0);

	    if (lastPosition.distanceTo(this.object.position) > 0) {
	      this.dispatchEvent(changeEvent);

	      lastPosition.copy(this.object.position);
	    }
	  };

	  this.reset = function () {
	    state = STATE.NONE;

	    this.object.position.copy(this.position0);
	  };

	  function onMouseDown(event) {
	    if (scope.enabled === false) return;
	    event.preventDefault();

	    if (event.button === 0) {
	      state = STATE.ROTATE;

	      rotateStart.set(event.clientX, event.clientY);
	    } else if (event.button === 2) {
	      state = STATE.PAN;

	      panStart.set(event.clientX, event.clientY);
	    }

	    scope.domElement.addEventListener('mousemove', onMouseMove, false);
	    scope.domElement.addEventListener('mouseup', onMouseUp, false);
	    scope.dispatchEvent(startEvent);
	  }

	  function onMouseMove(event) {
	    if (scope.enabled === false) return;

	    event.preventDefault();

	    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

	    if (state === STATE.ROTATE) {
	      rotateEnd.set(event.clientX, event.clientY);
	      rotateDelta.subVectors(rotateEnd, rotateStart);

	      // rotating across whole screen goes 360 degrees around
	      scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

	      // rotating up and down along whole screen attempts to go 360, but limited to 180
	      scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

	      rotateStart.copy(rotateEnd);
	    } else if (state === STATE.PAN) {
	      panEnd.set(event.clientX, event.clientY);
	      panDelta.subVectors(panEnd, panStart);
	      //panDelta.multiplyScalar(this.moveSpeed).multiplyScalar(0.0001);
	      panDelta.multiplyScalar(0.0005).multiplyScalar(scope.moveSpeed);

	      scope.pan(panDelta.x, panDelta.y);

	      panStart.copy(panEnd);
	    }
	  }

	  function onMouseUp() {
	    if (scope.enabled === false) return;

	    scope.domElement.removeEventListener('mousemove', onMouseMove, false);
	    scope.domElement.removeEventListener('mouseup', onMouseUp, false);
	    scope.dispatchEvent(endEvent);
	    state = STATE.NONE;
	  }

	  function onMouseWheel(event) {
	    if (scope.enabled === false || scope.noZoom === true) return;

	    event.preventDefault();

	    var direction = event.detail < 0 || event.wheelDelta > 0 ? 1 : -1;
	    scope.moveSpeed += scope.moveSpeed * 0.1 * direction;

	    scope.moveSpeed = Math.max(0.1, scope.moveSpeed);

	    scope.dispatchEvent(startEvent);
	    scope.dispatchEvent(endEvent);
	  }

	  function onKeyDown(event) {
	    if (scope.enabled === false) return;

	    switch (event.keyCode) {
	      case scope.keys.UP:
	        scope.moveForward = true;break;
	      case scope.keys.BOTTOM:
	        scope.moveBackward = true;break;
	      case scope.keys.LEFT:
	        scope.moveLeft = true;break;
	      case scope.keys.RIGHT:
	        scope.moveRight = true;break;
	      case scope.keys.W:
	        scope.moveForward = true;break;
	      case scope.keys.S:
	        scope.moveBackward = true;break;
	      case scope.keys.A:
	        scope.moveLeft = true;break;
	      case scope.keys.D:
	        scope.moveRight = true;break;
	    }
	  }

	  function onKeyUp(event) {
	    switch (event.keyCode) {
	      case scope.keys.W:
	        scope.moveForward = false;break;
	      case scope.keys.S:
	        scope.moveBackward = false;break;
	      case scope.keys.A:
	        scope.moveLeft = false;break;
	      case scope.keys.D:
	        scope.moveRight = false;break;
	      case scope.keys.UP:
	        scope.moveForward = false;break;
	      case scope.keys.BOTTOM:
	        scope.moveBackward = false;break;
	      case scope.keys.LEFT:
	        scope.moveLeft = false;break;
	      case scope.keys.RIGHT:
	        scope.moveRight = false;break;
	    }
	  }

	  this.domElement.addEventListener('contextmenu', function (event) {
	    event.preventDefault();
	  }, false);
	  this.domElement.addEventListener('mousedown', onMouseDown, false);
	  this.domElement.addEventListener('mousewheel', onMouseWheel, false);
	  this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox

	  window.addEventListener('keydown', onKeyDown, false);
	  window.addEventListener('keyup', onKeyUp, false);
	}; /**
	    * @author mschuetz / http://mschuetz.at
	    *
	    * adapted from THREE.OrbitControls by 
	    *
	    * @author qiao / https://github.com/qiao
	    * @author mrdoob / http://mrdoob.com
	    * @author alteredq / http://alteredqualia.com/
	    * @author WestLangley / http://github.com/WestLangley
	    * @author erich666 / http://erichaines.com
	    *
	    * This set of controls performs first person navigation without mouse lock.
	    * Instead, rotating the camera is done by dragging with the left mouse button.
	    *
	    * move: a/s/d/w or up/down/left/right
	    * rotate: left mouse
	    * pan: right mouse
	    * change speed: mouse wheel
	    *
	    *
	    */

	FirstPersonControls.prototype = Object.create(_three2.default.EventDispatcher.prototype);

	exports.default = FirstPersonControls;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _three = __webpack_require__(2);

	var _three2 = _interopRequireDefault(_three);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var EarthControls = function EarthControls(camera, renderer, scene) {
	  this.camera = camera;
	  this.renderer = renderer;
	  this.pointclouds = [];
	  this.domElement = renderer.domElement;
	  this.scene = scene;

	  // Set to false to disable this control
	  this.enabled = true;

	  var scope = this;

	  var STATE = { NONE: -1, DRAG: 0, ROTATE: 1 };

	  var state = STATE.NONE;

	  var dragStart = new _three2.default.Vector2();
	  var dragEnd = new _three2.default.Vector2();

	  var sphereGeometry = new _three2.default.SphereGeometry(1, 32, 32);
	  var sphereMaterial = new _three2.default.MeshNormalMaterial({ shading: _three2.default.SmoothShading, transparent: true, opacity: 0.5 });
	  this.pivotNode = new _three2.default.Mesh(sphereGeometry, sphereMaterial);

	  var mouseDelta = new _three2.default.Vector2();

	  var camStart = null;
	  var pivot = null;

	  this.minAngle = 10 / 180 * Math.PI; // 10
	  this.maxAngle = 70 / 180 * Math.PI; // 70

	  this.update = function (delta) {
	    var position = this.camera.position;
	    this.camera.updateMatrixWorld();

	    var proposal = new _three2.default.Object3D();
	    proposal.position.copy(this.camera.position);
	    proposal.rotation.copy(this.camera.rotation);
	    proposal.updateMatrix();
	    proposal.updateMatrixWorld();

	    if (pivot) {
	      if (state === STATE.DRAG) {
	        var plane = new _three2.default.Plane().setFromNormalAndCoplanarPoint(new _three2.default.Vector3(0, 1, 0), pivot);
	        var mouse = {
	          x: dragEnd.x / this.domElement.clientWidth * 2 - 1,
	          y: -(dragEnd.y / this.domElement.clientHeight) * 2 + 1
	        };

	        var vec = new _three2.default.Vector3(mouse.x, mouse.y, 0.5);
	        vec.unproject(camStart);
	        var dir = vec.sub(camStart.position).normalize();

	        var ray = new _three2.default.Ray(camStart.position, dir);
	        var distanceToPlane = ray.distanceToPlane(plane);

	        if (distanceToPlane > 0) {
	          var newCamPos = new _three2.default.Vector3().subVectors(pivot, dir.clone().multiplyScalar(distanceToPlane));
	          proposal.position.copy(newCamPos);
	        }
	      } else if (state === STATE.ROTATE) {
	        // rotate around pivot point

	        var diff = mouseDelta.clone().multiplyScalar(delta);
	        diff.x *= 0.3;
	        diff.y *= 0.2;

	        // do calculations on fresh nodes
	        var p = new _three2.default.Object3D();
	        var c = new _three2.default.Object3D();
	        p.add(c);
	        p.position.copy(pivot);
	        c.position.copy(this.camera.position).sub(pivot);
	        c.rotation.copy(this.camera.rotation);

	        // rotate left/right
	        p.rotation.y += -diff.x;

	        // rotate up/down
	        var dir = this.camera.getWorldDirection();
	        var up = new _three2.default.Vector3(0, 1, 0);
	        var side = new _three2.default.Vector3().crossVectors(up, dir);

	        var dirp = c.position.clone();
	        dirp.y = 0;
	        dirp.normalize();
	        var ac = dirp.dot(c.position.clone().normalize());
	        var angle = Math.acos(ac);
	        if (c.position.y < 0) {
	          angle = -angle;
	        }

	        var amount = 0;
	        if (diff.y > 0) {
	          // rotate downwards and apply minAngle limit
	          amount = diff.y - Math.max(0, this.minAngle - (angle - diff.y));
	        } else {
	          // rotate upwards and apply maxAngle limit
	          amount = diff.y + Math.max(0, angle - diff.y - this.maxAngle);
	        }
	        p.rotateOnAxis(side, -amount);

	        // apply changes to object
	        p.updateMatrixWorld();

	        proposal.position.copy(c.getWorldPosition());
	        proposal.quaternion.copy(c.getWorldQuaternion());
	      }

	      var proposeTransformEvent = {
	        type: "proposeTransform",
	        oldPosition: this.camera.position,
	        newPosition: proposal.position,
	        objections: 0
	      };
	      this.dispatchEvent(proposeTransformEvent);

	      if (proposeTransformEvent.objections > 0) {} else {
	        this.camera.position.copy(proposal.position);
	        this.camera.rotation.copy(proposal.rotation);
	      }

	      var wp = this.pivotNode.getWorldPosition().applyMatrix4(this.camera.matrixWorldInverse);
	      var w = Math.abs(wp.z / 30);
	      var l = this.pivotNode.scale.length();
	      this.pivotNode.scale.multiplyScalar(w / l);
	    }

	    mouseDelta.set(0, 0);
	  };

	  this.reset = function () {
	    state = STATE.NONE;

	    this.camera.position.copy(this.position0);
	  };

	  function onMouseDown(event) {
	    if (scope.enabled === false) return;
	    event.preventDefault();

	    var rect = scope.domElement.getBoundingClientRect();

	    var mouse = {
	      x: (event.clientX - rect.left) / scope.domElement.clientWidth * 2 - 1,
	      y: -((event.clientY - rect.top) / scope.domElement.clientHeight) * 2 + 1
	    };
	    var I = getMousePointCloudIntersection(mouse, scope.camera, scope.renderer, scope.pointclouds);
	    if (!I) {
	      return;
	    }

	    var plane = new _three2.default.Plane().setFromNormalAndCoplanarPoint(new _three2.default.Vector3(0, 1, 0), I);

	    var vec = new _three2.default.Vector3(mouse.x, mouse.y, 0.5);
	    vec.unproject(scope.camera);
	    var dir = vec.sub(scope.camera.position).normalize();

	    var ray = new _three2.default.Ray(scope.camera.position, dir);
	    pivot = ray.intersectPlane(plane);

	    //pivot = I;
	    camStart = scope.camera.clone();
	    camStart.rotation.copy(scope.camera.rotation);
	    dragStart.set(event.clientX - rect.left, event.clientY - rect.top);
	    dragEnd.set(event.clientX - rect.left, event.clientY - rect.top);

	    scope.scene.add(scope.pivotNode);
	    scope.pivotNode.position.copy(pivot);

	    if (event.button === 0) {
	      state = STATE.DRAG;
	    } else if (event.button === 2) {
	      state = STATE.ROTATE;
	    }

	    scope.domElement.addEventListener('mousemove', onMouseMove, false);
	    scope.domElement.addEventListener('mouseup', onMouseUp, false);
	  }

	  function onMouseMove(event) {
	    if (scope.enabled === false) return;

	    event.preventDefault();

	    var rect = scope.domElement.getBoundingClientRect();

	    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

	    mouseDelta.set(event.clientX - rect.left - dragEnd.x, event.clientY - rect.top - dragEnd.y);
	    dragEnd.set(event.clientX - rect.left, event.clientY - rect.top);
	  }

	  function onMouseUp() {
	    if (scope.enabled === false) return;

	    scope.domElement.removeEventListener('mousemove', onMouseMove, false);
	    scope.domElement.removeEventListener('mouseup', onMouseUp, false);
	    state = STATE.NONE;

	    //scope.dragStartIndicator.style.display = "none";
	    scope.scene.remove(scope.pivotNode);
	  }

	  function onMouseWheel(event) {
	    if (scope.enabled === false || scope.noZoom === true) return;

	    event.preventDefault();

	    var rect = scope.domElement.getBoundingClientRect();

	    var amount = event.detail < 0 || event.wheelDelta > 0 ? 1 : -1;
	    var mouse = {
	      x: (event.clientX - rect.left) / scope.domElement.clientWidth * 2 - 1,
	      y: -((event.clientY - rect.top) / scope.domElement.clientHeight) * 2 + 1
	    };
	    var I = getMousePointCloudIntersection(mouse, scope.camera, scope.renderer, scope.pointclouds);

	    if (I) {
	      var distance = I.distanceTo(scope.camera.position);
	      var dir = new _three2.default.Vector3().subVectors(I, scope.camera.position).normalize();
	      scope.camera.position.add(dir.multiplyScalar(distance * 0.1 * amount));
	    }
	  }

	  this.domElement.addEventListener('contextmenu', function (event) {
	    event.preventDefault();
	  }, false);
	  this.domElement.addEventListener('mousedown', onMouseDown, false);
	  this.domElement.addEventListener('mousewheel', onMouseWheel, false);
	  this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox
	}; /**
	    * @author mschuetz / http://mschuetz.at
	    *
	    *
	    * Navigation similar to Google Earth.
	    *
	    * left mouse: Drag with respect to intersection
	    * wheel: zoom towards/away from intersection
	    * right mouse: Rotate camera around intersection
	    *
	    *
	    */

	EarthControls.prototype = Object.create(_three2.default.EventDispatcher.prototype);

	exports.default = EarthControls;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _three = __webpack_require__(2);

	var _three2 = _interopRequireDefault(_three);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var PLYLoader = function PLYLoader(manager) {

	  this.manager = manager !== undefined ? manager : _three2.default.DefaultLoadingManager;

	  this.propertyNameMapping = {};
	}; /**
	    * @author Wei Meng / http://about.me/menway
	    *
	    * Description: A THREE loader for PLY ASCII files (known as the Polygon File Format or the Stanford Triangle Format).
	    *
	    *
	    * Limitations: ASCII decoding assumes file is UTF-8.
	    *
	    * Usage:
	    *  var loader = new PLYLoader();
	    *  loader.load('./models/ply/ascii/dolphins.ply', function (geometry) {
	    *
	    *    scene.add( new THREE.Mesh( geometry ) );
	    *
	    *  } );
	    *
	    * If the PLY file uses non standard property names, they can be mapped while
	    * loading. For example, the following maps the properties
	    * diffuse_(red|green|blue) in the file to standard color names.
	    *
	    * loader.setPropertyNameMapping( {
	    *  diffuse_red: 'red',
	    *  diffuse_green: 'green',
	    *  diffuse_blue: 'blue'
	    * } );
	    *
	    */

	PLYLoader.prototype = {

	  constructor: PLYLoader,

	  load: function load(url, onLoad, onProgress, onError) {

	    var scope = this;

	    var loader = new _three2.default.XHRLoader(this.manager);
	    loader.setResponseType('arraybuffer');
	    loader.load(url, function (text) {

	      onLoad(scope.parse(text));
	    }, onProgress, onError);
	  },

	  setPropertyNameMapping: function setPropertyNameMapping(mapping) {

	    this.propertyNameMapping = mapping;
	  },

	  bin2str: function bin2str(buf) {

	    var array_buffer = new Uint8Array(buf);
	    var str = '';
	    for (var i = 0; i < buf.byteLength; i++) {

	      str += String.fromCharCode(array_buffer[i]); // implicitly assumes little-endian
	    }

	    return str;
	  },

	  isASCII: function isASCII(data) {

	    var header = this.parseHeader(this.bin2str(data));

	    return header.format === "ascii";
	  },

	  parse: function parse(data) {

	    if (data instanceof ArrayBuffer) {

	      return this.isASCII(data) ? this.parseASCII(this.bin2str(data)) : this.parseBinary(data);
	    } else {

	      return this.parseASCII(data);
	    }
	  },

	  parseHeader: function parseHeader(data) {

	    var patternHeader = /ply([\s\S]*)end_header\s/;
	    var headerText = "";
	    var headerLength = 0;
	    var result = patternHeader.exec(data);
	    if (result !== null) {

	      headerText = result[1];
	      headerLength = result[0].length;
	    }

	    var header = {
	      comments: [],
	      elements: [],
	      headerLength: headerLength
	    };

	    var lines = headerText.split('\n');
	    var currentElement = undefined;
	    var lineType, lineValues;

	    function make_ply_element_property(propertValues, propertyNameMapping) {

	      var property = {
	        type: propertValues[0]
	      };

	      if (property.type === 'list') {

	        property.name = propertValues[3];
	        property.countType = propertValues[1];
	        property.itemType = propertValues[2];
	      } else {

	        property.name = propertValues[1];
	      }

	      if (property.name in propertyNameMapping) {

	        property.name = propertyNameMapping[property.name];
	      }

	      return property;
	    }

	    for (var i = 0; i < lines.length; i++) {

	      var line = lines[i];
	      line = line.trim();
	      if (line === "") {

	        continue;
	      }
	      lineValues = line.split(/\s+/);
	      lineType = lineValues.shift();
	      line = lineValues.join(" ");

	      switch (lineType) {

	        case "format":

	          header.format = lineValues[0];
	          header.version = lineValues[1];

	          break;

	        case "comment":

	          header.comments.push(line);

	          break;

	        case "element":

	          if (!(currentElement === undefined)) {

	            header.elements.push(currentElement);
	          }

	          currentElement = Object();
	          currentElement.name = lineValues[0];
	          currentElement.count = parseInt(lineValues[1]);
	          currentElement.properties = [];

	          break;

	        case "property":

	          currentElement.properties.push(make_ply_element_property(lineValues, this.propertyNameMapping));

	          break;

	        default:

	          console.log("unhandled", lineType, lineValues);

	      }
	    }

	    if (!(currentElement === undefined)) {

	      header.elements.push(currentElement);
	    }

	    return header;
	  },

	  parseASCIINumber: function parseASCIINumber(n, type) {

	    switch (type) {

	      case 'char':case 'uchar':case 'short':case 'ushort':case 'int':case 'uint':
	      case 'int8':case 'uint8':case 'int16':case 'uint16':case 'int32':case 'uint32':

	        return parseInt(n);

	      case 'float':case 'double':case 'float32':case 'float64':

	        return parseFloat(n);

	    }
	  },

	  parseASCIIElement: function parseASCIIElement(properties, line) {

	    var values = line.split(/\s+/);

	    var element = Object();

	    for (var i = 0; i < properties.length; i++) {

	      if (properties[i].type === "list") {

	        var list = [];
	        var n = this.parseASCIINumber(values.shift(), properties[i].countType);

	        for (var j = 0; j < n; j++) {

	          list.push(this.parseASCIINumber(values.shift(), properties[i].itemType));
	        }

	        element[properties[i].name] = list;
	      } else {

	        element[properties[i].name] = this.parseASCIINumber(values.shift(), properties[i].type);
	      }
	    }

	    return element;
	  },

	  parseASCII: function parseASCII(data) {

	    // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)

	    var geometry = new _three2.default.Geometry();

	    var result;

	    var header = this.parseHeader(data);

	    var patternBody = /end_header\s([\s\S]*)$/;
	    var body = "";
	    if ((result = patternBody.exec(data)) !== null) {

	      body = result[1];
	    }

	    var lines = body.split('\n');
	    var currentElement = 0;
	    var currentElementCount = 0;
	    geometry.useColor = false;

	    for (var i = 0; i < lines.length; i++) {

	      var line = lines[i];
	      line = line.trim();
	      if (line === "") {

	        continue;
	      }

	      if (currentElementCount >= header.elements[currentElement].count) {

	        currentElement++;
	        currentElementCount = 0;
	      }

	      var element = this.parseASCIIElement(header.elements[currentElement].properties, line);

	      this.handleElement(geometry, header.elements[currentElement].name, element);

	      currentElementCount++;
	    }

	    return this.postProcess(geometry);
	  },

	  postProcess: function postProcess(geometry) {

	    if (geometry.useColor) {

	      for (var i = 0; i < geometry.faces.length; i++) {

	        geometry.faces[i].vertexColors = [geometry.colors[geometry.faces[i].a], geometry.colors[geometry.faces[i].b], geometry.colors[geometry.faces[i].c]];
	      }

	      geometry.elementsNeedUpdate = true;
	    }

	    geometry.computeBoundingSphere();

	    return geometry;
	  },

	  handleElement: function handleElement(geometry, elementName, element) {

	    if (elementName === "vertex") {

	      geometry.vertices.push(new _three2.default.Vector3(element.x, element.y, element.z));

	      if ('red' in element && 'green' in element && 'blue' in element) {

	        geometry.useColor = true;

	        var color = new _three2.default.Color();
	        color.setRGB(element.red / 255.0, element.green / 255.0, element.blue / 255.0);
	        geometry.colors.push(color);
	      }
	    } else if (elementName === "face") {

	      var vertex_indices = element.vertex_indices;

	      if (vertex_indices.length === 3) {

	        geometry.faces.push(new _three2.default.Face3(vertex_indices[0], vertex_indices[1], vertex_indices[2]));
	      } else if (vertex_indices.length === 4) {

	        geometry.faces.push(new _three2.default.Face3(vertex_indices[0], vertex_indices[1], vertex_indices[3]), new _three2.default.Face3(vertex_indices[1], vertex_indices[2], vertex_indices[3]));
	      }
	    }
	  },

	  binaryRead: function binaryRead(dataview, at, type, little_endian) {

	    switch (type) {

	      // corespondences for non-specific length types here match rply:
	      case 'int8':case 'char':
	        return [dataview.getInt8(at), 1];

	      case 'uint8':case 'uchar':
	        return [dataview.getUint8(at), 1];

	      case 'int16':case 'short':
	        return [dataview.getInt16(at, little_endian), 2];

	      case 'uint16':case 'ushort':
	        return [dataview.getUint16(at, little_endian), 2];

	      case 'int32':case 'int':
	        return [dataview.getInt32(at, little_endian), 4];

	      case 'uint32':case 'uint':
	        return [dataview.getUint32(at, little_endian), 4];

	      case 'float32':case 'float':
	        return [dataview.getFloat32(at, little_endian), 4];

	      case 'float64':case 'double':
	        return [dataview.getFloat64(at, little_endian), 8];

	    }
	  },

	  binaryReadElement: function binaryReadElement(dataview, at, properties, little_endian) {

	    var element = Object();
	    var result,
	        read = 0;

	    for (var i = 0; i < properties.length; i++) {

	      if (properties[i].type === "list") {

	        var list = [];

	        result = this.binaryRead(dataview, at + read, properties[i].countType, little_endian);
	        var n = result[0];
	        read += result[1];

	        for (var j = 0; j < n; j++) {

	          result = this.binaryRead(dataview, at + read, properties[i].itemType, little_endian);
	          list.push(result[0]);
	          read += result[1];
	        }

	        element[properties[i].name] = list;
	      } else {

	        result = this.binaryRead(dataview, at + read, properties[i].type, little_endian);
	        element[properties[i].name] = result[0];
	        read += result[1];
	      }
	    }

	    return [element, read];
	  },

	  parseBinary: function parseBinary(data) {

	    var geometry = new _three2.default.Geometry();

	    var header = this.parseHeader(this.bin2str(data));
	    var little_endian = header.format === "binary_little_endian";
	    var body = new DataView(data, header.headerLength);
	    var result,
	        loc = 0;

	    for (var currentElement = 0; currentElement < header.elements.length; currentElement++) {

	      for (var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {

	        result = this.binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);
	        loc += result[1];
	        var element = result[0];

	        this.handleElement(geometry, header.elements[currentElement].name, element);
	      }
	    }

	    return this.postProcess(geometry);
	  }

	};

	exports.default = PLYLoader;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _three = __webpack_require__(2);

	var _three2 = _interopRequireDefault(_three);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ExtrinsicsLoader = function ExtrinsicsLoader(manager) {
	  this.manager = manager !== undefined ? manager : _three2.default.DefaultLoadingManager;
	  this.propertyNameMapping = {};
	};

	ExtrinsicsLoader.prototype = {
	  constructor: ExtrinsicsLoader,

	  load: function load(url, onLoad) {
	    var scope = this;

	    var loader = new _three2.default.XHRLoader(this.manager);
	    loader.setResponseType('text');
	    loader.load(url, function (text) {
	      onLoad(scope.text2matrix(text));
	    });
	  },

	  text2matrix: function text2matrix(text) {
	    var result = new _three2.default.Matrix4();

	    var data = text.split('\n').map(function (row) {
	      return row.split(' ').map(function (el) {
	        return parseFloat(el);
	      });
	    });
	    result.set(data[0][0], data[0][1], data[0][2], data[0][3], data[1][0], data[1][1], data[1][2], data[1][3], data[2][0], data[2][1], data[2][2], data[2][3], data[3][0], data[3][1], data[3][2], data[3][3]);

	    return result;
	  }
	};

	exports.default = ExtrinsicsLoader;

/***/ },
/* 18 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function () {
	  var urlParams = {},
	      match,
	      pl = /\+/g,
	      // Regex for replacing addition symbol with a space
	  search = /([^&=]+)=?([^&]*)/g,
	      decode = function decode(s) {
	    return decodeURIComponent(s.replace(pl, " "));
	  },
	      query = window.location.search.substring(1);

	  while (match = search.exec(query)) {
	    urlParams[decode(match[1])] = decode(match[2]);
	  }

	  return urlParams;
	};

	;

/***/ }
/******/ ]);